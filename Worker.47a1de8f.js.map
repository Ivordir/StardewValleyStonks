{"mappings":"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","sources":["node_modules/.pnpm/heap@0.2.7/node_modules/heap/lib/heap.js","fable/fable_modules/fable-library.4.0.4/Util.js","fable/fable_modules/fable-library.4.0.4/Native.js","fable/fable_modules/fable-library.4.0.4/Array.js","node_modules/.pnpm/yalps@0.5.5/node_modules/yalps/lib/module/tableau.js","node_modules/.pnpm/yalps@0.5.5/node_modules/yalps/lib/module/util.js","node_modules/.pnpm/yalps@0.5.5/node_modules/yalps/lib/module/simplex.js","node_modules/.pnpm/heap@0.2.7/node_modules/heap/index.js","node_modules/.pnpm/yalps@0.5.5/node_modules/yalps/lib/module/branchAndCut.js","node_modules/.pnpm/yalps@0.5.5/node_modules/yalps/lib/module/YALPS.js","src/WebApp/Worker.fs"],"sourcesContent":["// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","// tslint:disable:ban-types\n// Using a class here for better compatibility with TS files importing Some\nexport class Some {\n    constructor(value) {\n        this.value = value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    // Don't add \"Some\" for consistency with erased options\n    toString() {\n        return String(this.value);\n    }\n    GetHashCode() {\n        return structuralHash(this.value);\n    }\n    Equals(other) {\n        if (other == null) {\n            return false;\n        }\n        else {\n            return equals(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n    CompareTo(other) {\n        if (other == null) {\n            return 1;\n        }\n        else {\n            return compare(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n}\nexport function value(x) {\n    if (x == null) {\n        throw new Error(\"Option has no value\");\n    }\n    else {\n        return x instanceof Some ? x.value : x;\n    }\n}\nexport function isArrayLike(x) {\n    return Array.isArray(x) || ArrayBuffer.isView(x);\n}\nexport function isIterable(x) {\n    return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nexport function isEnumerable(x) {\n    return x != null && typeof x.GetEnumerator === \"function\";\n}\nexport function isComparer(x) {\n    return x != null && typeof x.Compare === \"function\";\n}\nexport function isComparable(x) {\n    return x != null && typeof x.CompareTo === \"function\";\n}\nexport function isEquatable(x) {\n    return x != null && typeof x.Equals === \"function\";\n}\nexport function isHashable(x) {\n    return x != null && typeof x.GetHashCode === \"function\";\n}\nexport function isDisposable(x) {\n    return x != null && typeof x.Dispose === \"function\";\n}\nexport function disposeSafe(x) {\n    if (isDisposable(x)) {\n        x.Dispose();\n    }\n}\nexport function defaultOf() {\n    return null;\n}\nexport function sameConstructor(x, y) {\n    return Object.getPrototypeOf(x)?.constructor === Object.getPrototypeOf(y)?.constructor;\n}\nexport class Enumerable {\n    constructor(en) {\n        this.en = en;\n    }\n    GetEnumerator() { return this.en; }\n    \"System.Collections.IEnumerable.GetEnumerator\"() { return this.en; }\n    [Symbol.iterator]() {\n        return this;\n    }\n    next() {\n        const hasNext = this.en[\"System.Collections.IEnumerator.MoveNext\"]();\n        const current = hasNext ? this.en[\"System.Collections.Generic.IEnumerator`1.get_Current\"]() : undefined;\n        return { done: !hasNext, value: current };\n    }\n}\nexport class Enumerator {\n    constructor(iter) {\n        this.iter = iter;\n        this.current = defaultOf();\n    }\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    [\"System.Collections.IEnumerator.Reset\"]() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() {\n        return;\n    }\n}\nexport function toEnumerable(e) {\n    if (isEnumerable(e)) {\n        return e;\n    }\n    else {\n        return new Enumerable(new Enumerator(e[Symbol.iterator]()));\n    }\n}\nexport function getEnumerator(e) {\n    if (isEnumerable(e)) {\n        return e.GetEnumerator();\n    }\n    else {\n        return new Enumerator(e[Symbol.iterator]());\n    }\n}\nexport function toIterator(en) {\n    return {\n        next() {\n            const hasNext = en[\"System.Collections.IEnumerator.MoveNext\"]();\n            const current = hasNext ? en[\"System.Collections.Generic.IEnumerator`1.get_Current\"]() : undefined;\n            return { done: !hasNext, value: current };\n        },\n    };\n}\nexport function enumerableToIterator(e) {\n    return toIterator(toEnumerable(e).GetEnumerator());\n}\nexport class Comparer {\n    constructor(f) {\n        this.Compare = f || compare;\n    }\n}\nexport function comparerFromEqualityComparer(comparer) {\n    // Sometimes IEqualityComparer also implements IComparer\n    if (isComparer(comparer)) {\n        return new Comparer(comparer.Compare);\n    }\n    else {\n        return new Comparer((x, y) => {\n            const xhash = comparer.GetHashCode(x);\n            const yhash = comparer.GetHashCode(y);\n            if (xhash === yhash) {\n                return comparer.Equals(x, y) ? 0 : -1;\n            }\n            else {\n                return xhash < yhash ? -1 : 1;\n            }\n        });\n    }\n}\nexport function assertEqual(actual, expected, msg) {\n    if (!equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport function assertNotEqual(actual, expected, msg) {\n    if (equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport class Lazy {\n    constructor(factory) {\n        this.factory = factory;\n        this.isValueCreated = false;\n    }\n    get Value() {\n        if (!this.isValueCreated) {\n            this.createdValue = this.factory();\n            this.isValueCreated = true;\n        }\n        return this.createdValue;\n    }\n    get IsValueCreated() {\n        return this.isValueCreated;\n    }\n}\nexport function lazyFromValue(v) {\n    return new Lazy(() => v);\n}\nexport function padWithZeros(i, length) {\n    let str = i.toString(10);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\nexport function padLeftAndRightWithZeros(i, lengthLeft, lengthRight) {\n    let str = i.toString(10);\n    while (str.length < lengthLeft) {\n        str = \"0\" + str;\n    }\n    while (str.length < lengthRight) {\n        str = str + \"0\";\n    }\n    return str;\n}\nexport function dateOffset(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\"\n        ? date1.offset\n        : (date.kind === 1 /* DateKind.UTC */\n            ? 0 : date.getTimezoneOffset() * -60000);\n}\nexport function int16ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport function int32ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nclass ObjectRef {\n    static id(o) {\n        if (!ObjectRef.idMap.has(o)) {\n            ObjectRef.idMap.set(o, ++ObjectRef.count);\n        }\n        return ObjectRef.idMap.get(o);\n    }\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nexport { ObjectRef };\nexport function stringHash(s) {\n    let i = 0;\n    let h = 5381;\n    const len = s.length;\n    while (i < len) {\n        h = (h * 33) ^ s.charCodeAt(i++);\n    }\n    return h;\n}\nexport function numberHash(x) {\n    return x * 2654435761 | 0;\n}\n// From https://stackoverflow.com/a/37449594\nexport function combineHashCodes(hashes) {\n    let h1 = 0;\n    const len = hashes.length;\n    for (let i = 0; i < len; i++) {\n        const h2 = hashes[i];\n        h1 = ((h1 << 5) + h1) ^ h2;\n    }\n    return h1;\n}\nexport function physicalHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default:\n            return numberHash(ObjectRef.id(x));\n    }\n}\nexport function identityHash(x) {\n    if (isHashable(x)) {\n        return x.GetHashCode();\n    }\n    else {\n        return physicalHash(x);\n    }\n}\nexport function dateHash(x) {\n    return x.getTime();\n}\nexport function arrayHash(x) {\n    const len = x.length;\n    const hashes = new Array(len);\n    for (let i = 0; i < len; i++) {\n        hashes[i] = structuralHash(x[i]);\n    }\n    return combineHashCodes(hashes);\n}\nexport function structuralHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default: {\n            if (isHashable(x)) {\n                return x.GetHashCode();\n            }\n            else if (isArrayLike(x)) {\n                return arrayHash(x);\n            }\n            else if (x instanceof Date) {\n                return dateHash(x);\n            }\n            else if (Object.getPrototypeOf(x)?.constructor === Object) {\n                // TODO: check call-stack to prevent cyclic objects?\n                const hashes = Object.values(x).map((v) => structuralHash(v));\n                return combineHashCodes(hashes);\n            }\n            else {\n                // Classes don't implement GetHashCode by default, but must use identity hashing\n                return numberHash(ObjectRef.id(x));\n                // return stringHash(String(x));\n            }\n        }\n    }\n}\n// Intended for custom numeric types, like long or decimal\nexport function fastStructuralHash(x) {\n    return stringHash(String(x));\n}\n// Intended for declared types that may or may not implement GetHashCode\nexport function safeHash(x) {\n    // return x == null ? 0 : isHashable(x) ? x.GetHashCode() : numberHash(ObjectRef.id(x));\n    return identityHash(x);\n}\nexport function equalArraysWith(x, y, eq) {\n    if (x == null) {\n        return y == null;\n    }\n    if (y == null) {\n        return false;\n    }\n    if (x.length !== y.length) {\n        return false;\n    }\n    for (let i = 0; i < x.length; i++) {\n        if (!eq(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equalArrays(x, y) {\n    return equalArraysWith(x, y, equals);\n}\nfunction equalObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return false;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0; i < xKeys.length; i++) {\n        if (xKeys[i] !== yKeys[i] || !equals(x[xKeys[i]], y[yKeys[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function physicalEquality(x, y) {\n    return x === y;\n}\nexport function equals(x, y) {\n    if (x === y) {\n        return true;\n    }\n    else if (x == null) {\n        return y == null;\n    }\n    else if (y == null) {\n        return false;\n    }\n    else if (isEquatable(x)) {\n        return x.Equals(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) && equalArrays(x, y);\n    }\n    else if (typeof x !== \"object\") {\n        return false;\n    }\n    else if (x instanceof Date) {\n        return (y instanceof Date) && compareDates(x, y) === 0;\n    }\n    else {\n        return Object.getPrototypeOf(x)?.constructor === Object && equalObjects(x, y);\n    }\n}\nexport function compareDates(x, y) {\n    let xtime;\n    let ytime;\n    // DateTimeOffset and DateTime deals with equality differently.\n    if (\"offset\" in x && \"offset\" in y) {\n        xtime = x.getTime();\n        ytime = y.getTime();\n    }\n    else {\n        xtime = x.getTime() + dateOffset(x);\n        ytime = y.getTime() + dateOffset(y);\n    }\n    return xtime === ytime ? 0 : (xtime < ytime ? -1 : 1);\n}\nexport function comparePrimitives(x, y) {\n    return x === y ? 0 : (x < y ? -1 : 1);\n}\nexport function compareArraysWith(x, y, comp) {\n    if (x == null) {\n        return y == null ? 0 : 1;\n    }\n    if (y == null) {\n        return -1;\n    }\n    if (x.length !== y.length) {\n        return x.length < y.length ? -1 : 1;\n    }\n    for (let i = 0, j = 0; i < x.length; i++) {\n        j = comp(x[i], y[i]);\n        if (j !== 0) {\n            return j;\n        }\n    }\n    return 0;\n}\nexport function compareArrays(x, y) {\n    return compareArraysWith(x, y, compare);\n}\nfunction compareObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return xKeys.length < yKeys.length ? -1 : 1;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0, j = 0; i < xKeys.length; i++) {\n        const key = xKeys[i];\n        if (key !== yKeys[i]) {\n            return key < yKeys[i] ? -1 : 1;\n        }\n        else {\n            j = compare(x[key], y[key]);\n            if (j !== 0) {\n                return j;\n            }\n        }\n    }\n    return 0;\n}\nexport function compare(x, y) {\n    if (x === y) {\n        return 0;\n    }\n    else if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    else if (y == null) {\n        return 1;\n    }\n    else if (isComparable(x)) {\n        return x.CompareTo(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) ? compareArrays(x, y) : -1;\n    }\n    else if (typeof x !== \"object\") {\n        return x < y ? -1 : 1;\n    }\n    else if (x instanceof Date) {\n        return y instanceof Date ? compareDates(x, y) : -1;\n    }\n    else {\n        return Object.getPrototypeOf(x)?.constructor === Object ? compareObjects(x, y) : -1;\n    }\n}\nexport function min(comparer, x, y) {\n    return comparer(x, y) < 0 ? x : y;\n}\nexport function max(comparer, x, y) {\n    return comparer(x, y) > 0 ? x : y;\n}\nexport function clamp(comparer, value, min, max) {\n    return (comparer(value, min) < 0) ? min : (comparer(value, max) > 0) ? max : value;\n}\nexport function createAtom(value) {\n    let atom = value;\n    return (...args) => {\n        if (args.length === 0) {\n            return atom;\n        }\n        else {\n            atom = args[0];\n        }\n    };\n}\nexport function createObj(fields) {\n    const obj = {};\n    for (const kv of fields) {\n        obj[kv[0]] = kv[1];\n    }\n    return obj;\n}\nexport function jsOptions(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nexport function round(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return digits ? r / m : r;\n}\nexport function sign(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nexport function unescapeDataString(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent((s).replace(/\\+/g, \"%20\"));\n}\nexport function escapeDataString(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\")\n        .replace(/'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\")\n        .replace(/\\*/g, \"%2A\");\n}\nexport function escapeUriString(s) {\n    return encodeURI(s);\n}\n// ICollection.Clear and Count members can be called on Arrays\n// or Dictionaries so we need a runtime check (see #1120)\nexport function count(col) {\n    if (isArrayLike(col)) {\n        return col.length;\n    }\n    else {\n        let count = 0;\n        for (const _ of col) {\n            count++;\n        }\n        return count;\n    }\n}\nexport function clear(col) {\n    if (isArrayLike(col)) {\n        col.splice(0);\n    }\n    else {\n        col.clear();\n    }\n}\nconst curried = new WeakMap();\nexport function uncurry2(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2) => f(a1)(a2);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry2(f) {\n    return curried.get(f) ?? ((a1) => (a2) => f(a1, a2));\n}\nexport function uncurry3(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3) => f(a1)(a2)(a3);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry3(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => f(a1, a2, a3));\n}\nexport function uncurry4(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4) => f(a1)(a2)(a3)(a4);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry4(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => f(a1, a2, a3, a4));\n}\nexport function uncurry5(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5) => f(a1)(a2)(a3)(a4)(a5);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry5(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => f(a1, a2, a3, a4, a5));\n}\nexport function uncurry6(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6) => f(a1)(a2)(a3)(a4)(a5)(a6);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry6(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => f(a1, a2, a3, a4, a5, a6));\n}\nexport function uncurry7(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry7(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => f(a1, a2, a3, a4, a5, a6, a7));\n}\nexport function uncurry8(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry8(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => f(a1, a2, a3, a4, a5, a6, a7, a8));\n}\nexport function uncurry9(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry9(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9));\n}\nexport function uncurry10(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry10(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));\n}\n// More performant method to copy arrays, see #2352\nexport function copyToArray(source, sourceIndex, target, targetIndex, count) {\n    if (ArrayBuffer.isView(source) && ArrayBuffer.isView(target)) {\n        target.set(source.subarray(sourceIndex, sourceIndex + count), targetIndex);\n    }\n    else {\n        for (let i = 0; i < count; ++i) {\n            target[targetIndex + i] = source[sourceIndex + i];\n        }\n    }\n}\n","\r\nexport function Helpers_allocateArrayFromCons(cons, len) {\r\n    if ((typeof cons) === \"function\") {\r\n        return new cons(len);\r\n    }\r\n    else {\r\n        return new Array(len);\r\n    }\r\n}\r\n\r\n","import { Helpers_allocateArrayFromCons } from \"./Native.js\";\r\nimport { value as value_2, map as map_1, defaultArg, some } from \"./Option.js\";\r\nimport { min as min_1, equals as equals_1, disposeSafe, getEnumerator, copyToArray, defaultOf, comparePrimitives, max as max_1 } from \"./Util.js\";\r\nimport { SR_indexOutOfBounds } from \"./Global.js\";\r\n\r\nfunction indexNotFound() {\r\n    throw new Error(\"An index satisfying the predicate was not found in the collection.\");\r\n}\r\n\r\nfunction differentLengths() {\r\n    throw new Error(\"Arrays had different lengths\");\r\n}\r\n\r\nexport function append(array1, array2, cons) {\r\n    const len1 = array1.length | 0;\r\n    const len2 = array2.length | 0;\r\n    const newArray = Helpers_allocateArrayFromCons(cons, len1 + len2);\r\n    for (let i = 0; i <= (len1 - 1); i++) {\r\n        newArray[i] = array1[i];\r\n    }\r\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\r\n        newArray[i_1 + len1] = array2[i_1];\r\n    }\r\n    return newArray;\r\n}\r\n\r\nexport function filter(predicate, array) {\r\n    return array.filter(predicate);\r\n}\r\n\r\nexport function fill(target, targetIndex, count, value) {\r\n    const start = targetIndex | 0;\r\n    return target.fill(value, start, (start + count));\r\n}\r\n\r\nexport function getSubArray(array, start, count) {\r\n    const start_1 = start | 0;\r\n    return array.slice(start_1, (start_1 + count));\r\n}\r\n\r\nexport function last(array) {\r\n    if (array.length === 0) {\r\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\r\n    }\r\n    return array[array.length - 1];\r\n}\r\n\r\nexport function tryLast(array) {\r\n    if (array.length === 0) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[array.length - 1]);\r\n    }\r\n}\r\n\r\nexport function mapIndexed(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const target = Helpers_allocateArrayFromCons(cons, len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = f(i, source[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function map(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const target = Helpers_allocateArrayFromCons(cons, len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = f(source[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function mapIndexed2(f, source1, source2, cons) {\r\n    if (source1.length !== source2.length) {\r\n        throw new Error(\"Arrays had different lengths\");\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(i, source1[i], source2[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function map2(f, source1, source2, cons) {\r\n    if (source1.length !== source2.length) {\r\n        throw new Error(\"Arrays had different lengths\");\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(source1[i], source2[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function mapIndexed3(f, source1, source2, source3, cons) {\r\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\r\n        throw new Error(\"Arrays had different lengths\");\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(i, source1[i], source2[i], source3[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function map3(f, source1, source2, source3, cons) {\r\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\r\n        throw new Error(\"Arrays had different lengths\");\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(source1[i], source2[i], source3[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function mapFold(mapping, state, array, cons) {\r\n    const matchValue = array.length | 0;\r\n    if (matchValue === 0) {\r\n        return [[], state];\r\n    }\r\n    else {\r\n        let acc = state;\r\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\r\n        for (let i = 0; i <= (array.length - 1); i++) {\r\n            const patternInput = mapping(acc, array[i]);\r\n            res[i] = patternInput[0];\r\n            acc = patternInput[1];\r\n        }\r\n        return [res, acc];\r\n    }\r\n}\r\n\r\nexport function mapFoldBack(mapping, array, state, cons) {\r\n    const matchValue = array.length | 0;\r\n    if (matchValue === 0) {\r\n        return [[], state];\r\n    }\r\n    else {\r\n        let acc = state;\r\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\r\n        for (let i = array.length - 1; i >= 0; i--) {\r\n            const patternInput = mapping(array[i], acc);\r\n            res[i] = patternInput[0];\r\n            acc = patternInput[1];\r\n        }\r\n        return [res, acc];\r\n    }\r\n}\r\n\r\nexport function indexed(source) {\r\n    const len = source.length | 0;\r\n    const target = new Array(len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = [i, source[i]];\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function truncate(count, array) {\r\n    const count_1 = max_1(comparePrimitives, 0, count) | 0;\r\n    return array.slice(0, (0 + count_1));\r\n}\r\n\r\nexport function concat(arrays, cons) {\r\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\r\n    const matchValue = arrays_1.length | 0;\r\n    switch (matchValue) {\r\n        case 0:\r\n            return Helpers_allocateArrayFromCons(cons, 0);\r\n        case 1:\r\n            return arrays_1[0];\r\n        default: {\r\n            let totalIdx = 0;\r\n            let totalLength = 0;\r\n            for (let idx = 0; idx <= (arrays_1.length - 1); idx++) {\r\n                const arr_1 = arrays_1[idx];\r\n                totalLength = ((totalLength + arr_1.length) | 0);\r\n            }\r\n            const result = Helpers_allocateArrayFromCons(cons, totalLength);\r\n            for (let idx_1 = 0; idx_1 <= (arrays_1.length - 1); idx_1++) {\r\n                const arr_2 = arrays_1[idx_1];\r\n                for (let j = 0; j <= (arr_2.length - 1); j++) {\r\n                    result[totalIdx] = arr_2[j];\r\n                    totalIdx = ((totalIdx + 1) | 0);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nexport function collect(mapping, array, cons) {\r\n    return concat(map(mapping, array, defaultOf()), cons);\r\n}\r\n\r\nexport function where(predicate, array) {\r\n    return array.filter(predicate);\r\n}\r\n\r\nexport function indexOf(array, item_1, start, count, eq) {\r\n    const start_1 = defaultArg(start, 0) | 0;\r\n    const end$0027 = defaultArg(map_1((c) => (start_1 + c), count), array.length) | 0;\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= end$0027) {\r\n                return -1;\r\n            }\r\n            else if (eq.Equals(item_1, array[i])) {\r\n                return i | 0;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(start_1) | 0;\r\n}\r\n\r\nexport function contains(value, array, eq) {\r\n    return indexOf(array, value, void 0, void 0, eq) >= 0;\r\n}\r\n\r\nexport function empty(cons) {\r\n    return Helpers_allocateArrayFromCons(cons, 0);\r\n}\r\n\r\nexport function singleton(value, cons) {\r\n    const ar = Helpers_allocateArrayFromCons(cons, 1);\r\n    ar[0] = value;\r\n    return ar;\r\n}\r\n\r\nexport function initialize(count, initializer, cons) {\r\n    if (count < 0) {\r\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, count);\r\n    for (let i = 0; i <= (count - 1); i++) {\r\n        result[i] = initializer(i);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function pairwise(array) {\r\n    if (array.length < 2) {\r\n        return [];\r\n    }\r\n    else {\r\n        const count = (array.length - 1) | 0;\r\n        const result = new Array(count);\r\n        for (let i = 0; i <= (count - 1); i++) {\r\n            result[i] = [array[i], array[i + 1]];\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function replicate(count, initial, cons) {\r\n    if (count < 0) {\r\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, count);\r\n    for (let i = 0; i <= (result.length - 1); i++) {\r\n        result[i] = initial;\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function copy(array) {\r\n    return array.slice();\r\n}\r\n\r\nexport function copyTo(source, sourceIndex, target, targetIndex, count) {\r\n    copyToArray(source, sourceIndex, target, targetIndex, count);\r\n}\r\n\r\nexport function reverse(array) {\r\n    const array_2 = array.slice();\r\n    return array_2.reverse();\r\n}\r\n\r\nexport function scan(folder, state, array, cons) {\r\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\r\n    res[0] = state;\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        res[i + 1] = folder(res[i], array[i]);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function scanBack(folder, array, state, cons) {\r\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\r\n    res[array.length] = state;\r\n    for (let i = array.length - 1; i >= 0; i--) {\r\n        res[i] = folder(array[i], res[i + 1]);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function skip(count, array, cons) {\r\n    if (count > array.length) {\r\n        throw new Error(\"count is greater than array length\\\\nParameter name: count\");\r\n    }\r\n    if (count === array.length) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const count_1 = ((count < 0) ? 0 : count) | 0;\r\n        return array.slice(count_1);\r\n    }\r\n}\r\n\r\nexport function skipWhile(predicate, array, cons) {\r\n    let count = 0;\r\n    while ((count < array.length) && predicate(array[count])) {\r\n        count = ((count + 1) | 0);\r\n    }\r\n    if (count === array.length) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const count_1 = count | 0;\r\n        return array.slice(count_1);\r\n    }\r\n}\r\n\r\nexport function take(count, array, cons) {\r\n    if (count < 0) {\r\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\r\n    }\r\n    if (count > array.length) {\r\n        throw new Error(\"count is greater than array length\\\\nParameter name: count\");\r\n    }\r\n    if (count === 0) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        return array.slice(0, (0 + count));\r\n    }\r\n}\r\n\r\nexport function takeWhile(predicate, array, cons) {\r\n    let count = 0;\r\n    while ((count < array.length) && predicate(array[count])) {\r\n        count = ((count + 1) | 0);\r\n    }\r\n    if (count === 0) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const count_1 = count | 0;\r\n        return array.slice(0, (0 + count_1));\r\n    }\r\n}\r\n\r\nexport function addInPlace(x, array) {\r\n    array.push(x);\r\n}\r\n\r\nexport function addRangeInPlace(range, array) {\r\n    const enumerator = getEnumerator(range);\r\n    try {\r\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            addInPlace(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), array);\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(enumerator);\r\n    }\r\n}\r\n\r\nexport function insertRangeInPlace(index, range, array) {\r\n    let index_1;\r\n    let i = index;\r\n    const enumerator = getEnumerator(range);\r\n    try {\r\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            (index_1 = (i | 0), array.splice(index_1, 0, x));\r\n            i = ((i + 1) | 0);\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(enumerator);\r\n    }\r\n}\r\n\r\nexport function removeInPlace(item_1, array, eq) {\r\n    const i = indexOf(array, item_1, void 0, void 0, eq) | 0;\r\n    if (i > -1) {\r\n        array.splice(i, 1);\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function removeAllInPlace(predicate, array) {\r\n    const countRemoveAll = (count) => {\r\n        const i = (array.findIndex(predicate)) | 0;\r\n        if (i > -1) {\r\n            array.splice(i, 1);\r\n            return (countRemoveAll(count) + 1) | 0;\r\n        }\r\n        else {\r\n            return count | 0;\r\n        }\r\n    };\r\n    return countRemoveAll(0) | 0;\r\n}\r\n\r\nexport function partition(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const res1 = Helpers_allocateArrayFromCons(cons, len);\r\n    const res2 = Helpers_allocateArrayFromCons(cons, len);\r\n    let iTrue = 0;\r\n    let iFalse = 0;\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        if (f(source[i])) {\r\n            res1[iTrue] = source[i];\r\n            iTrue = ((iTrue + 1) | 0);\r\n        }\r\n        else {\r\n            res2[iFalse] = source[i];\r\n            iFalse = ((iFalse + 1) | 0);\r\n        }\r\n    }\r\n    return [truncate(iTrue, res1), truncate(iFalse, res2)];\r\n}\r\n\r\nexport function find(predicate, array) {\r\n    const matchValue = array.find(predicate);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_2(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFind(predicate, array) {\r\n    return array.find(predicate);\r\n}\r\n\r\nexport function findIndex(predicate, array) {\r\n    const matchValue = (array.findIndex(predicate)) | 0;\r\n    if (matchValue > -1) {\r\n        return matchValue | 0;\r\n    }\r\n    else {\r\n        indexNotFound();\r\n        return -1;\r\n    }\r\n}\r\n\r\nexport function tryFindIndex(predicate, array) {\r\n    const matchValue = (array.findIndex(predicate)) | 0;\r\n    if (matchValue > -1) {\r\n        return matchValue;\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function pick(chooser, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= array.length) {\r\n                return indexNotFound();\r\n            }\r\n            else {\r\n                const matchValue = chooser(array[i]);\r\n                if (matchValue != null) {\r\n                    return value_2(matchValue);\r\n                }\r\n                else {\r\n                    i_mut = (i + 1);\r\n                    continue loop;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0);\r\n}\r\n\r\nexport function tryPick(chooser, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= array.length) {\r\n                return void 0;\r\n            }\r\n            else {\r\n                const matchValue = chooser(array[i]);\r\n                if (matchValue == null) {\r\n                    i_mut = (i + 1);\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return matchValue;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0);\r\n}\r\n\r\nexport function findBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return indexNotFound();\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return array[i];\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function tryFindBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return void 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return some(array[i]);\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function findLastIndex(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return -1;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i | 0;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1) | 0;\r\n}\r\n\r\nexport function findIndexBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                indexNotFound();\r\n                return -1;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i | 0;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1) | 0;\r\n}\r\n\r\nexport function tryFindIndexBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return void 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function choose(chooser, array, cons) {\r\n    const res = [];\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        const matchValue = chooser(array[i]);\r\n        if (matchValue != null) {\r\n            const y = value_2(matchValue);\r\n            res.push(y);\r\n        }\r\n    }\r\n    if (equals_1(cons, defaultOf())) {\r\n        return res;\r\n    }\r\n    else {\r\n        return map((x) => x, res, cons);\r\n    }\r\n}\r\n\r\nexport function foldIndexed(folder, state, array) {\r\n    return array.reduce(((delegateArg, delegateArg_1, delegateArg_2) => folder(delegateArg_2, delegateArg, delegateArg_1)), state);\r\n}\r\n\r\nexport function fold(folder, state, array) {\r\n    return array.reduce((folder), state);\r\n}\r\n\r\nexport function iterate(action, array) {\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        action(array[i]);\r\n    }\r\n}\r\n\r\nexport function iterateIndexed(action, array) {\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        action(i, array[i]);\r\n    }\r\n}\r\n\r\nexport function iterate2(action, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        action(array1[i], array2[i]);\r\n    }\r\n}\r\n\r\nexport function iterateIndexed2(action, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        action(i, array1[i], array2[i]);\r\n    }\r\n}\r\n\r\nexport function isEmpty(array) {\r\n    return array.length === 0;\r\n}\r\n\r\nexport function forAll(predicate, array) {\r\n    return array.every(predicate);\r\n}\r\n\r\nexport function permute(f, array) {\r\n    const size = array.length | 0;\r\n    const res = array.slice();\r\n    const checkFlags = new Array(size);\r\n    iterateIndexed((i, x) => {\r\n        const j = f(i) | 0;\r\n        if ((j < 0) ? true : (j >= size)) {\r\n            throw new Error(\"Not a valid permutation\");\r\n        }\r\n        res[j] = x;\r\n        checkFlags[j] = 1;\r\n    }, array);\r\n    if (!(checkFlags.every((y) => (1 === y)))) {\r\n        throw new Error(\"Not a valid permutation\");\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function setSlice(target, lower, upper, source) {\r\n    const lower_1 = defaultArg(lower, 0) | 0;\r\n    const upper_1 = defaultArg(upper, -1) | 0;\r\n    const length = (((upper_1 >= 0) ? upper_1 : (target.length - 1)) - lower_1) | 0;\r\n    for (let i = 0; i <= length; i++) {\r\n        target[i + lower_1] = source[i];\r\n    }\r\n}\r\n\r\nexport function sortInPlaceBy(projection, xs, comparer) {\r\n    xs.sort((x, y) => comparer.Compare(projection(x), projection(y)));\r\n}\r\n\r\nexport function sortInPlace(xs, comparer) {\r\n    xs.sort((x, y) => comparer.Compare(x, y));\r\n}\r\n\r\nexport function sort(xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort((x, y) => comparer.Compare(x, y));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortBy(projection, xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort((x, y) => comparer.Compare(projection(x), projection(y)));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortDescending(xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort((x, y) => (comparer.Compare(x, y) * -1));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortByDescending(projection, xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort((x, y) => (comparer.Compare(projection(x), projection(y)) * -1));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortWith(comparer, xs) {\r\n    const comparer_1 = comparer;\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort(comparer_1);\r\n    return xs_1;\r\n}\r\n\r\nexport function allPairs(xs, ys) {\r\n    const len1 = xs.length | 0;\r\n    const len2 = ys.length | 0;\r\n    const res = new Array(len1 * len2);\r\n    for (let i = 0; i <= (xs.length - 1); i++) {\r\n        for (let j = 0; j <= (ys.length - 1); j++) {\r\n            res[(i * len2) + j] = [xs[i], ys[j]];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function unfold(generator, state) {\r\n    const res = [];\r\n    const loop = (state_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const state_1 = state_1_mut;\r\n            const matchValue = generator(state_1);\r\n            if (matchValue != null) {\r\n                const x = matchValue[0];\r\n                const s = matchValue[1];\r\n                res.push(x);\r\n                state_1_mut = s;\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    loop(state);\r\n    return res;\r\n}\r\n\r\nexport function unzip(array) {\r\n    const len = array.length | 0;\r\n    const res1 = new Array(len);\r\n    const res2 = new Array(len);\r\n    iterateIndexed((i, tupledArg) => {\r\n        res1[i] = tupledArg[0];\r\n        res2[i] = tupledArg[1];\r\n    }, array);\r\n    return [res1, res2];\r\n}\r\n\r\nexport function unzip3(array) {\r\n    const len = array.length | 0;\r\n    const res1 = new Array(len);\r\n    const res2 = new Array(len);\r\n    const res3 = new Array(len);\r\n    iterateIndexed((i, tupledArg) => {\r\n        res1[i] = tupledArg[0];\r\n        res2[i] = tupledArg[1];\r\n        res3[i] = tupledArg[2];\r\n    }, array);\r\n    return [res1, res2, res3];\r\n}\r\n\r\nexport function zip(array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    const result = new Array(array1.length);\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        result[i] = [array1[i], array2[i]];\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function zip3(array1, array2, array3) {\r\n    if ((array1.length !== array2.length) ? true : (array2.length !== array3.length)) {\r\n        differentLengths();\r\n    }\r\n    const result = new Array(array1.length);\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        result[i] = [array1[i], array2[i], array3[i]];\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function chunkBySize(chunkSize, array) {\r\n    if (chunkSize < 1) {\r\n        throw new Error(\"The input must be positive.\\\\nParameter name: size\");\r\n    }\r\n    if (array.length === 0) {\r\n        return [[]];\r\n    }\r\n    else {\r\n        const result = [];\r\n        for (let x = 0; x <= (~~Math.ceil(array.length / chunkSize) - 1); x++) {\r\n            let slice;\r\n            const start_1 = (x * chunkSize) | 0;\r\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\r\n            result.push(slice);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function splitAt(index, array) {\r\n    if ((index < 0) ? true : (index > array.length)) {\r\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\r\n    }\r\n    return [array.slice(0, (0 + index)), array.slice(index)];\r\n}\r\n\r\nexport function compareWith(comparer, source1, source2) {\r\n    if (source1 == null) {\r\n        if (source2 == null) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    else if (source2 == null) {\r\n        return 1;\r\n    }\r\n    else {\r\n        const len1 = source1.length | 0;\r\n        const len2 = source2.length | 0;\r\n        const len = ((len1 < len2) ? len1 : len2) | 0;\r\n        let i = 0;\r\n        let res = 0;\r\n        while ((res === 0) && (i < len)) {\r\n            res = (comparer(source1[i], source2[i]) | 0);\r\n            i = ((i + 1) | 0);\r\n        }\r\n        if (res !== 0) {\r\n            return res | 0;\r\n        }\r\n        else if (len1 > len2) {\r\n            return 1;\r\n        }\r\n        else if (len1 < len2) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport function compareTo(comparer, source1, source2) {\r\n    if (source1 == null) {\r\n        if (source2 == null) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    else if (source2 == null) {\r\n        return 1;\r\n    }\r\n    else {\r\n        const len1 = source1.length | 0;\r\n        const len2 = source2.length | 0;\r\n        if (len1 > len2) {\r\n            return 1;\r\n        }\r\n        else if (len1 < len2) {\r\n            return -1;\r\n        }\r\n        else {\r\n            let i = 0;\r\n            let res = 0;\r\n            while ((res === 0) && (i < len1)) {\r\n                res = (comparer(source1[i], source2[i]) | 0);\r\n                i = ((i + 1) | 0);\r\n            }\r\n            return res | 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport function equalsWith(equals, array1, array2) {\r\n    if (array1 == null) {\r\n        if (array2 == null) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else if (array2 == null) {\r\n        return false;\r\n    }\r\n    else {\r\n        let i = 0;\r\n        let result = true;\r\n        const length1 = array1.length | 0;\r\n        const length2 = array2.length | 0;\r\n        if (length1 > length2) {\r\n            return false;\r\n        }\r\n        else if (length1 < length2) {\r\n            return false;\r\n        }\r\n        else {\r\n            while ((i < length1) && result) {\r\n                result = equals(array1[i], array2[i]);\r\n                i = ((i + 1) | 0);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nexport function exactlyOne(array) {\r\n    if (array.length === 1) {\r\n        return array[0];\r\n    }\r\n    else if (array.length === 0) {\r\n        throw new Error(\"The input sequence was empty\\\\nParameter name: array\");\r\n    }\r\n    else {\r\n        throw new Error(\"Input array too long\\\\nParameter name: array\");\r\n    }\r\n}\r\n\r\nexport function tryExactlyOne(array) {\r\n    if (array.length === 1) {\r\n        return some(array[0]);\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function head(array) {\r\n    if (array.length === 0) {\r\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\r\n    }\r\n    else {\r\n        return array[0];\r\n    }\r\n}\r\n\r\nexport function tryHead(array) {\r\n    if (array.length === 0) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[0]);\r\n    }\r\n}\r\n\r\nexport function tail(array) {\r\n    if (array.length === 0) {\r\n        throw new Error(\"Not enough elements\\\\nParameter name: array\");\r\n    }\r\n    return array.slice(1);\r\n}\r\n\r\nexport function item(index, array) {\r\n    return array[index];\r\n}\r\n\r\nexport function tryItem(index, array) {\r\n    if ((index < 0) ? true : (index >= array.length)) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[index]);\r\n    }\r\n}\r\n\r\nexport function foldBackIndexed(folder, array, state) {\r\n    return array.reduceRight(((delegateArg, delegateArg_1, delegateArg_2) => folder(delegateArg_2, delegateArg_1, delegateArg)), state);\r\n}\r\n\r\nexport function foldBack(folder, array, state) {\r\n    return array.reduceRight(((delegateArg, delegateArg_1) => folder(delegateArg_1, delegateArg)), state);\r\n}\r\n\r\nexport function foldIndexed2(folder, state, array1, array2) {\r\n    let acc = state;\r\n    if (array1.length !== array2.length) {\r\n        throw new Error(\"Arrays have different lengths\");\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        acc = folder(i, acc, array1[i], array2[i]);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function fold2(folder, state, array1, array2) {\r\n    return foldIndexed2((_arg, acc, x, y) => folder(acc, x, y), state, array1, array2);\r\n}\r\n\r\nexport function foldBackIndexed2(folder, array1, array2, state) {\r\n    let acc = state;\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    const size = array1.length | 0;\r\n    for (let i = 1; i <= size; i++) {\r\n        acc = folder(i - 1, array1[size - i], array2[size - i], acc);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function foldBack2(f, array1, array2, state) {\r\n    return foldBackIndexed2((_arg, x, y, acc) => f(x, y, acc), array1, array2, state);\r\n}\r\n\r\nexport function reduce(reduction, array) {\r\n    if (array.length === 0) {\r\n        throw new Error(\"The input array was empty\");\r\n    }\r\n    const reduction_1 = reduction;\r\n    return array.reduce(reduction_1);\r\n}\r\n\r\nexport function reduceBack(reduction, array) {\r\n    if (array.length === 0) {\r\n        throw new Error(\"The input array was empty\");\r\n    }\r\n    const reduction_1 = reduction;\r\n    return array.reduceRight(reduction_1);\r\n}\r\n\r\nexport function forAll2(predicate, array1, array2) {\r\n    return fold2((acc, x, y) => (acc && predicate(x, y)), true, array1, array2);\r\n}\r\n\r\nexport function existsOffset(predicate_mut, array_mut, index_mut) {\r\n    existsOffset:\r\n    while (true) {\r\n        const predicate = predicate_mut, array = array_mut, index = index_mut;\r\n        if (index === array.length) {\r\n            return false;\r\n        }\r\n        else if (predicate(array[index])) {\r\n            return true;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            array_mut = array;\r\n            index_mut = (index + 1);\r\n            continue existsOffset;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function exists(predicate, array) {\r\n    return existsOffset(predicate, array, 0);\r\n}\r\n\r\nexport function existsOffset2(predicate_mut, array1_mut, array2_mut, index_mut) {\r\n    existsOffset2:\r\n    while (true) {\r\n        const predicate = predicate_mut, array1 = array1_mut, array2 = array2_mut, index = index_mut;\r\n        if (index === array1.length) {\r\n            return false;\r\n        }\r\n        else if (predicate(array1[index], array2[index])) {\r\n            return true;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            array1_mut = array1;\r\n            array2_mut = array2;\r\n            index_mut = (index + 1);\r\n            continue existsOffset2;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function exists2(predicate, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    return existsOffset2(predicate, array1, array2, 0);\r\n}\r\n\r\nexport function sum(array, adder) {\r\n    let acc = adder.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        acc = adder.Add(acc, array[i]);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function sumBy(projection, array, adder) {\r\n    let acc = adder.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        acc = adder.Add(acc, projection(array[i]));\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function maxBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function max(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function minBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function min(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function average(array, averager) {\r\n    if (array.length === 0) {\r\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\r\n    }\r\n    let total = averager.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        total = averager.Add(total, array[i]);\r\n    }\r\n    return averager.DivideByInt(total, array.length);\r\n}\r\n\r\nexport function averageBy(projection, array, averager) {\r\n    if (array.length === 0) {\r\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\r\n    }\r\n    let total = averager.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        total = averager.Add(total, projection(array[i]));\r\n    }\r\n    return averager.DivideByInt(total, array.length);\r\n}\r\n\r\nexport function windowed(windowSize, source) {\r\n    if (windowSize <= 0) {\r\n        throw new Error(\"windowSize must be positive\");\r\n    }\r\n    let res;\r\n    const len = max_1(comparePrimitives, 0, (source.length - windowSize) + 1) | 0;\r\n    res = (new Array(len));\r\n    for (let i = windowSize; i <= source.length; i++) {\r\n        res[i - windowSize] = source.slice(i - windowSize, (i - 1) + 1);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function splitInto(chunks, array) {\r\n    if (chunks < 1) {\r\n        throw new Error(\"The input must be positive.\\\\nParameter name: chunks\");\r\n    }\r\n    if (array.length === 0) {\r\n        return [[]];\r\n    }\r\n    else {\r\n        const result = [];\r\n        const chunks_1 = min_1(comparePrimitives, chunks, array.length) | 0;\r\n        const minChunkSize = ~~(array.length / chunks_1) | 0;\r\n        const chunksWithExtraItem = (array.length % chunks_1) | 0;\r\n        for (let i = 0; i <= (chunks_1 - 1); i++) {\r\n            const chunkSize = ((i < chunksWithExtraItem) ? (minChunkSize + 1) : minChunkSize) | 0;\r\n            let slice;\r\n            const start_1 = ((i * minChunkSize) + min_1(comparePrimitives, chunksWithExtraItem, i)) | 0;\r\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\r\n            result.push(slice);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function transpose(arrays, cons) {\r\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\r\n    const len = arrays_1.length | 0;\r\n    if (len === 0) {\r\n        return new Array(0);\r\n    }\r\n    else {\r\n        const firstArray = arrays_1[0];\r\n        const lenInner = firstArray.length | 0;\r\n        if (!forAll((a) => (a.length === lenInner), arrays_1)) {\r\n            differentLengths();\r\n        }\r\n        const result = new Array(lenInner);\r\n        for (let i = 0; i <= (lenInner - 1); i++) {\r\n            result[i] = Helpers_allocateArrayFromCons(cons, len);\r\n            for (let j = 0; j <= (len - 1); j++) {\r\n                result[i][j] = arrays_1[j][i];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function insertAt(index, y, xs, cons) {\r\n    const len = xs.length | 0;\r\n    if ((index < 0) ? true : (index > len)) {\r\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\r\n    }\r\n    const target = Helpers_allocateArrayFromCons(cons, len + 1);\r\n    for (let i = 0; i <= (index - 1); i++) {\r\n        target[i] = xs[i];\r\n    }\r\n    target[index] = y;\r\n    for (let i_1 = index; i_1 <= (len - 1); i_1++) {\r\n        target[i_1 + 1] = xs[i_1];\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function insertManyAt(index, ys, xs, cons) {\r\n    const len = xs.length | 0;\r\n    if ((index < 0) ? true : (index > len)) {\r\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\r\n    }\r\n    const ys_1 = Array.from(ys);\r\n    const len2 = ys_1.length | 0;\r\n    const target = Helpers_allocateArrayFromCons(cons, len + len2);\r\n    for (let i = 0; i <= (index - 1); i++) {\r\n        target[i] = xs[i];\r\n    }\r\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\r\n        target[index + i_1] = ys_1[i_1];\r\n    }\r\n    for (let i_2 = index; i_2 <= (len - 1); i_2++) {\r\n        target[i_2 + len2] = xs[i_2];\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function removeAt(index, xs) {\r\n    if ((index < 0) ? true : (index >= xs.length)) {\r\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\r\n    }\r\n    let i = -1;\r\n    return filter((_arg) => {\r\n        i = ((i + 1) | 0);\r\n        return i !== index;\r\n    }, xs);\r\n}\r\n\r\nexport function removeManyAt(index, count, xs) {\r\n    let i = -1;\r\n    let status = -1;\r\n    const ys = filter((_arg) => {\r\n        i = ((i + 1) | 0);\r\n        if (i === index) {\r\n            status = 0;\r\n            return false;\r\n        }\r\n        else if (i > index) {\r\n            if (i < (index + count)) {\r\n                return false;\r\n            }\r\n            else {\r\n                status = 1;\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }, xs);\r\n    const status_1 = (((status === 0) && ((i + 1) === (index + count))) ? 1 : status) | 0;\r\n    if (status_1 < 1) {\r\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + ((status_1 < 0) ? \"index\" : \"count\"));\r\n    }\r\n    return ys;\r\n}\r\n\r\nexport function updateAt(index, y, xs, cons) {\r\n    const len = xs.length | 0;\r\n    if ((index < 0) ? true : (index >= len)) {\r\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\r\n    }\r\n    const target = Helpers_allocateArrayFromCons(cons, len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = ((i === index) ? y : xs[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\n","export const index = (tableau, row, col) => tableau.matrix[Math.imul(row, tableau.width) + col];\nexport const update = (tableau, row, col, value) => {\n    tableau.matrix[Math.imul(row, tableau.width) + col] = value;\n};\nconst convertToIterable = (seq) => typeof seq[Symbol.iterator] === \"function\" // eslint-disable-line\n    ? seq\n    : Object.entries(seq);\n// prettier-ignore\nconst convertToSet = (set) => set === true ? true\n    : set === false ? new Set()\n        : set instanceof Set ? set\n            : new Set(set);\nexport const tableauModel = (model) => {\n    const { direction, objective, integers, binaries } = model;\n    const sign = direction === \"minimize\" ? -1.0 : 1.0;\n    const constraintsIter = convertToIterable(model.constraints);\n    const variablesIter = convertToIterable(model.variables);\n    const variables = Array.isArray(variablesIter) ? variablesIter : Array.from(variablesIter);\n    const binaryConstraintCol = [];\n    const ints = [];\n    if (integers != null || binaries != null) {\n        const binaryVariables = convertToSet(binaries);\n        const integerVariables = binaryVariables === true ? true : convertToSet(integers);\n        for (let i = 1; i <= variables.length; i++) {\n            const [key] = variables[i - 1];\n            if (binaryVariables === true || binaryVariables.has(key)) {\n                binaryConstraintCol.push(i);\n                ints.push(i);\n            }\n            else if (integerVariables === true || integerVariables.has(key)) {\n                ints.push(i);\n            }\n        }\n    }\n    const constraints = new Map();\n    for (const [key, constraint] of constraintsIter) {\n        const bounds = constraints.get(key) ?? { row: NaN, lower: -Infinity, upper: Infinity };\n        bounds.lower = Math.max(bounds.lower, constraint.equal ?? constraint.min ?? -Infinity);\n        bounds.upper = Math.min(bounds.upper, constraint.equal ?? constraint.max ?? Infinity);\n        // if (rows.lower > rows.upper) return [\"infeasible\", NaN]\n        if (!constraints.has(key))\n            constraints.set(key, bounds);\n    }\n    let numConstraints = 1;\n    for (const constraint of constraints.values()) {\n        constraint.row = numConstraints;\n        numConstraints += (Number.isFinite(constraint.lower) ? 1 : 0) + (Number.isFinite(constraint.upper) ? 1 : 0);\n    }\n    const width = variables.length + 1;\n    const height = numConstraints + binaryConstraintCol.length;\n    const numVars = width + height;\n    const matrix = new Float64Array(width * height);\n    const positionOfVariable = new Int32Array(numVars);\n    const variableAtPosition = new Int32Array(numVars);\n    const tableau = { matrix, width, height, positionOfVariable, variableAtPosition };\n    for (let i = 0; i < numVars; i++) {\n        positionOfVariable[i] = i;\n        variableAtPosition[i] = i;\n    }\n    for (let c = 1; c < width; c++) {\n        for (const [constraint, coef] of convertToIterable(variables[c - 1][1])) {\n            if (constraint === objective) {\n                update(tableau, 0, c, sign * coef);\n            }\n            const bounds = constraints.get(constraint);\n            if (bounds != null) {\n                if (Number.isFinite(bounds.upper)) {\n                    update(tableau, bounds.row, c, coef);\n                    if (Number.isFinite(bounds.lower)) {\n                        update(tableau, bounds.row + 1, c, -coef);\n                    }\n                }\n                else if (Number.isFinite(bounds.lower)) {\n                    update(tableau, bounds.row, c, -coef);\n                }\n            }\n        }\n    }\n    for (const bounds of constraints.values()) {\n        if (Number.isFinite(bounds.upper)) {\n            update(tableau, bounds.row, 0, bounds.upper);\n            if (Number.isFinite(bounds.lower)) {\n                update(tableau, bounds.row + 1, 0, -bounds.lower);\n            }\n        }\n        else if (Number.isFinite(bounds.lower)) {\n            update(tableau, bounds.row, 0, -bounds.lower);\n        }\n    }\n    for (let b = 0; b < binaryConstraintCol.length; b++) {\n        const row = numConstraints + b;\n        update(tableau, row, 0, 1.0);\n        update(tableau, row, binaryConstraintCol[b], 1.0);\n    }\n    return { tableau, sign, variables, integers: ints };\n};\n","export const roundToPrecision = (num, precision) => {\n    const rounding = Math.round(1.0 / precision);\n    return Math.round((num + Number.EPSILON) * rounding) / rounding;\n};\n","import { index, update } from \"./tableau.js\";\nimport { roundToPrecision } from \"./util.js\";\nconst pivot = (tableau, row, col) => {\n    const quotient = index(tableau, row, col);\n    const leaving = tableau.variableAtPosition[tableau.width + row];\n    const entering = tableau.variableAtPosition[col];\n    tableau.variableAtPosition[tableau.width + row] = entering;\n    tableau.variableAtPosition[col] = leaving;\n    tableau.positionOfVariable[leaving] = col;\n    tableau.positionOfVariable[entering] = tableau.width + row;\n    const nonZeroColumns = [];\n    // (1 / quotient) * R_pivot -> R_pivot\n    for (let c = 0; c < tableau.width; c++) {\n        const value = index(tableau, row, c);\n        if (Math.abs(value) > 1e-16) {\n            update(tableau, row, c, value / quotient);\n            nonZeroColumns.push(c);\n        }\n        else {\n            update(tableau, row, c, 0.0);\n        }\n    }\n    update(tableau, row, col, 1.0 / quotient);\n    // -M[r, col] * R_pivot + R_r -> R_r\n    for (let r = 0; r < tableau.height; r++) {\n        if (r === row)\n            continue;\n        const coef = index(tableau, r, col);\n        if (Math.abs(coef) > 1e-16) {\n            for (let i = 0; i < nonZeroColumns.length; i++) {\n                const c = nonZeroColumns[i];\n                update(tableau, r, c, index(tableau, r, c) - coef * index(tableau, row, c));\n            }\n            update(tableau, r, col, -coef / quotient);\n        }\n    }\n};\n// Checks if the simplex method has encountered a cycle.\nconst hasCycle = (history, tableau, row, col) => {\n    // This whole function seems somewhat inefficient,\n    // but there was no? noticable impact in the benchmarks.\n    history.push([tableau.variableAtPosition[tableau.width + row], tableau.variableAtPosition[col]]);\n    // the minimum length of a cycle is 6\n    for (let length = 6; length <= Math.trunc(history.length / 2); length++) {\n        let cycle = true;\n        for (let i = 0; i < length; i++) {\n            const item = history.length - 1 - i;\n            const [row1, col1] = history[item];\n            const [row2, col2] = history[item - length];\n            if (row1 !== row2 || col1 !== col2) {\n                cycle = false;\n                break;\n            }\n        }\n        if (cycle)\n            return true;\n    }\n    return false;\n};\n// Finds the optimal solution given some basic feasible solution.\nconst phase2 = (tableau, options) => {\n    const pivotHistory = [];\n    const { precision, maxPivots, checkCycles } = options;\n    for (let iter = 0; iter < maxPivots; iter++) {\n        // Find the entering column/variable\n        let col = 0;\n        let value = precision;\n        for (let c = 1; c < tableau.width; c++) {\n            const reducedCost = index(tableau, 0, c);\n            if (reducedCost > value) {\n                value = reducedCost;\n                col = c;\n            }\n        }\n        if (col === 0)\n            return [\"optimal\", roundToPrecision(index(tableau, 0, 0), precision)];\n        // Find the leaving row/variable\n        let row = 0;\n        let minRatio = Infinity;\n        for (let r = 1; r < tableau.height; r++) {\n            const value = index(tableau, r, col);\n            if (value <= precision)\n                continue; // pivot entry must be positive\n            const rhs = index(tableau, r, 0);\n            const ratio = rhs / value;\n            if (ratio < minRatio) {\n                row = r;\n                minRatio = ratio;\n                if (ratio <= precision)\n                    break; // ratio is 0, lowest possible\n            }\n        }\n        if (row === 0)\n            return [\"unbounded\", col];\n        if (checkCycles && hasCycle(pivotHistory, tableau, row, col))\n            return [\"cycled\", NaN];\n        pivot(tableau, row, col);\n    }\n    return [\"cycled\", NaN];\n};\n// Transforms a tableau into a basic feasible solution.\nconst phase1 = (tableau, options) => {\n    const pivotHistory = [];\n    const { precision, maxPivots, checkCycles } = options;\n    for (let iter = 0; iter < maxPivots; iter++) {\n        // Find the leaving row/variable\n        let row = 0;\n        let rhs = -precision;\n        for (let r = 1; r < tableau.height; r++) {\n            const value = index(tableau, r, 0);\n            if (value < rhs) {\n                rhs = value;\n                row = r;\n            }\n        }\n        if (row === 0)\n            return phase2(tableau, options);\n        // Find the entering column/variable\n        let col = 0;\n        let maxRatio = -Infinity;\n        for (let c = 1; c < tableau.width; c++) {\n            const coefficient = index(tableau, row, c);\n            if (coefficient < -precision) {\n                const ratio = -index(tableau, 0, c) / coefficient;\n                if (ratio > maxRatio) {\n                    maxRatio = ratio;\n                    col = c;\n                }\n            }\n        }\n        if (col === 0)\n            return [\"infeasible\", NaN];\n        if (checkCycles && hasCycle(pivotHistory, tableau, row, col))\n            return [\"cycled\", NaN];\n        pivot(tableau, row, col);\n    }\n    return [\"cycled\", NaN];\n};\nexport { phase1 as simplex };\n","module.exports = require('./lib/heap');\n","import { index } from \"./tableau.js\";\nimport { simplex } from \"./simplex.js\";\nimport Heap from \"heap\";\nconst buffer = (matrixLength, posVarLength) => ({\n    matrix: new Float64Array(matrixLength),\n    positionOfVariable: new Int32Array(posVarLength),\n    variableAtPosition: new Int32Array(posVarLength)\n});\n// Creates a new tableau with additional cut constraints from a buffer.\nconst applyCuts = (tableau, { matrix, positionOfVariable, variableAtPosition }, cuts) => {\n    const { width, height } = tableau;\n    matrix.set(tableau.matrix);\n    for (let i = 0; i < cuts.length; i++) {\n        const [sign, variable, value] = cuts[i];\n        const r = (height + i) * width;\n        const pos = tableau.positionOfVariable[variable];\n        if (pos < width) {\n            matrix[r] = sign * value;\n            matrix.fill(0.0, r + 1, r + width);\n            matrix[r + pos] = sign;\n        }\n        else {\n            const row = (pos - width) * width;\n            matrix[r] = sign * (value - matrix[row]);\n            for (let c = 1; c < width; c++) {\n                matrix[r + c] = -sign * matrix[row + c];\n            }\n        }\n    }\n    positionOfVariable.set(tableau.positionOfVariable);\n    variableAtPosition.set(tableau.variableAtPosition);\n    const length = width + height + cuts.length;\n    for (let i = width + height; i < length; i++) {\n        positionOfVariable[i] = i;\n        variableAtPosition[i] = i;\n    }\n    return {\n        matrix: matrix.subarray(0, tableau.matrix.length + width * cuts.length),\n        width,\n        height: height + cuts.length,\n        positionOfVariable: positionOfVariable.subarray(0, length),\n        variableAtPosition: variableAtPosition.subarray(0, length)\n    };\n};\n// Finds the integer variable with the most fractional value.\nconst mostFractionalVar = (tableau, intVars) => {\n    let highestFrac = 0.0;\n    let variable = 0;\n    let value = 0.0;\n    for (let i = 0; i < intVars.length; i++) {\n        const intVar = intVars[i];\n        const row = tableau.positionOfVariable[intVar] - tableau.width;\n        if (row < 0)\n            continue;\n        const val = index(tableau, row, 0);\n        const frac = Math.abs(val - Math.round(val));\n        if (frac > highestFrac) {\n            highestFrac = frac;\n            variable = intVar;\n            value = val;\n        }\n    }\n    return [variable, value, highestFrac];\n};\n// Runs the branch and cut algorithm to solve an integer problem.\n// Requires the non-integer solution as input.\nexport const branchAndCut = (tabmod, initResult, options) => {\n    const { tableau, sign, integers } = tabmod;\n    const { precision, maxIterations, tolerance, timeout } = options;\n    const [initVariable, initValue, initFrac] = mostFractionalVar(tableau, integers);\n    // Wow, the initial solution is integer\n    if (initFrac <= precision)\n        return [tabmod, \"optimal\", initResult];\n    const branches = new Heap((x, y) => x[0] - y[0]);\n    branches.push([initResult, [[-1, initVariable, Math.ceil(initValue)]]]);\n    branches.push([initResult, [[1, initVariable, Math.floor(initValue)]]]);\n    // Set aside arrays/buffers to be reused over the course of the algorithm.\n    // One set of buffers stores the state of the currrent best solution.\n    // The other is used to solve the current candidate solution.\n    // The two buffers are \"swapped\" once a new best solution is found.\n    const maxExtraRows = integers.length * 2;\n    const matrixLength = tableau.matrix.length + maxExtraRows * tableau.width;\n    const posVarLength = tableau.positionOfVariable.length + maxExtraRows;\n    let candidateBuffer = buffer(matrixLength, posVarLength);\n    let solutionBuffer = buffer(matrixLength, posVarLength);\n    const optimalThreshold = initResult * (1.0 - sign * tolerance);\n    const stopTime = timeout + Date.now();\n    let timedout = Date.now() >= stopTime; // in case options.timeout <= 0\n    let solutionFound = false;\n    let bestEval = Infinity;\n    let bestTableau = tableau;\n    let iter = 0;\n    while (iter < maxIterations && !branches.empty() && bestEval >= optimalThreshold && !timedout) {\n        const [relaxedEval, cuts] = branches.pop();\n        if (relaxedEval > bestEval)\n            break; // the remaining branches are worse than the current best solution\n        const currentTableau = applyCuts(tableau, candidateBuffer, cuts);\n        const [status, result] = simplex(currentTableau, options);\n        // The initial tableau is not unbounded and adding more cuts/constraints cannot make it become unbounded\n        // assert(status !== \"unbounded\")\n        if (status === \"optimal\" && result < bestEval) {\n            const [variable, value, frac] = mostFractionalVar(currentTableau, integers);\n            if (frac <= precision) {\n                // The solution is integer\n                solutionFound = true;\n                bestEval = result;\n                bestTableau = currentTableau;\n                const temp = solutionBuffer;\n                solutionBuffer = candidateBuffer;\n                candidateBuffer = temp;\n            }\n            else {\n                const cutsUpper = [];\n                const cutsLower = [];\n                for (let i = 0; i < cuts.length; i++) {\n                    const cut = cuts[i];\n                    const [dir, v] = cut;\n                    if (v === variable) {\n                        dir < 0 ? cutsLower.push(cut) : cutsUpper.push(cut);\n                    }\n                    else {\n                        cutsUpper.push(cut);\n                        cutsLower.push(cut);\n                    }\n                }\n                cutsLower.push([1, variable, Math.floor(value)]);\n                cutsUpper.push([-1, variable, Math.ceil(value)]);\n                branches.push([result, cutsUpper]);\n                branches.push([result, cutsLower]);\n            }\n        }\n        // Otherwise, this branch's result is worse than the current best solution.\n        // This could be because this branch is infeasible or cycled.\n        // Either way, skip this branch and see if any other branches have a valid, better solution.\n        timedout = Date.now() >= stopTime;\n        iter++;\n    }\n    // Did the solver \"timeout\"?\n    const unfinished = (timedout || iter >= maxIterations) && !branches.empty() && bestEval >= optimalThreshold;\n    // prettier-ignore\n    const status = unfinished ? \"timedout\"\n        : !solutionFound ? \"infeasible\"\n            : \"optimal\";\n    return [{ ...tabmod, tableau: bestTableau }, status, solutionFound ? bestEval : NaN];\n};\n","import { index, tableauModel } from \"./tableau.js\";\nimport { roundToPrecision } from \"./util.js\";\nimport { simplex } from \"./simplex.js\";\nimport { branchAndCut } from \"./branchAndCut.js\";\n// Creates a solution object representing the optimal solution (if any).\nconst solution = ({ tableau, sign, variables: vars }, status, result, { precision, includeZeroVariables }) => {\n    if (status === \"optimal\" || (status === \"timedout\" && !Number.isNaN(result))) {\n        const variables = [];\n        for (let i = 0; i < vars.length; i++) {\n            const [variable] = vars[i];\n            const row = tableau.positionOfVariable[i + 1] - tableau.width;\n            const value = row >= 0 ? index(tableau, row, 0) : 0.0;\n            if (value > precision) {\n                variables.push([variable, roundToPrecision(value, precision)]);\n            }\n            else if (includeZeroVariables) {\n                variables.push([variable, 0.0]);\n            }\n        }\n        return {\n            status,\n            result: -sign * result,\n            variables\n        };\n    }\n    else if (status === \"unbounded\") {\n        const variable = tableau.variableAtPosition[result] - 1;\n        return {\n            status: \"unbounded\",\n            result: sign * Infinity,\n            // prettier-ignore\n            variables: (0 <= variable && variable < vars.length)\n                ? [[vars[variable][0], Infinity]]\n                : []\n        };\n    }\n    else {\n        // infeasible | cycled | (timedout and result is NaN)\n        return {\n            status,\n            result: NaN,\n            variables: []\n        };\n    }\n};\nconst defaultOptionValues = {\n    precision: 1e-8,\n    checkCycles: false,\n    maxPivots: 8192,\n    tolerance: 0,\n    timeout: Infinity,\n    maxIterations: 32768,\n    includeZeroVariables: false\n};\n/**\n * The default options used by the solver.\n */\nexport const defaultOptions = { ...defaultOptionValues };\n/**\n * Runs the solver on the given model and using the given options (if any).\n * @see `Model` on how to specify/create the model.\n * @see `Options` for the kinds of options available.\n * @see `Solution` for more detailed information on what is returned.\n */\nexport const solve = (model, options) => {\n    const tabmod = tableauModel(model);\n    const opt = { ...defaultOptionValues, ...options };\n    const [status, result] = simplex(tabmod.tableau, opt);\n    if (tabmod.integers.length === 0 || status !== \"optimal\") {\n        // If a non-integer problem, return the simplex result.\n        // Otherwise, the problem has integer variables, but the initial solution is either:\n        // 1) unbounded | infeasible => all branches will also be unbounded | infeasible\n        // 2) cycled => cannot get an initial solution, return invalid solution\n        return solution(tabmod, status, result, opt);\n    }\n    else {\n        // Integer problem and an optimal non-integer solution was found\n        const [intTabmod, intStatus, intResult] = branchAndCut(tabmod, result, opt);\n        return solution(intTabmod, intStatus, intResult, opt);\n    }\n};\n","module internal StardewValleyStonks.WebApp.Worker\n\nopen Fable.Core\nopen YALPS\n\ntype Input = Model<int, string> array\ntype Output = int Solution array\n\nlet [<Global>] private postMessage: Output -> unit = jsNative\n\nlet [<Global>] mutable private onmessage: Browser.Types.MessageEvent -> unit = jsNative\n\nonmessage <- fun message ->\n  match message.data with\n  | :? Input as data -> postMessage (data |> Array.map Solver.solve)\n  | _ -> assert false\n"],"names":["Heap","defaultCmp","floor","heapify","heappop","heappush","heappushpop","heapreplace","insort","min","nlargest","nsmallest","updateItem","_siftdown","_siftup","factory","Math","x","y","a","lo","hi","cmp","mid","Error","length","splice","apply","concat","array","item","push","lastelt","returnitem","pop","_ref","i","_i","_len","_ref1","_results","_results1","_j","this","reverse","pos","indexOf","n","elem","result","slice","sort","los","startpos","newitem","parent","parentpos","childpos","endpos","rightpos","nodes","replace","pushpop","prototype","peek","contains","clear","empty","size","clone","heap","toArray","insert","top","front","has","copy","define","amd","module","exports","call","$ca83e11e3862bb5c$export$1e2f57719e155213","Array","isArray","ArrayBuffer","isView","$ca83e11e3862bb5c$export$37843fd8de917eb4","constructor","en","GetEnumerator","Symbol","iterator","next","hasNext","done","value","undefined","$ca83e11e3862bb5c$export$f3f95c9f1920e9b5","static","o","idMap","set","count","get","WeakMap","$8b41158f8f196dc9$export$882a7a2eca8e1502","cons","len","$ba002d66bd13c98f$export$871de8747c9eaa88","f","source","target","$766310993b931f49$export$b610b8812bbcded9","tableau","row","col","matrix","imul","width","$766310993b931f49$export$722fbec263ad908a","$766310993b931f49$var$convertToIterable","seq","Object","entries","$766310993b931f49$var$convertToSet","Set","$766310993b931f49$export$5775ac136be60802","model","direction","objective","integers","binaries","sign","constraintsIter","constraints","variablesIter","variables","from","binaryConstraintCol","ints","binaryVariables","integerVariables","key","Map","constraint","bounds","NaN","lower","Infinity","upper","max","equal","numConstraints","values","Number","isFinite","height","numVars","Float64Array","positionOfVariable","Int32Array","variableAtPosition","c","coef","b","$1b2ad3cb69a79105$export$b485511e5cd71305","num","precision","rounding","round","EPSILON","$8135c8e95bc184a9$var$pivot","quotient","leaving","entering","nonZeroColumns","abs","r","$8135c8e95bc184a9$var$hasCycle","history","trunc","cycle","row1","col1","row2","col2","$8135c8e95bc184a9$var$phase2","options","pivotHistory","maxPivots","checkCycles","iter","reducedCost","minRatio","ratio","$8135c8e95bc184a9$export$cdff0fdd5b0f2742","rhs","maxRatio","coefficient","$a480cfd0af27e963$exports","parcelRequire","$9ffe9ea54178e5e7$var$buffer","matrixLength","posVarLength","$9ffe9ea54178e5e7$var$applyCuts","cuts","variable","fill","subarray","$9ffe9ea54178e5e7$var$mostFractionalVar","intVars","highestFrac","intVar","val","frac","$9ffe9ea54178e5e7$export$ecbfccb5730dd058","tabmod","initResult","maxIterations","tolerance","timeout","initVariable","initValue","initFrac","branches","$parcel$interopDefault","ceil","maxExtraRows","candidateBuffer","solutionBuffer","optimalThreshold","stopTime","Date","now","timedout","solutionFound","bestEval","bestTableau","relaxedEval","currentTableau","status","temp","cutsUpper","cutsLower","cut","dir","v","$a886f1a34b7cd82c$var$solution","vars","includeZeroVariables","isNaN","$a886f1a34b7cd82c$var$defaultOptionValues","$a886f1a34b7cd82c$export$2865df1f26e73f8e","opt","intTabmod","intStatus","intResult","onmessage","message","matchValue","data","postMessage"],"version":3,"file":"Worker.47a1de8f.js.map"}
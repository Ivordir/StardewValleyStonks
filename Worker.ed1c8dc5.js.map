{"mappings":"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","sources":["<anon>","node_modules/.pnpm/heap@0.2.7/node_modules/heap/lib/heap.js","fable/Worker.js","src/WebApp/Worker.fs","fable/fable_modules/Fable.YALPS.0.5.0/Fable.YALPS.fs","fable/fable_modules/fable-library.4.5.0/Util.js","fable/fable_modules/fable-library.4.5.0/Array.js","fable/fable_modules/fable-library.4.5.0/Native.js","fable/fable_modules/fable-library.4.5.0/Option.js","fable/fable_modules/fable-library.4.5.0/Double.js","fable/fable_modules/fable-library.4.5.0/Types.js","fable/fable_modules/fable-library.4.5.0/Global.js","node_modules/.pnpm/yalps@0.5.5/node_modules/yalps/lib/module/YALPS.js","node_modules/.pnpm/yalps@0.5.5/node_modules/yalps/lib/module/tableau.js","node_modules/.pnpm/yalps@0.5.5/node_modules/yalps/lib/module/util.js","node_modules/.pnpm/yalps@0.5.5/node_modules/yalps/lib/module/simplex.js","node_modules/.pnpm/yalps@0.5.5/node_modules/yalps/lib/module/branchAndCut.js","node_modules/.pnpm/heap@0.2.7/node_modules/heap/index.js"],"sourcesContent":["(() => {\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"l9uIb\", function(module, exports) {\n// Generated by CoffeeScript 1.8.0\n(function() {\n    var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n    floor = Math.floor, min = Math.min;\n    /*\n  Default comparison function to be used\n   */ defaultCmp = function(x, y) {\n        if (x < y) return -1;\n        if (x > y) return 1;\n        return 0;\n    };\n    /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */ insort = function(a, x, lo, hi, cmp) {\n        var mid;\n        if (lo == null) lo = 0;\n        if (cmp == null) cmp = defaultCmp;\n        if (lo < 0) throw new Error(\"lo must be non-negative\");\n        if (hi == null) hi = a.length;\n        while(lo < hi){\n            mid = floor((lo + hi) / 2);\n            if (cmp(x, a[mid]) < 0) hi = mid;\n            else lo = mid + 1;\n        }\n        return [].splice.apply(a, [\n            lo,\n            lo - lo\n        ].concat(x)), x;\n    };\n    /*\n  Push item onto heap, maintaining the heap invariant.\n   */ heappush = function(array, item, cmp) {\n        if (cmp == null) cmp = defaultCmp;\n        array.push(item);\n        return _siftdown(array, 0, array.length - 1, cmp);\n    };\n    /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */ heappop = function(array, cmp) {\n        var lastelt, returnitem;\n        if (cmp == null) cmp = defaultCmp;\n        lastelt = array.pop();\n        if (array.length) {\n            returnitem = array[0];\n            array[0] = lastelt;\n            _siftup(array, 0, cmp);\n        } else returnitem = lastelt;\n        return returnitem;\n    };\n    /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */ heapreplace = function(array, item, cmp) {\n        var returnitem;\n        if (cmp == null) cmp = defaultCmp;\n        returnitem = array[0];\n        array[0] = item;\n        _siftup(array, 0, cmp);\n        return returnitem;\n    };\n    /*\n  Fast version of a heappush followed by a heappop.\n   */ heappushpop = function(array, item, cmp) {\n        var _ref;\n        if (cmp == null) cmp = defaultCmp;\n        if (array.length && cmp(array[0], item) < 0) {\n            _ref = [\n                array[0],\n                item\n            ], item = _ref[0], array[0] = _ref[1];\n            _siftup(array, 0, cmp);\n        }\n        return item;\n    };\n    /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */ heapify = function(array, cmp) {\n        var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n        if (cmp == null) cmp = defaultCmp;\n        _ref1 = (function() {\n            _results1 = [];\n            for(var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--)_results1.push(_j);\n            return _results1;\n        }).apply(this).reverse();\n        _results = [];\n        for(_i = 0, _len = _ref1.length; _i < _len; _i++){\n            i = _ref1[_i];\n            _results.push(_siftup(array, i, cmp));\n        }\n        return _results;\n    };\n    /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */ updateItem = function(array, item, cmp) {\n        var pos;\n        if (cmp == null) cmp = defaultCmp;\n        pos = array.indexOf(item);\n        if (pos === -1) return;\n        _siftdown(array, 0, pos, cmp);\n        return _siftup(array, pos, cmp);\n    };\n    /*\n  Find the n largest elements in a dataset.\n   */ nlargest = function(array, n, cmp) {\n        var elem, result, _i, _len, _ref;\n        if (cmp == null) cmp = defaultCmp;\n        result = array.slice(0, n);\n        if (!result.length) return result;\n        heapify(result, cmp);\n        _ref = array.slice(n);\n        for(_i = 0, _len = _ref.length; _i < _len; _i++){\n            elem = _ref[_i];\n            heappushpop(result, elem, cmp);\n        }\n        return result.sort(cmp).reverse();\n    };\n    /*\n  Find the n smallest elements in a dataset.\n   */ nsmallest = function(array, n, cmp) {\n        var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n        if (cmp == null) cmp = defaultCmp;\n        if (n * 10 <= array.length) {\n            result = array.slice(0, n).sort(cmp);\n            if (!result.length) return result;\n            los = result[result.length - 1];\n            _ref = array.slice(n);\n            for(_i = 0, _len = _ref.length; _i < _len; _i++){\n                elem = _ref[_i];\n                if (cmp(elem, los) < 0) {\n                    insort(result, elem, 0, null, cmp);\n                    result.pop();\n                    los = result[result.length - 1];\n                }\n            }\n            return result;\n        }\n        heapify(array, cmp);\n        _results = [];\n        for(i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j)_results.push(heappop(array, cmp));\n        return _results;\n    };\n    _siftdown = function(array, startpos, pos, cmp) {\n        var newitem, parent, parentpos;\n        if (cmp == null) cmp = defaultCmp;\n        newitem = array[pos];\n        while(pos > startpos){\n            parentpos = pos - 1 >> 1;\n            parent = array[parentpos];\n            if (cmp(newitem, parent) < 0) {\n                array[pos] = parent;\n                pos = parentpos;\n                continue;\n            }\n            break;\n        }\n        return array[pos] = newitem;\n    };\n    _siftup = function(array, pos, cmp) {\n        var childpos, endpos, newitem, rightpos, startpos;\n        if (cmp == null) cmp = defaultCmp;\n        endpos = array.length;\n        startpos = pos;\n        newitem = array[pos];\n        childpos = 2 * pos + 1;\n        while(childpos < endpos){\n            rightpos = childpos + 1;\n            if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) childpos = rightpos;\n            array[pos] = array[childpos];\n            pos = childpos;\n            childpos = 2 * pos + 1;\n        }\n        array[pos] = newitem;\n        return _siftdown(array, startpos, pos, cmp);\n    };\n    Heap = function() {\n        Heap.push = heappush;\n        Heap.pop = heappop;\n        Heap.replace = heapreplace;\n        Heap.pushpop = heappushpop;\n        Heap.heapify = heapify;\n        Heap.updateItem = updateItem;\n        Heap.nlargest = nlargest;\n        Heap.nsmallest = nsmallest;\n        function Heap(cmp) {\n            this.cmp = cmp != null ? cmp : defaultCmp;\n            this.nodes = [];\n        }\n        Heap.prototype.push = function(x) {\n            return heappush(this.nodes, x, this.cmp);\n        };\n        Heap.prototype.pop = function() {\n            return heappop(this.nodes, this.cmp);\n        };\n        Heap.prototype.peek = function() {\n            return this.nodes[0];\n        };\n        Heap.prototype.contains = function(x) {\n            return this.nodes.indexOf(x) !== -1;\n        };\n        Heap.prototype.replace = function(x) {\n            return heapreplace(this.nodes, x, this.cmp);\n        };\n        Heap.prototype.pushpop = function(x) {\n            return heappushpop(this.nodes, x, this.cmp);\n        };\n        Heap.prototype.heapify = function() {\n            return heapify(this.nodes, this.cmp);\n        };\n        Heap.prototype.updateItem = function(x) {\n            return updateItem(this.nodes, x, this.cmp);\n        };\n        Heap.prototype.clear = function() {\n            return this.nodes = [];\n        };\n        Heap.prototype.empty = function() {\n            return this.nodes.length === 0;\n        };\n        Heap.prototype.size = function() {\n            return this.nodes.length;\n        };\n        Heap.prototype.clone = function() {\n            var heap;\n            heap = new Heap();\n            heap.nodes = this.nodes.slice(0);\n            return heap;\n        };\n        Heap.prototype.toArray = function() {\n            return this.nodes.slice(0);\n        };\n        Heap.prototype.insert = Heap.prototype.push;\n        Heap.prototype.top = Heap.prototype.peek;\n        Heap.prototype.front = Heap.prototype.peek;\n        Heap.prototype.has = Heap.prototype.contains;\n        Heap.prototype.copy = Heap.prototype.clone;\n        return Heap;\n    }();\n    (function(root, factory) {\n        if (typeof define === \"function\" && define.amd) return define([], factory);\n        else return module.exports = factory();\n    })(this, function() {\n        return Heap;\n    });\n}).call(module.exports);\n\n});\n\nvar $a964b07fa95d5b27$exports = {};\n// tslint:disable:ban-types\nfunction $0ba2f68448f8716d$export$1e2f57719e155213(x) {\n    return Array.isArray(x) || ArrayBuffer.isView(x);\n}\nfunction $0ba2f68448f8716d$export$9652023d9040757(x) {\n    return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nfunction $0ba2f68448f8716d$export$8edadf8e974b29dc(x) {\n    return x != null && typeof x.GetEnumerator === \"function\";\n}\nfunction $0ba2f68448f8716d$export$c3a1405a13c192dc(x) {\n    return x != null && typeof x.Compare === \"function\";\n}\nfunction $0ba2f68448f8716d$export$a8eb308fbdcb0e9c(x) {\n    return x != null && typeof x.CompareTo === \"function\";\n}\nfunction $0ba2f68448f8716d$export$a2520bc9aec4b126(x) {\n    return x != null && typeof x.Equals === \"function\";\n}\nfunction $0ba2f68448f8716d$export$f0284d1eb84ae373(x) {\n    return x != null && typeof x.GetHashCode === \"function\";\n}\nfunction $0ba2f68448f8716d$export$e29d65b7eabdc6dd(x) {\n    return x != null && typeof x.Dispose === \"function\";\n}\nfunction $0ba2f68448f8716d$export$466534c54e60af80(x) {\n    if ($0ba2f68448f8716d$export$e29d65b7eabdc6dd(x)) x.Dispose();\n}\nfunction $0ba2f68448f8716d$export$439614834d2d5072() {\n    return null;\n}\nfunction $0ba2f68448f8716d$export$52febab2880147bb(x, y) {\n    return Object.getPrototypeOf(x)?.constructor === Object.getPrototypeOf(y)?.constructor;\n}\nclass $0ba2f68448f8716d$export$37843fd8de917eb4 {\n    constructor(en){\n        this.en = en;\n    }\n    GetEnumerator() {\n        return this.en;\n    }\n    \"System.Collections.IEnumerable.GetEnumerator\"() {\n        return this.en;\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n    next() {\n        const hasNext = this.en[\"System.Collections.IEnumerator.MoveNext\"]();\n        const current = hasNext ? this.en[\"System.Collections.Generic.IEnumerator`1.get_Current\"]() : undefined;\n        return {\n            done: !hasNext,\n            value: current\n        };\n    }\n}\nclass $0ba2f68448f8716d$export$95c529ba89ee4ce7 {\n    constructor(iter){\n        this.iter = iter;\n        this.current = $0ba2f68448f8716d$export$439614834d2d5072();\n    }\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    [\"System.Collections.IEnumerator.Reset\"]() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() {\n        return;\n    }\n}\nfunction $0ba2f68448f8716d$export$9fb89e7387d05511(e) {\n    if ($0ba2f68448f8716d$export$8edadf8e974b29dc(e)) return e;\n    else return new $0ba2f68448f8716d$export$37843fd8de917eb4(new $0ba2f68448f8716d$export$95c529ba89ee4ce7(e[Symbol.iterator]()));\n}\nfunction $0ba2f68448f8716d$export$a41738691dcd8bea(e) {\n    if ($0ba2f68448f8716d$export$8edadf8e974b29dc(e)) return e.GetEnumerator();\n    else return new $0ba2f68448f8716d$export$95c529ba89ee4ce7(e[Symbol.iterator]());\n}\nfunction $0ba2f68448f8716d$export$21e0669b7bd01bb4(en) {\n    return {\n        next () {\n            const hasNext = en[\"System.Collections.IEnumerator.MoveNext\"]();\n            const current = hasNext ? en[\"System.Collections.Generic.IEnumerator`1.get_Current\"]() : undefined;\n            return {\n                done: !hasNext,\n                value: current\n            };\n        }\n    };\n}\nfunction $0ba2f68448f8716d$export$3610da1c5de62df(e) {\n    return $0ba2f68448f8716d$export$21e0669b7bd01bb4($0ba2f68448f8716d$export$9fb89e7387d05511(e).GetEnumerator());\n}\nclass $0ba2f68448f8716d$export$6f7eded1b7c5be2f {\n    constructor(f){\n        this.Compare = f || $0ba2f68448f8716d$export$398604a469f7de9a;\n    }\n}\nfunction $0ba2f68448f8716d$export$40090773fd11c74c(comparer) {\n    // Sometimes IEqualityComparer also implements IComparer\n    if ($0ba2f68448f8716d$export$c3a1405a13c192dc(comparer)) return new $0ba2f68448f8716d$export$6f7eded1b7c5be2f(comparer.Compare);\n    else return new $0ba2f68448f8716d$export$6f7eded1b7c5be2f((x, y)=>{\n        const xhash = comparer.GetHashCode(x);\n        const yhash = comparer.GetHashCode(y);\n        if (xhash === yhash) return comparer.Equals(x, y) ? 0 : -1;\n        else return xhash < yhash ? -1 : 1;\n    });\n}\nfunction $0ba2f68448f8716d$export$27555cdfb0b84a1a(actual, expected, msg) {\n    if (!$0ba2f68448f8716d$export$e9bab7fafb253603(actual, expected)) throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n        actual: actual,\n        expected: expected\n    });\n}\nfunction $0ba2f68448f8716d$export$49eedac51f614f7d(actual, expected, msg) {\n    if ($0ba2f68448f8716d$export$e9bab7fafb253603(actual, expected)) throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n        actual: actual,\n        expected: expected\n    });\n}\nclass $0ba2f68448f8716d$export$b624eff549462981 {\n    constructor(factory){\n        this.factory = factory;\n        this.isValueCreated = false;\n    }\n    get Value() {\n        if (!this.isValueCreated) {\n            this.createdValue = this.factory();\n            this.isValueCreated = true;\n        }\n        return this.createdValue;\n    }\n    get IsValueCreated() {\n        return this.isValueCreated;\n    }\n}\nfunction $0ba2f68448f8716d$export$c5f9bac959aafb6(v) {\n    return new $0ba2f68448f8716d$export$b624eff549462981(()=>v);\n}\nfunction $0ba2f68448f8716d$export$eeb1958fe3944641(i, length) {\n    let str = i.toString(10);\n    while(str.length < length)str = \"0\" + str;\n    return str;\n}\nfunction $0ba2f68448f8716d$export$9251776e912f9733(i, lengthLeft, lengthRight) {\n    let str = i.toString(10);\n    while(str.length < lengthLeft)str = \"0\" + str;\n    while(str.length < lengthRight)str = str + \"0\";\n    return str;\n}\nfunction $0ba2f68448f8716d$export$b4360650442640a0(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\" ? date1.offset : date.kind === 1 /* DateKind.UTC */  ? 0 : date.getTimezoneOffset() * -60000;\n}\nfunction $0ba2f68448f8716d$export$a3afeaad75c2403e(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nfunction $0ba2f68448f8716d$export$afbd86327cbebb03(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nfunction $0ba2f68448f8716d$export$4012a95a346cab46(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xffffffffffffffffn + i + 1n : i;\n    return i.toString(radix);\n}\nclass $0ba2f68448f8716d$export$f3f95c9f1920e9b5 {\n    static id(o) {\n        if (!$0ba2f68448f8716d$export$f3f95c9f1920e9b5.idMap.has(o)) $0ba2f68448f8716d$export$f3f95c9f1920e9b5.idMap.set(o, ++$0ba2f68448f8716d$export$f3f95c9f1920e9b5.count);\n        return $0ba2f68448f8716d$export$f3f95c9f1920e9b5.idMap.get(o);\n    }\n}\n$0ba2f68448f8716d$export$f3f95c9f1920e9b5.idMap = new WeakMap();\n$0ba2f68448f8716d$export$f3f95c9f1920e9b5.count = 0;\nfunction $0ba2f68448f8716d$export$b9b095ec8c02760b(s) {\n    let i = 0;\n    let h = 5381;\n    const len = s.length;\n    while(i < len)h = h * 33 ^ s.charCodeAt(i++);\n    return h;\n}\nfunction $0ba2f68448f8716d$export$a9844eb73de0a218(x) {\n    return x * 2654435761 | 0;\n}\nfunction $0ba2f68448f8716d$export$ef8370382c2c5327(x) {\n    return $0ba2f68448f8716d$export$b9b095ec8c02760b(x.toString(32));\n}\nfunction $0ba2f68448f8716d$export$4a6567c520a28ea3(hashes) {\n    let h1 = 0;\n    const len = hashes.length;\n    for(let i = 0; i < len; i++){\n        const h2 = hashes[i];\n        h1 = (h1 << 5) + h1 ^ h2;\n    }\n    return h1;\n}\nfunction $0ba2f68448f8716d$export$9657185e7652fc5b(x) {\n    if (x == null) return 0;\n    switch(typeof x){\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return $0ba2f68448f8716d$export$a9844eb73de0a218(x);\n        case \"bigint\":\n            return $0ba2f68448f8716d$export$ef8370382c2c5327(x);\n        case \"string\":\n            return $0ba2f68448f8716d$export$b9b095ec8c02760b(x);\n        default:\n            return $0ba2f68448f8716d$export$a9844eb73de0a218($0ba2f68448f8716d$export$f3f95c9f1920e9b5.id(x));\n    }\n}\nfunction $0ba2f68448f8716d$export$66b47a187ef76f1c(x) {\n    if ($0ba2f68448f8716d$export$f0284d1eb84ae373(x)) return x.GetHashCode();\n    else return $0ba2f68448f8716d$export$9657185e7652fc5b(x);\n}\nfunction $0ba2f68448f8716d$export$2e003ac3dfcb70a3(x) {\n    return x.getTime();\n}\nfunction $0ba2f68448f8716d$export$34638350c54b9a1b(x) {\n    const len = x.length;\n    const hashes = new Array(len);\n    for(let i = 0; i < len; i++)hashes[i] = $0ba2f68448f8716d$export$2e619f11ca48bee4(x[i]);\n    return $0ba2f68448f8716d$export$4a6567c520a28ea3(hashes);\n}\nfunction $0ba2f68448f8716d$export$2e619f11ca48bee4(x) {\n    if (x == null) return 0;\n    switch(typeof x){\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return $0ba2f68448f8716d$export$a9844eb73de0a218(x);\n        case \"bigint\":\n            return $0ba2f68448f8716d$export$ef8370382c2c5327(x);\n        case \"string\":\n            return $0ba2f68448f8716d$export$b9b095ec8c02760b(x);\n        default:\n            if ($0ba2f68448f8716d$export$f0284d1eb84ae373(x)) return x.GetHashCode();\n            else if ($0ba2f68448f8716d$export$1e2f57719e155213(x)) return $0ba2f68448f8716d$export$34638350c54b9a1b(x);\n            else if (x instanceof Date) return $0ba2f68448f8716d$export$2e003ac3dfcb70a3(x);\n            else if (Object.getPrototypeOf(x)?.constructor === Object) {\n                // TODO: check call-stack to prevent cyclic objects?\n                const hashes = Object.values(x).map((v)=>$0ba2f68448f8716d$export$2e619f11ca48bee4(v));\n                return $0ba2f68448f8716d$export$4a6567c520a28ea3(hashes);\n            } else // Classes don't implement GetHashCode by default, but must use identity hashing\n            return $0ba2f68448f8716d$export$a9844eb73de0a218($0ba2f68448f8716d$export$f3f95c9f1920e9b5.id(x));\n    }\n}\nfunction $0ba2f68448f8716d$export$2ba04dca110a1015(x) {\n    return $0ba2f68448f8716d$export$b9b095ec8c02760b(String(x));\n}\nfunction $0ba2f68448f8716d$export$fed18027a0c1a84b(x) {\n    // return x == null ? 0 : isHashable(x) ? x.GetHashCode() : numberHash(ObjectRef.id(x));\n    return $0ba2f68448f8716d$export$66b47a187ef76f1c(x);\n}\nfunction $0ba2f68448f8716d$export$b9a64d2e4daf3c9f(x, y, eq) {\n    if (x == null) return y == null;\n    if (y == null) return false;\n    if (x.length !== y.length) return false;\n    for(let i = 0; i < x.length; i++){\n        if (!eq(x[i], y[i])) return false;\n    }\n    return true;\n}\nfunction $0ba2f68448f8716d$export$dc63f52ecf814bf8(x, y) {\n    return $0ba2f68448f8716d$export$b9a64d2e4daf3c9f(x, y, $0ba2f68448f8716d$export$e9bab7fafb253603);\n}\nfunction $0ba2f68448f8716d$var$equalObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) return false;\n    xKeys.sort();\n    yKeys.sort();\n    for(let i = 0; i < xKeys.length; i++){\n        if (xKeys[i] !== yKeys[i] || !$0ba2f68448f8716d$export$e9bab7fafb253603(x[xKeys[i]], y[yKeys[i]])) return false;\n    }\n    return true;\n}\nfunction $0ba2f68448f8716d$export$97c886f9eb1c7d16(x, y) {\n    return x === y;\n}\nfunction $0ba2f68448f8716d$export$e9bab7fafb253603(x, y) {\n    if (x === y) return true;\n    else if (x == null) return y == null;\n    else if (y == null) return false;\n    else if ($0ba2f68448f8716d$export$a2520bc9aec4b126(x)) return x.Equals(y);\n    else if ($0ba2f68448f8716d$export$1e2f57719e155213(x)) return $0ba2f68448f8716d$export$1e2f57719e155213(y) && $0ba2f68448f8716d$export$dc63f52ecf814bf8(x, y);\n    else if (typeof x !== \"object\") return false;\n    else if (x instanceof Date) return y instanceof Date && $0ba2f68448f8716d$export$c4c806e061935577(x, y) === 0;\n    else return Object.getPrototypeOf(x)?.constructor === Object && $0ba2f68448f8716d$var$equalObjects(x, y);\n}\nfunction $0ba2f68448f8716d$export$c4c806e061935577(x, y) {\n    let xtime;\n    let ytime;\n    // DateTimeOffset and DateTime deals with equality differently.\n    if (\"offset\" in x && \"offset\" in y) {\n        xtime = x.getTime();\n        ytime = y.getTime();\n    } else {\n        xtime = x.getTime() + $0ba2f68448f8716d$export$b4360650442640a0(x);\n        ytime = y.getTime() + $0ba2f68448f8716d$export$b4360650442640a0(y);\n    }\n    return xtime === ytime ? 0 : xtime < ytime ? -1 : 1;\n}\nfunction $0ba2f68448f8716d$export$591cc4a8025fba16(x, y) {\n    return x === y ? 0 : x < y ? -1 : 1;\n}\nfunction $0ba2f68448f8716d$export$7b00afb96b8966ce(x, y, comp) {\n    if (x == null) return y == null ? 0 : 1;\n    if (y == null) return -1;\n    if (x.length !== y.length) return x.length < y.length ? -1 : 1;\n    for(let i = 0, j = 0; i < x.length; i++){\n        j = comp(x[i], y[i]);\n        if (j !== 0) return j;\n    }\n    return 0;\n}\nfunction $0ba2f68448f8716d$export$fc16749c794bf6ff(x, y) {\n    return $0ba2f68448f8716d$export$7b00afb96b8966ce(x, y, $0ba2f68448f8716d$export$398604a469f7de9a);\n}\nfunction $0ba2f68448f8716d$var$compareObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) return xKeys.length < yKeys.length ? -1 : 1;\n    xKeys.sort();\n    yKeys.sort();\n    for(let i = 0, j = 0; i < xKeys.length; i++){\n        const key = xKeys[i];\n        if (key !== yKeys[i]) return key < yKeys[i] ? -1 : 1;\n        else {\n            j = $0ba2f68448f8716d$export$398604a469f7de9a(x[key], y[key]);\n            if (j !== 0) return j;\n        }\n    }\n    return 0;\n}\nfunction $0ba2f68448f8716d$export$398604a469f7de9a(x, y) {\n    if (x === y) return 0;\n    else if (x == null) return y == null ? 0 : -1;\n    else if (y == null) return 1;\n    else if ($0ba2f68448f8716d$export$a8eb308fbdcb0e9c(x)) return x.CompareTo(y);\n    else if ($0ba2f68448f8716d$export$1e2f57719e155213(x)) return $0ba2f68448f8716d$export$1e2f57719e155213(y) ? $0ba2f68448f8716d$export$fc16749c794bf6ff(x, y) : -1;\n    else if (typeof x !== \"object\") return x < y ? -1 : 1;\n    else if (x instanceof Date) return y instanceof Date ? $0ba2f68448f8716d$export$c4c806e061935577(x, y) : -1;\n    else return Object.getPrototypeOf(x)?.constructor === Object ? $0ba2f68448f8716d$var$compareObjects(x, y) : -1;\n}\nfunction $0ba2f68448f8716d$export$96ec731ed4dcb222(comparer, x, y) {\n    return comparer(x, y) < 0 ? x : y;\n}\nfunction $0ba2f68448f8716d$export$8960430cfd85939f(comparer, x, y) {\n    return comparer(x, y) > 0 ? x : y;\n}\nfunction $0ba2f68448f8716d$export$7d15b64cf5a3a4c4(comparer, value, min, max) {\n    return comparer(value, min) < 0 ? min : comparer(value, max) > 0 ? max : value;\n}\nfunction $0ba2f68448f8716d$export$2e17fe64ec9a826e(value) {\n    let atom = value;\n    return (...args)=>{\n        if (args.length === 0) return atom;\n        else atom = args[0];\n    };\n}\nfunction $0ba2f68448f8716d$export$ad1552835d16e4ca(fields) {\n    const obj = {};\n    for (const kv of fields)obj[kv[0]] = kv[1];\n    return obj;\n}\nfunction $0ba2f68448f8716d$export$abe6afec815e60a8(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nfunction $0ba2f68448f8716d$export$2077e0241d6afd3c(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = f > 0.5 - e && f < 0.5 + e ? i % 2 === 0 ? i : i + 1 : Math.round(n);\n    return digits ? r / m : r;\n}\nfunction $0ba2f68448f8716d$export$c5552dfdbc7cec71(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nfunction $0ba2f68448f8716d$export$4aad32b45f511863(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent(s.replace(/\\+/g, \"%20\"));\n}\nfunction $0ba2f68448f8716d$export$c6a168a6353a7fe6(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\").replace(/'/g, \"%27\").replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\").replace(/\\*/g, \"%2A\");\n}\nfunction $0ba2f68448f8716d$export$a793387c99636443(s) {\n    return encodeURI(s);\n}\nfunction $0ba2f68448f8716d$export$85b9a36db797e02b(col) {\n    if ($0ba2f68448f8716d$export$1e2f57719e155213(col)) return col.length;\n    else {\n        let count = 0;\n        for (const _ of col)count++;\n        return count;\n    }\n}\nfunction $0ba2f68448f8716d$export$42ffd38884aecdac(col) {\n    if ($0ba2f68448f8716d$export$1e2f57719e155213(col)) col.splice(0);\n    else col.clear();\n}\nconst $0ba2f68448f8716d$var$curried = new WeakMap();\nfunction $0ba2f68448f8716d$export$495bf678c7ada30a(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2)=>f(a1)(a2);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$6944c5e0a4d7bdd2(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>f(a1, a2));\n}\nfunction $0ba2f68448f8716d$export$6dd46814578720b1(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3)=>f(a1)(a2)(a3);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$2ed711877756bc12(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>f(a1, a2, a3));\n}\nfunction $0ba2f68448f8716d$export$75fb6550be126673(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4)=>f(a1)(a2)(a3)(a4);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$a8e204661557a0e7(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>f(a1, a2, a3, a4));\n}\nfunction $0ba2f68448f8716d$export$a4425868a5bff0ec(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5)=>f(a1)(a2)(a3)(a4)(a5);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$19bdf157e132484e(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>f(a1, a2, a3, a4, a5));\n}\nfunction $0ba2f68448f8716d$export$50264c9e3152f4e7(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6)=>f(a1)(a2)(a3)(a4)(a5)(a6);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$4c3f1fa36ae21ea2(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>f(a1, a2, a3, a4, a5, a6));\n}\nfunction $0ba2f68448f8716d$export$291538c41595a785(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$69c3d5a842137507(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>f(a1, a2, a3, a4, a5, a6, a7));\n}\nfunction $0ba2f68448f8716d$export$110e9d6adab59a3c(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$a0ae61d3d56831e0(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>f(a1, a2, a3, a4, a5, a6, a7, a8));\n}\nfunction $0ba2f68448f8716d$export$92539c998fe36029(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$a25e348a83e1baa(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9));\n}\nfunction $0ba2f68448f8716d$export$127a72cb4b8b11d3(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$bb4bc73579e32e25(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));\n}\nfunction $0ba2f68448f8716d$export$3bc7eb57965d7cf0(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$64de315c63c5b678(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>(a11)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));\n}\nfunction $0ba2f68448f8716d$export$17cd531c09f56cdf(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$2c142431666d5b65(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>(a11)=>(a12)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12));\n}\nfunction $0ba2f68448f8716d$export$a37c8585594c6e1c(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$8307041aa4f78593(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>(a11)=>(a12)=>(a13)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13));\n}\nfunction $0ba2f68448f8716d$export$90e84022c730bc90(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$7bde3cf248f1f859(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>(a11)=>(a12)=>(a13)=>(a14)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14));\n}\nfunction $0ba2f68448f8716d$export$bc0d2c49f5d8a707(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$8f9f96e3dac7f00c(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>(a11)=>(a12)=>(a13)=>(a14)=>(a15)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15));\n}\nfunction $0ba2f68448f8716d$export$b25105d6aec6a37a(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$e001d9aaea7abe3b(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>(a11)=>(a12)=>(a13)=>(a14)=>(a15)=>(a16)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16));\n}\nfunction $0ba2f68448f8716d$export$17fbe267305929ac(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$72df03b953d70202(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>(a11)=>(a12)=>(a13)=>(a14)=>(a15)=>(a16)=>(a17)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17));\n}\nfunction $0ba2f68448f8716d$export$510a9b6d1882a70c(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$d2a33acc8b7eeed(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>(a11)=>(a12)=>(a13)=>(a14)=>(a15)=>(a16)=>(a17)=>(a18)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18));\n}\nfunction $0ba2f68448f8716d$export$7b8846a843256036(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18)(a19);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$af2ffe64dbb9db3d(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>(a11)=>(a12)=>(a13)=>(a14)=>(a15)=>(a16)=>(a17)=>(a18)=>(a19)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19));\n}\nfunction $0ba2f68448f8716d$export$85e0ea0e5c7e1a15(f) {\n    if (f == null) return null;\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)=>f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18)(a19)(a20);\n    $0ba2f68448f8716d$var$curried.set(f2, f);\n    return f2;\n}\nfunction $0ba2f68448f8716d$export$5c7d97a8e576cd32(f) {\n    return $0ba2f68448f8716d$var$curried.get(f) ?? ((a1)=>(a2)=>(a3)=>(a4)=>(a5)=>(a6)=>(a7)=>(a8)=>(a9)=>(a10)=>(a11)=>(a12)=>(a13)=>(a14)=>(a15)=>(a16)=>(a17)=>(a18)=>(a19)=>(a20)=>f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20));\n}\nfunction $0ba2f68448f8716d$export$b457c8de52d85e65(source, sourceIndex, target, targetIndex, count) {\n    if (ArrayBuffer.isView(source) && ArrayBuffer.isView(target)) target.set(source.subarray(sourceIndex, sourceIndex + count), targetIndex);\n    else for(let i = 0; i < count; ++i)target[targetIndex + i] = source[sourceIndex + i];\n}\n\n\nfunction $156d701283f9fc89$export$882a7a2eca8e1502(cons, len) {\n    if (typeof cons === \"function\") return new cons(len);\n    else return new Array(len);\n}\n\n\n\nclass $46485786458244dd$export$9f9d0139d032da4f {\n    constructor(value){\n        this.value = value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    // Don't add \"Some\" for consistency with erased options\n    toString() {\n        return String(this.value);\n    }\n    GetHashCode() {\n        return (0, $0ba2f68448f8716d$export$2e619f11ca48bee4)(this.value);\n    }\n    Equals(other) {\n        if (other == null) return false;\n        else return (0, $0ba2f68448f8716d$export$e9bab7fafb253603)(this.value, other instanceof $46485786458244dd$export$9f9d0139d032da4f ? other.value : other);\n    }\n    CompareTo(other) {\n        if (other == null) return 1;\n        else return (0, $0ba2f68448f8716d$export$398604a469f7de9a)(this.value, other instanceof $46485786458244dd$export$9f9d0139d032da4f ? other.value : other);\n    }\n}\nfunction $46485786458244dd$export$2ab9a8f9f1186f14(x) {\n    if (x == null) throw new Error(\"Option has no value\");\n    else return x instanceof $46485786458244dd$export$9f9d0139d032da4f ? x.value : x;\n}\nfunction $46485786458244dd$export$debb760848ca95a(opt) {\n    return opt instanceof $46485786458244dd$export$9f9d0139d032da4f ? opt.value : opt;\n}\nfunction $46485786458244dd$export$ad14ef4001db2bcd(x) {\n    return x == null || x instanceof $46485786458244dd$export$9f9d0139d032da4f ? new $46485786458244dd$export$9f9d0139d032da4f(x) : x;\n}\nfunction $46485786458244dd$export$e724fd86d7aa146b(x) {\n    // This will fail with unit probably, an alternative would be:\n    // return x === null ? undefined : (x === undefined ? new Some(x) : x);\n    return x == null ? undefined : x;\n}\nfunction $46485786458244dd$export$b187f57ee1822bc5(x) {\n    return x == null ? null : $46485786458244dd$export$2ab9a8f9f1186f14(x);\n}\nfunction $46485786458244dd$export$bffa455ba8c619a6(x) {\n    return x == null ? undefined : $46485786458244dd$export$2ab9a8f9f1186f14(x);\n}\nfunction $46485786458244dd$export$45b10814cc054894(opt) {\n    return opt == null ? [] : [\n        $46485786458244dd$export$2ab9a8f9f1186f14(opt)\n    ];\n}\nfunction $46485786458244dd$export$37721a79838ca038(opt, defaultValue) {\n    return opt != null ? $46485786458244dd$export$2ab9a8f9f1186f14(opt) : defaultValue;\n}\nfunction $46485786458244dd$export$c90763f2293d7e67(opt, defThunk) {\n    return opt != null ? $46485786458244dd$export$2ab9a8f9f1186f14(opt) : defThunk();\n}\nfunction $46485786458244dd$export$41d1a04d78e7b141(opt, ifNone) {\n    return opt == null ? ifNone : opt;\n}\nfunction $46485786458244dd$export$eb1968ae3f7e8865(opt, ifNoneThunk) {\n    return opt == null ? ifNoneThunk() : opt;\n}\nfunction $46485786458244dd$export$3dea766d36a8935f(predicate, opt) {\n    return opt != null ? predicate($46485786458244dd$export$2ab9a8f9f1186f14(opt)) ? opt : undefined : opt;\n}\nfunction $46485786458244dd$export$871de8747c9eaa88(mapping, opt) {\n    return opt != null ? $46485786458244dd$export$ad14ef4001db2bcd(mapping($46485786458244dd$export$2ab9a8f9f1186f14(opt))) : undefined;\n}\nfunction $46485786458244dd$export$5be556bf484c4f10(mapping, opt1, opt2) {\n    return opt1 != null && opt2 != null ? mapping($46485786458244dd$export$2ab9a8f9f1186f14(opt1), $46485786458244dd$export$2ab9a8f9f1186f14(opt2)) : undefined;\n}\nfunction $46485786458244dd$export$f7389512af34c855(mapping, opt1, opt2, opt3) {\n    return opt1 != null && opt2 != null && opt3 != null ? mapping($46485786458244dd$export$2ab9a8f9f1186f14(opt1), $46485786458244dd$export$2ab9a8f9f1186f14(opt2), $46485786458244dd$export$2ab9a8f9f1186f14(opt3)) : undefined;\n}\nfunction $46485786458244dd$export$2385a24977818dd0(binder, opt) {\n    return opt != null ? binder($46485786458244dd$export$2ab9a8f9f1186f14(opt)) : undefined;\n}\nfunction $46485786458244dd$export$4324eaa7776d3b57(op, arg) {\n    try {\n        return $46485786458244dd$export$ad14ef4001db2bcd(op(arg));\n    } catch  {\n        return undefined;\n    }\n}\n\n\n\nfunction $41925774fb695aae$export$67548df8c961d303(self) {\n    let count = 0;\n    let str = \"[\";\n    for (const x of self){\n        if (count === 0) str += $41925774fb695aae$export$f84e8e69fd4488a5(x);\n        else if (count === 100) {\n            str += \"; ...\";\n            break;\n        } else str += \"; \" + $41925774fb695aae$export$f84e8e69fd4488a5(x);\n        count++;\n    }\n    return str + \"]\";\n}\nfunction $41925774fb695aae$export$f84e8e69fd4488a5(x, callStack = 0) {\n    if (x != null && typeof x === \"object\") {\n        if (typeof x.toString === \"function\") return x.toString();\n        else if (Symbol.iterator in x) return $41925774fb695aae$export$67548df8c961d303(x);\n        else {\n            const cons = Object.getPrototypeOf(x)?.constructor;\n            return cons === Object && callStack < 10 ? \"{ \" + Object.entries(x).map(([k, v])=>k + \" = \" + $41925774fb695aae$export$f84e8e69fd4488a5(v, callStack + 1)).join(\"\\n  \") + \" }\" : cons?.name ?? \"\";\n        }\n    }\n    return String(x);\n}\nfunction $41925774fb695aae$export$19c5b35f73b7bbbc(name, fields) {\n    if (fields.length === 0) return name;\n    else {\n        let fieldStr;\n        let withParens = true;\n        if (fields.length === 1) {\n            fieldStr = $41925774fb695aae$export$f84e8e69fd4488a5(fields[0]);\n            withParens = fieldStr.indexOf(\" \") >= 0;\n        } else fieldStr = fields.map((x)=>$41925774fb695aae$export$f84e8e69fd4488a5(x)).join(\", \");\n        return name + (withParens ? \" (\" : \" \") + fieldStr + (withParens ? \")\" : \"\");\n    }\n}\nclass $41925774fb695aae$export$6cbb4f8fa0c4c986 {\n    get name() {\n        return this.cases()[this.tag];\n    }\n    toJSON() {\n        return this.fields.length === 0 ? this.name : [\n            this.name\n        ].concat(this.fields);\n    }\n    toString() {\n        return $41925774fb695aae$export$19c5b35f73b7bbbc(this.name, this.fields);\n    }\n    GetHashCode() {\n        const hashes = this.fields.map((x)=>(0, $0ba2f68448f8716d$export$2e619f11ca48bee4)(x));\n        hashes.splice(0, 0, (0, $0ba2f68448f8716d$export$a9844eb73de0a218)(this.tag));\n        return (0, $0ba2f68448f8716d$export$4a6567c520a28ea3)(hashes);\n    }\n    Equals(other) {\n        if (this === other) return true;\n        else if (!(0, $0ba2f68448f8716d$export$52febab2880147bb)(this, other)) return false;\n        else if (this.tag === other.tag) return (0, $0ba2f68448f8716d$export$dc63f52ecf814bf8)(this.fields, other.fields);\n        else return false;\n    }\n    CompareTo(other) {\n        if (this === other) return 0;\n        else if (!(0, $0ba2f68448f8716d$export$52febab2880147bb)(this, other)) return -1;\n        else if (this.tag === other.tag) return (0, $0ba2f68448f8716d$export$fc16749c794bf6ff)(this.fields, other.fields);\n        else return this.tag < other.tag ? -1 : 1;\n    }\n}\nfunction $41925774fb695aae$var$recordToJSON(self) {\n    const o = {};\n    const keys = Object.keys(self);\n    for(let i = 0; i < keys.length; i++)o[keys[i]] = self[keys[i]];\n    return o;\n}\nfunction $41925774fb695aae$var$recordToString(self) {\n    return \"{ \" + Object.entries(self).map(([k, v])=>k + \" = \" + $41925774fb695aae$export$f84e8e69fd4488a5(v)).join(\"\\n  \") + \" }\";\n}\nfunction $41925774fb695aae$var$recordGetHashCode(self) {\n    const hashes = Object.values(self).map((v)=>(0, $0ba2f68448f8716d$export$2e619f11ca48bee4)(v));\n    return (0, $0ba2f68448f8716d$export$4a6567c520a28ea3)(hashes);\n}\nfunction $41925774fb695aae$var$recordEquals(self, other) {\n    if (self === other) return true;\n    else if (!(0, $0ba2f68448f8716d$export$52febab2880147bb)(self, other)) return false;\n    else {\n        const thisNames = Object.keys(self);\n        for(let i = 0; i < thisNames.length; i++){\n            if (!(0, $0ba2f68448f8716d$export$e9bab7fafb253603)(self[thisNames[i]], other[thisNames[i]])) return false;\n        }\n        return true;\n    }\n}\nfunction $41925774fb695aae$var$recordCompareTo(self, other) {\n    if (self === other) return 0;\n    else if (!(0, $0ba2f68448f8716d$export$52febab2880147bb)(self, other)) return -1;\n    else {\n        const thisNames = Object.keys(self);\n        for(let i = 0; i < thisNames.length; i++){\n            const result = (0, $0ba2f68448f8716d$export$398604a469f7de9a)(self[thisNames[i]], other[thisNames[i]]);\n            if (result !== 0) return result;\n        }\n        return 0;\n    }\n}\nclass $41925774fb695aae$export$5b163c6d120341e7 {\n    toJSON() {\n        return $41925774fb695aae$var$recordToJSON(this);\n    }\n    toString() {\n        return $41925774fb695aae$var$recordToString(this);\n    }\n    GetHashCode() {\n        return $41925774fb695aae$var$recordGetHashCode(this);\n    }\n    Equals(other) {\n        return $41925774fb695aae$var$recordEquals(this, other);\n    }\n    CompareTo(other) {\n        return $41925774fb695aae$var$recordCompareTo(this, other);\n    }\n}\nclass $41925774fb695aae$export$be150d1a3c7e94fe {\n    get contents() {\n        return this.getter();\n    }\n    set contents(v) {\n        this.setter(v);\n    }\n    constructor(contentsOrGetter, setter){\n        if (typeof setter === \"function\") {\n            this.getter = contentsOrGetter;\n            this.setter = setter;\n        } else {\n            this.getter = ()=>contentsOrGetter;\n            this.setter = (v)=>{\n                contentsOrGetter = v;\n            };\n        }\n    }\n}\nclass $41925774fb695aae$export$e2f174de097e0bcd {\n    constructor(message){\n        this.message = message;\n    }\n}\nfunction $41925774fb695aae$export$40f07171f4b6ee01(x) {\n    return x instanceof $41925774fb695aae$export$e2f174de097e0bcd || x instanceof Error;\n}\nfunction $41925774fb695aae$export$4369c812aac99591(x) {\n    return x instanceof Promise;\n}\nfunction $41925774fb695aae$export$1ad1de0e03fe42fe(e) {\n    // Exceptionally admitting promises as errors for compatibility with React.suspense (see #3298)\n    return $41925774fb695aae$export$40f07171f4b6ee01(e) || $41925774fb695aae$export$4369c812aac99591(e) ? e : new Error(String(e));\n}\nclass $41925774fb695aae$export$bf6d26922abbea07 extends $41925774fb695aae$export$e2f174de097e0bcd {\n    toJSON() {\n        return $41925774fb695aae$var$recordToJSON(this);\n    }\n    toString() {\n        return $41925774fb695aae$var$recordToString(this);\n    }\n    GetHashCode() {\n        return $41925774fb695aae$var$recordGetHashCode(this);\n    }\n    Equals(other) {\n        return $41925774fb695aae$var$recordEquals(this, other);\n    }\n    CompareTo(other) {\n        return $41925774fb695aae$var$recordCompareTo(this, other);\n    }\n}\nclass $41925774fb695aae$export$56fde45cb633adea extends $41925774fb695aae$export$bf6d26922abbea07 {\n    constructor(arg1, arg2, arg3){\n        super();\n        this.arg1 = arg1;\n        this.arg2 = arg2 | 0;\n        this.arg3 = arg3 | 0;\n        this.message = \"The match cases were incomplete\";\n    }\n}\nclass $41925774fb695aae$export$ab9c25261cd8c720 {\n}\n\n\nfunction $4840af1467e42596$export$468ff95b83d315e5(str, defValue) {\n    // TODO: test if value is valid and in range\n    if (str != null && /\\S/.test(str)) {\n        const v = +str.replace(\"_\", \"\");\n        if (!Number.isNaN(v)) {\n            defValue.contents = v;\n            return true;\n        }\n    }\n    return false;\n}\nfunction $4840af1467e42596$export$98e6a39c04603d36(str) {\n    const defValue = new (0, $41925774fb695aae$export$be150d1a3c7e94fe)(0);\n    if ($4840af1467e42596$export$468ff95b83d315e5(str, defValue)) return defValue.contents;\n    else throw new Error(`The input string ${str} was not in a correct format.`);\n}\nfunction $4840af1467e42596$export$cedde49ca4e635df(x) {\n    return x === Number.POSITIVE_INFINITY;\n}\nfunction $4840af1467e42596$export$86dc1490ec32fe0a(x) {\n    return x === Number.NEGATIVE_INFINITY;\n}\nfunction $4840af1467e42596$export$4c8a3b4c9715e22d(x) {\n    return x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY;\n}\nfunction $4840af1467e42596$export$8960430cfd85939f(x, y) {\n    return x > y ? x : y;\n}\nfunction $4840af1467e42596$export$96ec731ed4dcb222(x, y) {\n    return x < y ? x : y;\n}\nfunction $4840af1467e42596$export$d5c1c11e7369f9ca(x, y) {\n    return Math.abs(x) > Math.abs(y) ? x : y;\n}\nfunction $4840af1467e42596$export$98c4be7bef211208(x, y) {\n    return Math.abs(x) < Math.abs(y) ? x : y;\n}\nfunction $4840af1467e42596$export$7d15b64cf5a3a4c4(x, min, max) {\n    return x < min ? min : x > max ? max : x;\n}\n\n\n\nconst $3872cbf98ba8550b$export$1d7558b55257001d = \"The index was outside the range of elements in the collection.\";\nconst $3872cbf98ba8550b$export$6f6b0078912f4c4b = \"Collection was empty.\";\nconst $3872cbf98ba8550b$export$2f1b8e728b004525 = \"The input must be non-negative.\";\nconst $3872cbf98ba8550b$export$bb8ebba5bfe3f17a = \"The input sequence was empty.\";\nconst $3872cbf98ba8550b$export$8f2c469045724186 = \"The input sequence contains more than one element.\";\nconst $3872cbf98ba8550b$export$bc2c3bc917b1d953 = \"An index satisfying the predicate was not found in the collection.\";\nconst $3872cbf98ba8550b$export$11574e3a2ac48981 = \"The collections had different lengths.\";\nconst $3872cbf98ba8550b$export$9f17aeddfa374276 = \"The input sequence has an insufficient number of elements.\";\n\n\nfunction $01e2cc4a8ea727fe$var$indexNotFound() {\n    throw new Error(\"An index satisfying the predicate was not found in the collection.\");\n}\nfunction $01e2cc4a8ea727fe$var$differentLengths() {\n    throw new Error(\"Arrays had different lengths\");\n}\nfunction $01e2cc4a8ea727fe$export$10d8903dec122b9d(array1, array2, cons) {\n    const len1 = array1.length | 0;\n    const len2 = array2.length | 0;\n    const newArray = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, len1 + len2);\n    for(let i = 0; i <= len1 - 1; i++)newArray[i] = array1[i];\n    for(let i_1 = 0; i_1 <= len2 - 1; i_1++)newArray[i_1 + len1] = array2[i_1];\n    return newArray;\n}\nfunction $01e2cc4a8ea727fe$export$3dea766d36a8935f(predicate, array) {\n    return array.filter(predicate);\n}\nfunction $01e2cc4a8ea727fe$export$9563e054e6f787fb(target, targetIndex, count, value) {\n    const start = targetIndex | 0;\n    return target.fill(value, start, start + count);\n}\nfunction $01e2cc4a8ea727fe$export$482c79a7d4ed32a1(array, start, count) {\n    const start_1 = start | 0;\n    return array.slice(start_1, start_1 + count);\n}\nfunction $01e2cc4a8ea727fe$export$4c7897fafd92b108(array) {\n    if (array.length === 0) throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    return array[array.length - 1];\n}\nfunction $01e2cc4a8ea727fe$export$e5907b21d797cce6(array) {\n    if (array.length === 0) return void 0;\n    else return (0, $46485786458244dd$export$ad14ef4001db2bcd)(array[array.length - 1]);\n}\nfunction $01e2cc4a8ea727fe$export$e5bd5b3b105c2a71(f, source, cons) {\n    const len = source.length | 0;\n    const target = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, len);\n    for(let i = 0; i <= len - 1; i++)target[i] = f(i, source[i]);\n    return target;\n}\nfunction $01e2cc4a8ea727fe$export$871de8747c9eaa88(f, source, cons) {\n    const len = source.length | 0;\n    const target = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, len);\n    for(let i = 0; i <= len - 1; i++)target[i] = f(source[i]);\n    return target;\n}\nfunction $01e2cc4a8ea727fe$export$aded800c294daba4(f, source1, source2, cons) {\n    if (source1.length !== source2.length) throw new Error(\"Arrays had different lengths\");\n    const result = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, source1.length);\n    for(let i = 0; i <= source1.length - 1; i++)result[i] = f(i, source1[i], source2[i]);\n    return result;\n}\nfunction $01e2cc4a8ea727fe$export$5be556bf484c4f10(f, source1, source2, cons) {\n    if (source1.length !== source2.length) throw new Error(\"Arrays had different lengths\");\n    const result = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, source1.length);\n    for(let i = 0; i <= source1.length - 1; i++)result[i] = f(source1[i], source2[i]);\n    return result;\n}\nfunction $01e2cc4a8ea727fe$export$9ba7fb30dbbb3821(f, source1, source2, source3, cons) {\n    if (source1.length !== source2.length ? true : source2.length !== source3.length) throw new Error(\"Arrays had different lengths\");\n    const result = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, source1.length);\n    for(let i = 0; i <= source1.length - 1; i++)result[i] = f(i, source1[i], source2[i], source3[i]);\n    return result;\n}\nfunction $01e2cc4a8ea727fe$export$f7389512af34c855(f, source1, source2, source3, cons) {\n    if (source1.length !== source2.length ? true : source2.length !== source3.length) throw new Error(\"Arrays had different lengths\");\n    const result = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, source1.length);\n    for(let i = 0; i <= source1.length - 1; i++)result[i] = f(source1[i], source2[i], source3[i]);\n    return result;\n}\nfunction $01e2cc4a8ea727fe$export$9b19c2e3f2aab20f(mapping, state, array, cons) {\n    const matchValue = array.length | 0;\n    if (matchValue === 0) return [\n        [],\n        state\n    ];\n    else {\n        let acc = state;\n        const res = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, matchValue);\n        for(let i = 0; i <= array.length - 1; i++){\n            const patternInput = mapping(acc, array[i]);\n            res[i] = patternInput[0];\n            acc = patternInput[1];\n        }\n        return [\n            res,\n            acc\n        ];\n    }\n}\nfunction $01e2cc4a8ea727fe$export$6d7c6abab27be307(mapping, array, state, cons) {\n    const matchValue = array.length | 0;\n    if (matchValue === 0) return [\n        [],\n        state\n    ];\n    else {\n        let acc = state;\n        const res = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, matchValue);\n        for(let i = array.length - 1; i >= 0; i--){\n            const patternInput = mapping(array[i], acc);\n            res[i] = patternInput[0];\n            acc = patternInput[1];\n        }\n        return [\n            res,\n            acc\n        ];\n    }\n}\nfunction $01e2cc4a8ea727fe$export$ddf7c77acd0bf516(source) {\n    const len = source.length | 0;\n    const target = new Array(len);\n    for(let i = 0; i <= len - 1; i++)target[i] = [\n        i,\n        source[i]\n    ];\n    return target;\n}\nfunction $01e2cc4a8ea727fe$export$6a506b36fdea397d(count, array) {\n    const count_1 = (0, $4840af1467e42596$export$8960430cfd85939f)(0, count) | 0;\n    return array.slice(0, 0 + count_1);\n}\nfunction $01e2cc4a8ea727fe$export$ee1b3e54f0441b22(arrays, cons) {\n    const arrays_1 = Array.isArray(arrays) ? arrays : Array.from(arrays);\n    const matchValue = arrays_1.length | 0;\n    switch(matchValue){\n        case 0:\n            return (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, 0);\n        case 1:\n            return arrays_1[0];\n        default:\n            {\n                let totalIdx = 0;\n                let totalLength = 0;\n                for(let idx = 0; idx <= arrays_1.length - 1; idx++){\n                    const arr_1 = arrays_1[idx];\n                    totalLength = totalLength + arr_1.length | 0;\n                }\n                const result = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, totalLength);\n                for(let idx_1 = 0; idx_1 <= arrays_1.length - 1; idx_1++){\n                    const arr_2 = arrays_1[idx_1];\n                    for(let j = 0; j <= arr_2.length - 1; j++){\n                        result[totalIdx] = arr_2[j];\n                        totalIdx = totalIdx + 1 | 0;\n                    }\n                }\n                return result;\n            }\n    }\n}\nfunction $01e2cc4a8ea727fe$export$bb44f104e3c54dae(mapping, array, cons) {\n    return $01e2cc4a8ea727fe$export$ee1b3e54f0441b22($01e2cc4a8ea727fe$export$871de8747c9eaa88(mapping, array, (0, $0ba2f68448f8716d$export$439614834d2d5072)()), cons);\n}\nfunction $01e2cc4a8ea727fe$export$9c59b80dda569a6e(predicate, array) {\n    return array.filter(predicate);\n}\nfunction $01e2cc4a8ea727fe$export$305f7d4e9d4624f2(array, item_1, start, count, eq) {\n    const start_1 = (0, $46485786458244dd$export$37721a79838ca038)(start, 0) | 0;\n    const end$0027 = (0, $46485786458244dd$export$37721a79838ca038)((0, $46485786458244dd$export$871de8747c9eaa88)((c)=>start_1 + c, count), array.length) | 0;\n    const loop = (i_mut)=>{\n        loop: while(true){\n            const i = i_mut;\n            if (i >= end$0027) return -1;\n            else if (eq.Equals(item_1, array[i])) return i | 0;\n            else {\n                i_mut = i + 1;\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(start_1) | 0;\n}\nfunction $01e2cc4a8ea727fe$export$2344b14b097df817(value, array, eq) {\n    return $01e2cc4a8ea727fe$export$305f7d4e9d4624f2(array, value, void 0, void 0, eq) >= 0;\n}\nfunction $01e2cc4a8ea727fe$export$6e22c362a0406a2c(cons) {\n    return (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, 0);\n}\nfunction $01e2cc4a8ea727fe$export$439306a4dcaafbb9(value, cons) {\n    const ar = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, 1);\n    ar[0] = value;\n    return ar;\n}\nfunction $01e2cc4a8ea727fe$export$2a47f398eeff8b01(count, initializer, cons) {\n    if (count < 0) throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    const result = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, count);\n    for(let i = 0; i <= count - 1; i++)result[i] = initializer(i);\n    return result;\n}\nfunction $01e2cc4a8ea727fe$export$8f9d79d42bff1aac(array) {\n    if (array.length < 2) return [];\n    else {\n        const count = array.length - 1 | 0;\n        const result = new Array(count);\n        for(let i = 0; i <= count - 1; i++)result[i] = [\n            array[i],\n            array[i + 1]\n        ];\n        return result;\n    }\n}\nfunction $01e2cc4a8ea727fe$export$606959e7ccb797f0(count, initial, cons) {\n    if (count < 0) throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    const result = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, count);\n    for(let i = 0; i <= result.length - 1; i++)result[i] = initial;\n    return result;\n}\nfunction $01e2cc4a8ea727fe$export$784d13d8ee351f07(array) {\n    return array.slice();\n}\nfunction $01e2cc4a8ea727fe$export$1c7fb22ad89b2a7c(source, sourceIndex, target, targetIndex, count) {\n    (0, $0ba2f68448f8716d$export$b457c8de52d85e65)(source, sourceIndex, target, targetIndex, count);\n}\nfunction $01e2cc4a8ea727fe$export$66c1ae025e96b4bc(array) {\n    const array_2 = array.slice();\n    return array_2.reverse();\n}\nfunction $01e2cc4a8ea727fe$export$c87d910e63d22ed6(folder, state, array, cons) {\n    const res = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, array.length + 1);\n    res[0] = state;\n    for(let i = 0; i <= array.length - 1; i++)res[i + 1] = folder(res[i], array[i]);\n    return res;\n}\nfunction $01e2cc4a8ea727fe$export$7bd1078b283d99ad(folder, array, state, cons) {\n    const res = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, array.length + 1);\n    res[array.length] = state;\n    for(let i = array.length - 1; i >= 0; i--)res[i] = folder(array[i], res[i + 1]);\n    return res;\n}\nfunction $01e2cc4a8ea727fe$export$955fc4a6c4be454d(count, array, cons) {\n    if (count > array.length) throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n    if (count === array.length) return (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, 0);\n    else {\n        const count_1 = (count < 0 ? 0 : count) | 0;\n        return array.slice(count_1);\n    }\n}\nfunction $01e2cc4a8ea727fe$export$175dedd748069215(predicate, array, cons) {\n    let count = 0;\n    while(count < array.length && predicate(array[count]))count = count + 1 | 0;\n    if (count === array.length) return (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, 0);\n    else {\n        const count_1 = count | 0;\n        return array.slice(count_1);\n    }\n}\nfunction $01e2cc4a8ea727fe$export$b7df5d561049483a(count, array, cons) {\n    if (count < 0) throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    if (count > array.length) throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n    if (count === 0) return (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, 0);\n    else return array.slice(0, 0 + count);\n}\nfunction $01e2cc4a8ea727fe$export$9384c7afe4015e42(predicate, array, cons) {\n    let count = 0;\n    while(count < array.length && predicate(array[count]))count = count + 1 | 0;\n    if (count === 0) return (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, 0);\n    else {\n        const count_1 = count | 0;\n        return array.slice(0, 0 + count_1);\n    }\n}\nfunction $01e2cc4a8ea727fe$export$7085ea1126df7818(x, array) {\n    array.push(x);\n}\nfunction $01e2cc4a8ea727fe$export$9760889ead41947a(range, array) {\n    const enumerator = (0, $0ba2f68448f8716d$export$a41738691dcd8bea)(range);\n    try {\n        while(enumerator[\"System.Collections.IEnumerator.MoveNext\"]())$01e2cc4a8ea727fe$export$7085ea1126df7818(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), array);\n    } finally{\n        (0, $0ba2f68448f8716d$export$466534c54e60af80)(enumerator);\n    }\n}\nfunction $01e2cc4a8ea727fe$export$73ea5dcdf758ae6e(index, range, array) {\n    let index_1;\n    let i = index;\n    const enumerator = (0, $0ba2f68448f8716d$export$a41738691dcd8bea)(range);\n    try {\n        while(enumerator[\"System.Collections.IEnumerator.MoveNext\"]()){\n            const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\n            index_1 = i | 0, array.splice(index_1, 0, x);\n            i = i + 1 | 0;\n        }\n    } finally{\n        (0, $0ba2f68448f8716d$export$466534c54e60af80)(enumerator);\n    }\n}\nfunction $01e2cc4a8ea727fe$export$94ff4a985fbc3b28(item_1, array, eq) {\n    const i = $01e2cc4a8ea727fe$export$305f7d4e9d4624f2(array, item_1, void 0, void 0, eq) | 0;\n    if (i > -1) {\n        array.splice(i, 1);\n        return true;\n    } else return false;\n}\nfunction $01e2cc4a8ea727fe$export$50ed39f80a942033(predicate, array) {\n    const countRemoveAll = (count)=>{\n        const i = array.findIndex(predicate) | 0;\n        if (i > -1) {\n            array.splice(i, 1);\n            return countRemoveAll(count) + 1 | 0;\n        } else return count | 0;\n    };\n    return countRemoveAll(0) | 0;\n}\nfunction $01e2cc4a8ea727fe$export$b29f828819edca8d(f, source, cons) {\n    const len = source.length | 0;\n    const res1 = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, len);\n    const res2 = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, len);\n    let iTrue = 0;\n    let iFalse = 0;\n    for(let i = 0; i <= len - 1; i++)if (f(source[i])) {\n        res1[iTrue] = source[i];\n        iTrue = iTrue + 1 | 0;\n    } else {\n        res2[iFalse] = source[i];\n        iFalse = iFalse + 1 | 0;\n    }\n    return [\n        $01e2cc4a8ea727fe$export$6a506b36fdea397d(iTrue, res1),\n        $01e2cc4a8ea727fe$export$6a506b36fdea397d(iFalse, res2)\n    ];\n}\nfunction $01e2cc4a8ea727fe$export$71aa6c912b956294(predicate, array) {\n    const matchValue = array.find(predicate);\n    if (matchValue == null) return $01e2cc4a8ea727fe$var$indexNotFound();\n    else return (0, $46485786458244dd$export$2ab9a8f9f1186f14)(matchValue);\n}\nfunction $01e2cc4a8ea727fe$export$d65cb303b863e3bf(predicate, array) {\n    return array.find(predicate);\n}\nfunction $01e2cc4a8ea727fe$export$de3a4d4a0d731119(predicate, array) {\n    const matchValue = array.findIndex(predicate) | 0;\n    if (matchValue > -1) return matchValue | 0;\n    else {\n        $01e2cc4a8ea727fe$var$indexNotFound();\n        return -1;\n    }\n}\nfunction $01e2cc4a8ea727fe$export$5c13475397a61429(predicate, array) {\n    const matchValue = array.findIndex(predicate) | 0;\n    if (matchValue > -1) return matchValue;\n    else return void 0;\n}\nfunction $01e2cc4a8ea727fe$export$357523c63a2253b9(chooser, array) {\n    const loop = (i_mut)=>{\n        loop: while(true){\n            const i = i_mut;\n            if (i >= array.length) return $01e2cc4a8ea727fe$var$indexNotFound();\n            else {\n                const matchValue = chooser(array[i]);\n                if (matchValue != null) return (0, $46485786458244dd$export$2ab9a8f9f1186f14)(matchValue);\n                else {\n                    i_mut = i + 1;\n                    continue loop;\n                }\n            }\n            break;\n        }\n    };\n    return loop(0);\n}\nfunction $01e2cc4a8ea727fe$export$d944e5c60afb688e(chooser, array) {\n    const loop = (i_mut)=>{\n        loop: while(true){\n            const i = i_mut;\n            if (i >= array.length) return void 0;\n            else {\n                const matchValue = chooser(array[i]);\n                if (matchValue == null) {\n                    i_mut = i + 1;\n                    continue loop;\n                } else return matchValue;\n            }\n            break;\n        }\n    };\n    return loop(0);\n}\nfunction $01e2cc4a8ea727fe$export$ec18defb06d12add(predicate, array) {\n    const loop = (i_mut)=>{\n        loop: while(true){\n            const i = i_mut;\n            if (i < 0) return $01e2cc4a8ea727fe$var$indexNotFound();\n            else if (predicate(array[i])) return array[i];\n            else {\n                i_mut = i - 1;\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nfunction $01e2cc4a8ea727fe$export$36425195e236bb0f(predicate, array) {\n    const loop = (i_mut)=>{\n        loop: while(true){\n            const i = i_mut;\n            if (i < 0) return void 0;\n            else if (predicate(array[i])) return (0, $46485786458244dd$export$ad14ef4001db2bcd)(array[i]);\n            else {\n                i_mut = i - 1;\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nfunction $01e2cc4a8ea727fe$export$8855a8be7bd3e9f8(predicate, array) {\n    const loop = (i_mut)=>{\n        loop: while(true){\n            const i = i_mut;\n            if (i < 0) return -1;\n            else if (predicate(array[i])) return i | 0;\n            else {\n                i_mut = i - 1;\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1) | 0;\n}\nfunction $01e2cc4a8ea727fe$export$78e19deb30f83296(predicate, array) {\n    const loop = (i_mut)=>{\n        loop: while(true){\n            const i = i_mut;\n            if (i < 0) {\n                $01e2cc4a8ea727fe$var$indexNotFound();\n                return -1;\n            } else if (predicate(array[i])) return i | 0;\n            else {\n                i_mut = i - 1;\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1) | 0;\n}\nfunction $01e2cc4a8ea727fe$export$e1cc954945760117(predicate, array) {\n    const loop = (i_mut)=>{\n        loop: while(true){\n            const i = i_mut;\n            if (i < 0) return void 0;\n            else if (predicate(array[i])) return i;\n            else {\n                i_mut = i - 1;\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nfunction $01e2cc4a8ea727fe$export$7877a478dd30fd3d(chooser, array, cons) {\n    const res = [];\n    for(let i = 0; i <= array.length - 1; i++){\n        const matchValue = chooser(array[i]);\n        if (matchValue != null) {\n            const y = (0, $46485786458244dd$export$2ab9a8f9f1186f14)(matchValue);\n            res.push(y);\n        }\n    }\n    if ((0, $0ba2f68448f8716d$export$e9bab7fafb253603)(cons, (0, $0ba2f68448f8716d$export$439614834d2d5072)())) return res;\n    else return $01e2cc4a8ea727fe$export$871de8747c9eaa88((x)=>x, res, cons);\n}\nfunction $01e2cc4a8ea727fe$export$c336ee92e62ce644(folder, state, array) {\n    return array.reduce((delegateArg, delegateArg_1, delegateArg_2)=>folder(delegateArg_2, delegateArg, delegateArg_1), state);\n}\nfunction $01e2cc4a8ea727fe$export$93e2b83da34ff82a(folder, state, array) {\n    return array.reduce(folder, state);\n}\nfunction $01e2cc4a8ea727fe$export$c1a059043cc9c119(action, array) {\n    for(let i = 0; i <= array.length - 1; i++)action(array[i]);\n}\nfunction $01e2cc4a8ea727fe$export$5a067165821eae2d(action, array) {\n    for(let i = 0; i <= array.length - 1; i++)action(i, array[i]);\n}\nfunction $01e2cc4a8ea727fe$export$d1731a37ee7d4fbb(action, array1, array2) {\n    if (array1.length !== array2.length) $01e2cc4a8ea727fe$var$differentLengths();\n    for(let i = 0; i <= array1.length - 1; i++)action(array1[i], array2[i]);\n}\nfunction $01e2cc4a8ea727fe$export$ab3c1f9aeb4948fd(action, array1, array2) {\n    if (array1.length !== array2.length) $01e2cc4a8ea727fe$var$differentLengths();\n    for(let i = 0; i <= array1.length - 1; i++)action(i, array1[i], array2[i]);\n}\nfunction $01e2cc4a8ea727fe$export$dd1bc94b04021eeb(array) {\n    return array.length === 0;\n}\nfunction $01e2cc4a8ea727fe$export$e5bd981f5eeebe3b(predicate, array) {\n    return array.every(predicate);\n}\nfunction $01e2cc4a8ea727fe$export$95e62ad65da8b7d2(f, array) {\n    const size = array.length | 0;\n    const res = array.slice();\n    const checkFlags = new Array(size);\n    $01e2cc4a8ea727fe$export$5a067165821eae2d((i, x)=>{\n        const j = f(i) | 0;\n        if (j < 0 ? true : j >= size) throw new Error(\"Not a valid permutation\");\n        res[j] = x;\n        checkFlags[j] = 1;\n    }, array);\n    if (!checkFlags.every((y)=>1 === y)) throw new Error(\"Not a valid permutation\");\n    return res;\n}\nfunction $01e2cc4a8ea727fe$export$673bd84e9c48e6b2(target, lower, upper, source) {\n    const lower_1 = (0, $46485786458244dd$export$37721a79838ca038)(lower, 0) | 0;\n    const upper_1 = (0, $46485786458244dd$export$37721a79838ca038)(upper, -1) | 0;\n    const length = (upper_1 >= 0 ? upper_1 : target.length - 1) - lower_1 | 0;\n    for(let i = 0; i <= length; i++)target[i + lower_1] = source[i];\n}\nfunction $01e2cc4a8ea727fe$export$9a2c8f31e984c6d5(projection, xs, comparer) {\n    xs.sort((x, y)=>comparer.Compare(projection(x), projection(y)));\n}\nfunction $01e2cc4a8ea727fe$export$f76e9de28552298f(xs, comparer) {\n    xs.sort((x, y)=>comparer.Compare(x, y));\n}\nfunction $01e2cc4a8ea727fe$export$97db5808d8f88186(xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y)=>comparer.Compare(x, y));\n    return xs_1;\n}\nfunction $01e2cc4a8ea727fe$export$b035e44d7bb4278f(projection, xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y)=>comparer.Compare(projection(x), projection(y)));\n    return xs_1;\n}\nfunction $01e2cc4a8ea727fe$export$9a59fdf05ed66d15(xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y)=>comparer.Compare(x, y) * -1);\n    return xs_1;\n}\nfunction $01e2cc4a8ea727fe$export$ca6dab212df382f6(projection, xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y)=>comparer.Compare(projection(x), projection(y)) * -1);\n    return xs_1;\n}\nfunction $01e2cc4a8ea727fe$export$a9e7d1a6fdcfefde(comparer, xs) {\n    const comparer_1 = comparer;\n    const xs_1 = xs.slice();\n    xs_1.sort(comparer_1);\n    return xs_1;\n}\nfunction $01e2cc4a8ea727fe$export$8016484fb8238078(xs, ys) {\n    const len1 = xs.length | 0;\n    const len2 = ys.length | 0;\n    const res = new Array(len1 * len2);\n    for(let i = 0; i <= xs.length - 1; i++)for(let j = 0; j <= ys.length - 1; j++)res[i * len2 + j] = [\n        xs[i],\n        ys[j]\n    ];\n    return res;\n}\nfunction $01e2cc4a8ea727fe$export$c48e357c1a89b78d(generator, state) {\n    const res = [];\n    const loop = (state_1_mut)=>{\n        loop: while(true){\n            const state_1 = state_1_mut;\n            const matchValue = generator(state_1);\n            if (matchValue != null) {\n                const x = (0, $46485786458244dd$export$2ab9a8f9f1186f14)(matchValue)[0];\n                const s = (0, $46485786458244dd$export$2ab9a8f9f1186f14)(matchValue)[1];\n                res.push(x);\n                state_1_mut = s;\n                continue loop;\n            }\n            break;\n        }\n    };\n    loop(state);\n    return res;\n}\nfunction $01e2cc4a8ea727fe$export$23c8d3f8757cab88(array) {\n    const len = array.length | 0;\n    const res1 = new Array(len);\n    const res2 = new Array(len);\n    $01e2cc4a8ea727fe$export$5a067165821eae2d((i, tupledArg)=>{\n        res1[i] = tupledArg[0];\n        res2[i] = tupledArg[1];\n    }, array);\n    return [\n        res1,\n        res2\n    ];\n}\nfunction $01e2cc4a8ea727fe$export$a52790ad56d35e3d(array) {\n    const len = array.length | 0;\n    const res1 = new Array(len);\n    const res2 = new Array(len);\n    const res3 = new Array(len);\n    $01e2cc4a8ea727fe$export$5a067165821eae2d((i, tupledArg)=>{\n        res1[i] = tupledArg[0];\n        res2[i] = tupledArg[1];\n        res3[i] = tupledArg[2];\n    }, array);\n    return [\n        res1,\n        res2,\n        res3\n    ];\n}\nfunction $01e2cc4a8ea727fe$export$8901015135f2fb22(array1, array2) {\n    if (array1.length !== array2.length) $01e2cc4a8ea727fe$var$differentLengths();\n    const result = new Array(array1.length);\n    for(let i = 0; i <= array1.length - 1; i++)result[i] = [\n        array1[i],\n        array2[i]\n    ];\n    return result;\n}\nfunction $01e2cc4a8ea727fe$export$a3c629e5d025ffc1(array1, array2, array3) {\n    if (array1.length !== array2.length ? true : array2.length !== array3.length) $01e2cc4a8ea727fe$var$differentLengths();\n    const result = new Array(array1.length);\n    for(let i = 0; i <= array1.length - 1; i++)result[i] = [\n        array1[i],\n        array2[i],\n        array3[i]\n    ];\n    return result;\n}\nfunction $01e2cc4a8ea727fe$export$6302d00ba2848bf(chunkSize, array) {\n    if (chunkSize < 1) throw new Error(\"The input must be positive.\\\\nParameter name: size\");\n    if (array.length === 0) return [\n        []\n    ];\n    else {\n        const result = [];\n        for(let x = 0; x <= ~~Math.ceil(array.length / chunkSize) - 1; x++){\n            let slice;\n            const start_1 = x * chunkSize | 0;\n            slice = array.slice(start_1, start_1 + chunkSize);\n            result.push(slice);\n        }\n        return result;\n    }\n}\nfunction $01e2cc4a8ea727fe$export$b0d75975ac0be0e1(index, array) {\n    if (index < 0 ? true : index > array.length) throw new Error((0, $3872cbf98ba8550b$export$1d7558b55257001d) + \"\\\\nParameter name: \" + \"index\");\n    return [\n        array.slice(0, 0 + index),\n        array.slice(index)\n    ];\n}\nfunction $01e2cc4a8ea727fe$export$ecb3797c03e8ce0c(comparer, source1, source2) {\n    if (source1 == null) {\n        if (source2 == null) return 0;\n        else return -1;\n    } else if (source2 == null) return 1;\n    else {\n        const len1 = source1.length | 0;\n        const len2 = source2.length | 0;\n        const len = (len1 < len2 ? len1 : len2) | 0;\n        let i = 0;\n        let res = 0;\n        while(res === 0 && i < len){\n            res = comparer(source1[i], source2[i]) | 0;\n            i = i + 1 | 0;\n        }\n        if (res !== 0) return res | 0;\n        else if (len1 > len2) return 1;\n        else if (len1 < len2) return -1;\n        else return 0;\n    }\n}\nfunction $01e2cc4a8ea727fe$export$53576907a5c40ba3(comparer, source1, source2) {\n    if (source1 == null) {\n        if (source2 == null) return 0;\n        else return -1;\n    } else if (source2 == null) return 1;\n    else {\n        const len1 = source1.length | 0;\n        const len2 = source2.length | 0;\n        if (len1 > len2) return 1;\n        else if (len1 < len2) return -1;\n        else {\n            let i = 0;\n            let res = 0;\n            while(res === 0 && i < len1){\n                res = comparer(source1[i], source2[i]) | 0;\n                i = i + 1 | 0;\n            }\n            return res | 0;\n        }\n    }\n}\nfunction $01e2cc4a8ea727fe$export$9d4fa3538bf09487(equals, array1, array2) {\n    if (array1 == null) {\n        if (array2 == null) return true;\n        else return false;\n    } else if (array2 == null) return false;\n    else {\n        let i = 0;\n        let result = true;\n        const length1 = array1.length | 0;\n        const length2 = array2.length | 0;\n        if (length1 > length2) return false;\n        else if (length1 < length2) return false;\n        else {\n            while(i < length1 && result){\n                result = equals(array1[i], array2[i]);\n                i = i + 1 | 0;\n            }\n            return result;\n        }\n    }\n}\nfunction $01e2cc4a8ea727fe$export$3367fc0da2c111f0(array) {\n    switch(array.length){\n        case 1:\n            return array[0];\n        case 0:\n            throw new Error(\"The input sequence was empty\\\\nParameter name: array\");\n        default:\n            throw new Error(\"Input array too long\\\\nParameter name: array\");\n    }\n}\nfunction $01e2cc4a8ea727fe$export$22f0cfb94dab14ba(array) {\n    if (array.length === 1) return (0, $46485786458244dd$export$ad14ef4001db2bcd)(array[0]);\n    else return void 0;\n}\nfunction $01e2cc4a8ea727fe$export$5fd5031fecdacec3(array) {\n    if (array.length === 0) throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    else return array[0];\n}\nfunction $01e2cc4a8ea727fe$export$1acbe849d0cb723e(array) {\n    if (array.length === 0) return void 0;\n    else return (0, $46485786458244dd$export$ad14ef4001db2bcd)(array[0]);\n}\nfunction $01e2cc4a8ea727fe$export$c01875f616615628(array) {\n    if (array.length === 0) throw new Error(\"Not enough elements\\\\nParameter name: array\");\n    return array.slice(1);\n}\nfunction $01e2cc4a8ea727fe$export$7061c75fc5af8b7e(index, array) {\n    return array[index];\n}\nfunction $01e2cc4a8ea727fe$export$3fe40c3a4d8cb094(index, array) {\n    if (index < 0 ? true : index >= array.length) return void 0;\n    else return (0, $46485786458244dd$export$ad14ef4001db2bcd)(array[index]);\n}\nfunction $01e2cc4a8ea727fe$export$550943be80b2169b(folder, array, state) {\n    return array.reduceRight((delegateArg, delegateArg_1, delegateArg_2)=>folder(delegateArg_2, delegateArg_1, delegateArg), state);\n}\nfunction $01e2cc4a8ea727fe$export$c38b8353041a4f48(folder, array, state) {\n    return array.reduceRight((delegateArg, delegateArg_1)=>folder(delegateArg_1, delegateArg), state);\n}\nfunction $01e2cc4a8ea727fe$export$665dec9c39c3adad(folder, state, array1, array2) {\n    let acc = state;\n    if (array1.length !== array2.length) throw new Error(\"Arrays have different lengths\");\n    for(let i = 0; i <= array1.length - 1; i++)acc = folder(i, acc, array1[i], array2[i]);\n    return acc;\n}\nfunction $01e2cc4a8ea727fe$export$6eef545db8c1f6e(folder, state, array1, array2) {\n    return $01e2cc4a8ea727fe$export$665dec9c39c3adad((_arg, acc, x, y)=>folder(acc, x, y), state, array1, array2);\n}\nfunction $01e2cc4a8ea727fe$export$eb873be546c6a428(folder, array1, array2, state) {\n    let acc = state;\n    if (array1.length !== array2.length) $01e2cc4a8ea727fe$var$differentLengths();\n    const size = array1.length | 0;\n    for(let i = 1; i <= size; i++)acc = folder(i - 1, array1[size - i], array2[size - i], acc);\n    return acc;\n}\nfunction $01e2cc4a8ea727fe$export$f04d6919de1a1f94(f, array1, array2, state) {\n    return $01e2cc4a8ea727fe$export$eb873be546c6a428((_arg, x, y, acc)=>f(x, y, acc), array1, array2, state);\n}\nfunction $01e2cc4a8ea727fe$export$533b26079ad0b4b(reduction, array) {\n    if (array.length === 0) throw new Error(\"The input array was empty\");\n    const reduction_1 = reduction;\n    return array.reduce(reduction_1);\n}\nfunction $01e2cc4a8ea727fe$export$90cf02207d4ef99b(reduction, array) {\n    if (array.length === 0) throw new Error(\"The input array was empty\");\n    const reduction_1 = reduction;\n    return array.reduceRight(reduction_1);\n}\nfunction $01e2cc4a8ea727fe$export$a85e1ff32f9fff6e(predicate, array1, array2) {\n    return $01e2cc4a8ea727fe$export$6eef545db8c1f6e((acc, x, y)=>acc && predicate(x, y), true, array1, array2);\n}\nfunction $01e2cc4a8ea727fe$export$f9300ec6f6f05293(predicate_mut, array_mut, index_mut) {\n    existsOffset: while(true){\n        const predicate = predicate_mut, array = array_mut, index = index_mut;\n        if (index === array.length) return false;\n        else if (predicate(array[index])) return true;\n        else {\n            predicate_mut = predicate;\n            array_mut = array;\n            index_mut = index + 1;\n            continue existsOffset;\n        }\n        break;\n    }\n}\nfunction $01e2cc4a8ea727fe$export$f7e9f41ea797a17(predicate, array) {\n    return $01e2cc4a8ea727fe$export$f9300ec6f6f05293(predicate, array, 0);\n}\nfunction $01e2cc4a8ea727fe$export$5c0f099be5c4dc6a(predicate_mut, array1_mut, array2_mut, index_mut) {\n    existsOffset2: while(true){\n        const predicate = predicate_mut, array1 = array1_mut, array2 = array2_mut, index = index_mut;\n        if (index === array1.length) return false;\n        else if (predicate(array1[index], array2[index])) return true;\n        else {\n            predicate_mut = predicate;\n            array1_mut = array1;\n            array2_mut = array2;\n            index_mut = index + 1;\n            continue existsOffset2;\n        }\n        break;\n    }\n}\nfunction $01e2cc4a8ea727fe$export$d04ae74aaa2c0655(predicate, array1, array2) {\n    if (array1.length !== array2.length) $01e2cc4a8ea727fe$var$differentLengths();\n    return $01e2cc4a8ea727fe$export$5c0f099be5c4dc6a(predicate, array1, array2, 0);\n}\nfunction $01e2cc4a8ea727fe$export$8a63f25cc62965f1(array, adder) {\n    let acc = adder.GetZero();\n    for(let i = 0; i <= array.length - 1; i++)acc = adder.Add(acc, array[i]);\n    return acc;\n}\nfunction $01e2cc4a8ea727fe$export$9e8299ab977385a3(projection, array, adder) {\n    let acc = adder.GetZero();\n    for(let i = 0; i <= array.length - 1; i++)acc = adder.Add(acc, projection(array[i]));\n    return acc;\n}\nfunction $01e2cc4a8ea727fe$export$ad1963a493908da4(projection, xs, comparer) {\n    return $01e2cc4a8ea727fe$export$533b26079ad0b4b((x, y)=>comparer.Compare(projection(y), projection(x)) > 0 ? y : x, xs);\n}\nfunction $01e2cc4a8ea727fe$export$8960430cfd85939f(xs, comparer) {\n    return $01e2cc4a8ea727fe$export$533b26079ad0b4b((x, y)=>comparer.Compare(y, x) > 0 ? y : x, xs);\n}\nfunction $01e2cc4a8ea727fe$export$8c826aa0fa59ac68(projection, xs, comparer) {\n    return $01e2cc4a8ea727fe$export$533b26079ad0b4b((x, y)=>comparer.Compare(projection(y), projection(x)) > 0 ? x : y, xs);\n}\nfunction $01e2cc4a8ea727fe$export$96ec731ed4dcb222(xs, comparer) {\n    return $01e2cc4a8ea727fe$export$533b26079ad0b4b((x, y)=>comparer.Compare(y, x) > 0 ? x : y, xs);\n}\nfunction $01e2cc4a8ea727fe$export$cc6710ee5f037d57(array, averager) {\n    if (array.length === 0) throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    let total = averager.GetZero();\n    for(let i = 0; i <= array.length - 1; i++)total = averager.Add(total, array[i]);\n    return averager.DivideByInt(total, array.length);\n}\nfunction $01e2cc4a8ea727fe$export$9077387bc3582185(projection, array, averager) {\n    if (array.length === 0) throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    let total = averager.GetZero();\n    for(let i = 0; i <= array.length - 1; i++)total = averager.Add(total, projection(array[i]));\n    return averager.DivideByInt(total, array.length);\n}\nfunction $01e2cc4a8ea727fe$export$5f2b86065ccf5a1(windowSize, source) {\n    if (windowSize <= 0) throw new Error(\"windowSize must be positive\");\n    let res;\n    const len = (0, $4840af1467e42596$export$8960430cfd85939f)(0, source.length - windowSize + 1) | 0;\n    res = new Array(len);\n    for(let i = windowSize; i <= source.length; i++)res[i - windowSize] = source.slice(i - windowSize, i - 1 + 1);\n    return res;\n}\nfunction $01e2cc4a8ea727fe$export$7120a88bf3d39e8(chunks, array) {\n    if (chunks < 1) throw new Error(\"The input must be positive.\\\\nParameter name: chunks\");\n    if (array.length === 0) return [\n        []\n    ];\n    else {\n        const result = [];\n        const chunks_1 = (0, $4840af1467e42596$export$96ec731ed4dcb222)(chunks, array.length) | 0;\n        const minChunkSize = ~~(array.length / chunks_1) | 0;\n        const chunksWithExtraItem = array.length % chunks_1 | 0;\n        for(let i = 0; i <= chunks_1 - 1; i++){\n            const chunkSize = (i < chunksWithExtraItem ? minChunkSize + 1 : minChunkSize) | 0;\n            let slice;\n            const start_1 = i * minChunkSize + (0, $4840af1467e42596$export$96ec731ed4dcb222)(chunksWithExtraItem, i) | 0;\n            slice = array.slice(start_1, start_1 + chunkSize);\n            result.push(slice);\n        }\n        return result;\n    }\n}\nfunction $01e2cc4a8ea727fe$export$9cb09a71b7d66923(arrays, cons) {\n    const arrays_1 = Array.isArray(arrays) ? arrays : Array.from(arrays);\n    const len = arrays_1.length | 0;\n    if (len === 0) return new Array(0);\n    else {\n        const firstArray = arrays_1[0];\n        const lenInner = firstArray.length | 0;\n        if (!$01e2cc4a8ea727fe$export$e5bd981f5eeebe3b((a)=>a.length === lenInner, arrays_1)) $01e2cc4a8ea727fe$var$differentLengths();\n        const result = new Array(lenInner);\n        for(let i = 0; i <= lenInner - 1; i++){\n            result[i] = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, len);\n            for(let j = 0; j <= len - 1; j++)result[i][j] = arrays_1[j][i];\n        }\n        return result;\n    }\n}\nfunction $01e2cc4a8ea727fe$export$9f200c4466975173(index, y, xs, cons) {\n    const len = xs.length | 0;\n    if (index < 0 ? true : index > len) throw new Error((0, $3872cbf98ba8550b$export$1d7558b55257001d) + \"\\\\nParameter name: \" + \"index\");\n    const target = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, len + 1);\n    for(let i = 0; i <= index - 1; i++)target[i] = xs[i];\n    target[index] = y;\n    for(let i_1 = index; i_1 <= len - 1; i_1++)target[i_1 + 1] = xs[i_1];\n    return target;\n}\nfunction $01e2cc4a8ea727fe$export$97e8c8737f8994b9(index, ys, xs, cons) {\n    const len = xs.length | 0;\n    if (index < 0 ? true : index > len) throw new Error((0, $3872cbf98ba8550b$export$1d7558b55257001d) + \"\\\\nParameter name: \" + \"index\");\n    const ys_1 = Array.from(ys);\n    const len2 = ys_1.length | 0;\n    const target = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, len + len2);\n    for(let i = 0; i <= index - 1; i++)target[i] = xs[i];\n    for(let i_1 = 0; i_1 <= len2 - 1; i_1++)target[index + i_1] = ys_1[i_1];\n    for(let i_2 = index; i_2 <= len - 1; i_2++)target[i_2 + len2] = xs[i_2];\n    return target;\n}\nfunction $01e2cc4a8ea727fe$export$aa72b1a59562dee2(index, xs) {\n    if (index < 0 ? true : index >= xs.length) throw new Error((0, $3872cbf98ba8550b$export$1d7558b55257001d) + \"\\\\nParameter name: \" + \"index\");\n    let i = -1;\n    return $01e2cc4a8ea727fe$export$3dea766d36a8935f((_arg)=>{\n        i = i + 1 | 0;\n        return i !== index;\n    }, xs);\n}\nfunction $01e2cc4a8ea727fe$export$a1b32c1cdbbe428e(index, count, xs) {\n    let i = -1;\n    let status = -1;\n    const ys = $01e2cc4a8ea727fe$export$3dea766d36a8935f((_arg)=>{\n        i = i + 1 | 0;\n        if (i === index) {\n            status = 0;\n            return false;\n        } else if (i > index) {\n            if (i < index + count) return false;\n            else {\n                status = 1;\n                return true;\n            }\n        } else return true;\n    }, xs);\n    const status_1 = (status === 0 && i + 1 === index + count ? 1 : status) | 0;\n    if (status_1 < 1) throw new Error((0, $3872cbf98ba8550b$export$1d7558b55257001d) + \"\\\\nParameter name: \" + (status_1 < 0 ? \"index\" : \"count\"));\n    return ys;\n}\nfunction $01e2cc4a8ea727fe$export$b6d8713d53419d4c(index, y, xs, cons) {\n    const len = xs.length | 0;\n    if (index < 0 ? true : index >= len) throw new Error((0, $3872cbf98ba8550b$export$1d7558b55257001d) + \"\\\\nParameter name: \" + \"index\");\n    const target = (0, $156d701283f9fc89$export$882a7a2eca8e1502)(cons, len);\n    for(let i = 0; i <= len - 1; i++)target[i] = i === index ? y : xs[i];\n    return target;\n}\n\n\nconst $766310993b931f49$export$b610b8812bbcded9 = (tableau, row, col)=>tableau.matrix[Math.imul(row, tableau.width) + col];\nconst $766310993b931f49$export$722fbec263ad908a = (tableau, row, col, value)=>{\n    tableau.matrix[Math.imul(row, tableau.width) + col] = value;\n};\nconst $766310993b931f49$var$convertToIterable = (seq)=>typeof seq[Symbol.iterator] === \"function\" // eslint-disable-line\n     ? seq : Object.entries(seq);\n// prettier-ignore\nconst $766310993b931f49$var$convertToSet = (set)=>set === true ? true : set === false ? new Set() : set instanceof Set ? set : new Set(set);\nconst $766310993b931f49$export$5775ac136be60802 = (model)=>{\n    const { direction: direction, objective: objective, integers: integers, binaries: binaries } = model;\n    const sign = direction === \"minimize\" ? -1 : 1.0;\n    const constraintsIter = $766310993b931f49$var$convertToIterable(model.constraints);\n    const variablesIter = $766310993b931f49$var$convertToIterable(model.variables);\n    const variables = Array.isArray(variablesIter) ? variablesIter : Array.from(variablesIter);\n    const binaryConstraintCol = [];\n    const ints = [];\n    if (integers != null || binaries != null) {\n        const binaryVariables = $766310993b931f49$var$convertToSet(binaries);\n        const integerVariables = binaryVariables === true ? true : $766310993b931f49$var$convertToSet(integers);\n        for(let i = 1; i <= variables.length; i++){\n            const [key] = variables[i - 1];\n            if (binaryVariables === true || binaryVariables.has(key)) {\n                binaryConstraintCol.push(i);\n                ints.push(i);\n            } else if (integerVariables === true || integerVariables.has(key)) ints.push(i);\n        }\n    }\n    const constraints = new Map();\n    for (const [key, constraint] of constraintsIter){\n        const bounds = constraints.get(key) ?? {\n            row: NaN,\n            lower: -Infinity,\n            upper: Infinity\n        };\n        bounds.lower = Math.max(bounds.lower, constraint.equal ?? constraint.min ?? -Infinity);\n        bounds.upper = Math.min(bounds.upper, constraint.equal ?? constraint.max ?? Infinity);\n        // if (rows.lower > rows.upper) return [\"infeasible\", NaN]\n        if (!constraints.has(key)) constraints.set(key, bounds);\n    }\n    let numConstraints = 1;\n    for (const constraint of constraints.values()){\n        constraint.row = numConstraints;\n        numConstraints += (Number.isFinite(constraint.lower) ? 1 : 0) + (Number.isFinite(constraint.upper) ? 1 : 0);\n    }\n    const width = variables.length + 1;\n    const height = numConstraints + binaryConstraintCol.length;\n    const numVars = width + height;\n    const matrix = new Float64Array(width * height);\n    const positionOfVariable = new Int32Array(numVars);\n    const variableAtPosition = new Int32Array(numVars);\n    const tableau = {\n        matrix: matrix,\n        width: width,\n        height: height,\n        positionOfVariable: positionOfVariable,\n        variableAtPosition: variableAtPosition\n    };\n    for(let i = 0; i < numVars; i++){\n        positionOfVariable[i] = i;\n        variableAtPosition[i] = i;\n    }\n    for(let c = 1; c < width; c++)for (const [constraint, coef] of $766310993b931f49$var$convertToIterable(variables[c - 1][1])){\n        if (constraint === objective) $766310993b931f49$export$722fbec263ad908a(tableau, 0, c, sign * coef);\n        const bounds = constraints.get(constraint);\n        if (bounds != null) {\n            if (Number.isFinite(bounds.upper)) {\n                $766310993b931f49$export$722fbec263ad908a(tableau, bounds.row, c, coef);\n                if (Number.isFinite(bounds.lower)) $766310993b931f49$export$722fbec263ad908a(tableau, bounds.row + 1, c, -coef);\n            } else if (Number.isFinite(bounds.lower)) $766310993b931f49$export$722fbec263ad908a(tableau, bounds.row, c, -coef);\n        }\n    }\n    for (const bounds of constraints.values()){\n        if (Number.isFinite(bounds.upper)) {\n            $766310993b931f49$export$722fbec263ad908a(tableau, bounds.row, 0, bounds.upper);\n            if (Number.isFinite(bounds.lower)) $766310993b931f49$export$722fbec263ad908a(tableau, bounds.row + 1, 0, -bounds.lower);\n        } else if (Number.isFinite(bounds.lower)) $766310993b931f49$export$722fbec263ad908a(tableau, bounds.row, 0, -bounds.lower);\n    }\n    for(let b = 0; b < binaryConstraintCol.length; b++){\n        const row = numConstraints + b;\n        $766310993b931f49$export$722fbec263ad908a(tableau, row, 0, 1.0);\n        $766310993b931f49$export$722fbec263ad908a(tableau, row, binaryConstraintCol[b], 1.0);\n    }\n    return {\n        tableau: tableau,\n        sign: sign,\n        variables: variables,\n        integers: ints\n    };\n};\n\n\nconst $1b2ad3cb69a79105$export$b485511e5cd71305 = (num, precision)=>{\n    const rounding = Math.round(1.0 / precision);\n    return Math.round((num + Number.EPSILON) * rounding) / rounding;\n};\n\n\n\n\nconst $8135c8e95bc184a9$var$pivot = (tableau, row, col)=>{\n    const quotient = (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, row, col);\n    const leaving = tableau.variableAtPosition[tableau.width + row];\n    const entering = tableau.variableAtPosition[col];\n    tableau.variableAtPosition[tableau.width + row] = entering;\n    tableau.variableAtPosition[col] = leaving;\n    tableau.positionOfVariable[leaving] = col;\n    tableau.positionOfVariable[entering] = tableau.width + row;\n    const nonZeroColumns = [];\n    // (1 / quotient) * R_pivot -> R_pivot\n    for(let c = 0; c < tableau.width; c++){\n        const value = (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, row, c);\n        if (Math.abs(value) > 1e-16) {\n            (0, $766310993b931f49$export$722fbec263ad908a)(tableau, row, c, value / quotient);\n            nonZeroColumns.push(c);\n        } else (0, $766310993b931f49$export$722fbec263ad908a)(tableau, row, c, 0.0);\n    }\n    (0, $766310993b931f49$export$722fbec263ad908a)(tableau, row, col, 1.0 / quotient);\n    // -M[r, col] * R_pivot + R_r -> R_r\n    for(let r = 0; r < tableau.height; r++){\n        if (r === row) continue;\n        const coef = (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, r, col);\n        if (Math.abs(coef) > 1e-16) {\n            for(let i = 0; i < nonZeroColumns.length; i++){\n                const c = nonZeroColumns[i];\n                (0, $766310993b931f49$export$722fbec263ad908a)(tableau, r, c, (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, r, c) - coef * (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, row, c));\n            }\n            (0, $766310993b931f49$export$722fbec263ad908a)(tableau, r, col, -coef / quotient);\n        }\n    }\n};\n// Checks if the simplex method has encountered a cycle.\nconst $8135c8e95bc184a9$var$hasCycle = (history, tableau, row, col)=>{\n    // This whole function seems somewhat inefficient,\n    // but there was no? noticable impact in the benchmarks.\n    history.push([\n        tableau.variableAtPosition[tableau.width + row],\n        tableau.variableAtPosition[col]\n    ]);\n    // the minimum length of a cycle is 6\n    for(let length = 6; length <= Math.trunc(history.length / 2); length++){\n        let cycle = true;\n        for(let i = 0; i < length; i++){\n            const item = history.length - 1 - i;\n            const [row1, col1] = history[item];\n            const [row2, col2] = history[item - length];\n            if (row1 !== row2 || col1 !== col2) {\n                cycle = false;\n                break;\n            }\n        }\n        if (cycle) return true;\n    }\n    return false;\n};\n// Finds the optimal solution given some basic feasible solution.\nconst $8135c8e95bc184a9$var$phase2 = (tableau, options)=>{\n    const pivotHistory = [];\n    const { precision: precision, maxPivots: maxPivots, checkCycles: checkCycles } = options;\n    for(let iter = 0; iter < maxPivots; iter++){\n        // Find the entering column/variable\n        let col = 0;\n        let value = precision;\n        for(let c = 1; c < tableau.width; c++){\n            const reducedCost = (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, 0, c);\n            if (reducedCost > value) {\n                value = reducedCost;\n                col = c;\n            }\n        }\n        if (col === 0) return [\n            \"optimal\",\n            (0, $1b2ad3cb69a79105$export$b485511e5cd71305)((0, $766310993b931f49$export$b610b8812bbcded9)(tableau, 0, 0), precision)\n        ];\n        // Find the leaving row/variable\n        let row = 0;\n        let minRatio = Infinity;\n        for(let r = 1; r < tableau.height; r++){\n            const value = (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, r, col);\n            if (value <= precision) continue; // pivot entry must be positive\n            const rhs = (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, r, 0);\n            const ratio = rhs / value;\n            if (ratio < minRatio) {\n                row = r;\n                minRatio = ratio;\n                if (ratio <= precision) break; // ratio is 0, lowest possible\n            }\n        }\n        if (row === 0) return [\n            \"unbounded\",\n            col\n        ];\n        if (checkCycles && $8135c8e95bc184a9$var$hasCycle(pivotHistory, tableau, row, col)) return [\n            \"cycled\",\n            NaN\n        ];\n        $8135c8e95bc184a9$var$pivot(tableau, row, col);\n    }\n    return [\n        \"cycled\",\n        NaN\n    ];\n};\n// Transforms a tableau into a basic feasible solution.\nconst $8135c8e95bc184a9$export$cdff0fdd5b0f2742 = (tableau, options)=>{\n    const pivotHistory = [];\n    const { precision: precision, maxPivots: maxPivots, checkCycles: checkCycles } = options;\n    for(let iter = 0; iter < maxPivots; iter++){\n        // Find the leaving row/variable\n        let row = 0;\n        let rhs = -precision;\n        for(let r = 1; r < tableau.height; r++){\n            const value = (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, r, 0);\n            if (value < rhs) {\n                rhs = value;\n                row = r;\n            }\n        }\n        if (row === 0) return $8135c8e95bc184a9$var$phase2(tableau, options);\n        // Find the entering column/variable\n        let col = 0;\n        let maxRatio = -Infinity;\n        for(let c = 1; c < tableau.width; c++){\n            const coefficient = (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, row, c);\n            if (coefficient < -precision) {\n                const ratio = -(0, $766310993b931f49$export$b610b8812bbcded9)(tableau, 0, c) / coefficient;\n                if (ratio > maxRatio) {\n                    maxRatio = ratio;\n                    col = c;\n                }\n            }\n        }\n        if (col === 0) return [\n            \"infeasible\",\n            NaN\n        ];\n        if (checkCycles && $8135c8e95bc184a9$var$hasCycle(pivotHistory, tableau, row, col)) return [\n            \"cycled\",\n            NaN\n        ];\n        $8135c8e95bc184a9$var$pivot(tableau, row, col);\n    }\n    return [\n        \"cycled\",\n        NaN\n    ];\n};\n\n\n\n\nvar $a480cfd0af27e963$exports = {};\n\n$a480cfd0af27e963$exports = (parcelRequire(\"l9uIb\"));\n\n\nconst $9ffe9ea54178e5e7$var$buffer = (matrixLength, posVarLength)=>({\n        matrix: new Float64Array(matrixLength),\n        positionOfVariable: new Int32Array(posVarLength),\n        variableAtPosition: new Int32Array(posVarLength)\n    });\n// Creates a new tableau with additional cut constraints from a buffer.\nconst $9ffe9ea54178e5e7$var$applyCuts = (tableau, { matrix: matrix, positionOfVariable: positionOfVariable, variableAtPosition: variableAtPosition }, cuts)=>{\n    const { width: width, height: height } = tableau;\n    matrix.set(tableau.matrix);\n    for(let i = 0; i < cuts.length; i++){\n        const [sign, variable, value] = cuts[i];\n        const r = (height + i) * width;\n        const pos = tableau.positionOfVariable[variable];\n        if (pos < width) {\n            matrix[r] = sign * value;\n            matrix.fill(0.0, r + 1, r + width);\n            matrix[r + pos] = sign;\n        } else {\n            const row = (pos - width) * width;\n            matrix[r] = sign * (value - matrix[row]);\n            for(let c = 1; c < width; c++)matrix[r + c] = -sign * matrix[row + c];\n        }\n    }\n    positionOfVariable.set(tableau.positionOfVariable);\n    variableAtPosition.set(tableau.variableAtPosition);\n    const length = width + height + cuts.length;\n    for(let i = width + height; i < length; i++){\n        positionOfVariable[i] = i;\n        variableAtPosition[i] = i;\n    }\n    return {\n        matrix: matrix.subarray(0, tableau.matrix.length + width * cuts.length),\n        width: width,\n        height: height + cuts.length,\n        positionOfVariable: positionOfVariable.subarray(0, length),\n        variableAtPosition: variableAtPosition.subarray(0, length)\n    };\n};\n// Finds the integer variable with the most fractional value.\nconst $9ffe9ea54178e5e7$var$mostFractionalVar = (tableau, intVars)=>{\n    let highestFrac = 0.0;\n    let variable = 0;\n    let value = 0.0;\n    for(let i = 0; i < intVars.length; i++){\n        const intVar = intVars[i];\n        const row = tableau.positionOfVariable[intVar] - tableau.width;\n        if (row < 0) continue;\n        const val = (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, row, 0);\n        const frac = Math.abs(val - Math.round(val));\n        if (frac > highestFrac) {\n            highestFrac = frac;\n            variable = intVar;\n            value = val;\n        }\n    }\n    return [\n        variable,\n        value,\n        highestFrac\n    ];\n};\nconst $9ffe9ea54178e5e7$export$ecbfccb5730dd058 = (tabmod, initResult, options)=>{\n    const { tableau: tableau, sign: sign, integers: integers } = tabmod;\n    const { precision: precision, maxIterations: maxIterations, tolerance: tolerance, timeout: timeout } = options;\n    const [initVariable, initValue, initFrac] = $9ffe9ea54178e5e7$var$mostFractionalVar(tableau, integers);\n    // Wow, the initial solution is integer\n    if (initFrac <= precision) return [\n        tabmod,\n        \"optimal\",\n        initResult\n    ];\n    const branches = new (0, (/*@__PURE__*/$parcel$interopDefault($a480cfd0af27e963$exports)))((x, y)=>x[0] - y[0]);\n    branches.push([\n        initResult,\n        [\n            [\n                -1,\n                initVariable,\n                Math.ceil(initValue)\n            ]\n        ]\n    ]);\n    branches.push([\n        initResult,\n        [\n            [\n                1,\n                initVariable,\n                Math.floor(initValue)\n            ]\n        ]\n    ]);\n    // Set aside arrays/buffers to be reused over the course of the algorithm.\n    // One set of buffers stores the state of the currrent best solution.\n    // The other is used to solve the current candidate solution.\n    // The two buffers are \"swapped\" once a new best solution is found.\n    const maxExtraRows = integers.length * 2;\n    const matrixLength = tableau.matrix.length + maxExtraRows * tableau.width;\n    const posVarLength = tableau.positionOfVariable.length + maxExtraRows;\n    let candidateBuffer = $9ffe9ea54178e5e7$var$buffer(matrixLength, posVarLength);\n    let solutionBuffer = $9ffe9ea54178e5e7$var$buffer(matrixLength, posVarLength);\n    const optimalThreshold = initResult * (1.0 - sign * tolerance);\n    const stopTime = timeout + Date.now();\n    let timedout = Date.now() >= stopTime; // in case options.timeout <= 0\n    let solutionFound = false;\n    let bestEval = Infinity;\n    let bestTableau = tableau;\n    let iter = 0;\n    while(iter < maxIterations && !branches.empty() && bestEval >= optimalThreshold && !timedout){\n        const [relaxedEval, cuts] = branches.pop();\n        if (relaxedEval > bestEval) break; // the remaining branches are worse than the current best solution\n        const currentTableau = $9ffe9ea54178e5e7$var$applyCuts(tableau, candidateBuffer, cuts);\n        const [status, result] = (0, $8135c8e95bc184a9$export$cdff0fdd5b0f2742)(currentTableau, options);\n        // The initial tableau is not unbounded and adding more cuts/constraints cannot make it become unbounded\n        // assert(status !== \"unbounded\")\n        if (status === \"optimal\" && result < bestEval) {\n            const [variable, value, frac] = $9ffe9ea54178e5e7$var$mostFractionalVar(currentTableau, integers);\n            if (frac <= precision) {\n                // The solution is integer\n                solutionFound = true;\n                bestEval = result;\n                bestTableau = currentTableau;\n                const temp = solutionBuffer;\n                solutionBuffer = candidateBuffer;\n                candidateBuffer = temp;\n            } else {\n                const cutsUpper = [];\n                const cutsLower = [];\n                for(let i = 0; i < cuts.length; i++){\n                    const cut = cuts[i];\n                    const [dir, v] = cut;\n                    if (v === variable) dir < 0 ? cutsLower.push(cut) : cutsUpper.push(cut);\n                    else {\n                        cutsUpper.push(cut);\n                        cutsLower.push(cut);\n                    }\n                }\n                cutsLower.push([\n                    1,\n                    variable,\n                    Math.floor(value)\n                ]);\n                cutsUpper.push([\n                    -1,\n                    variable,\n                    Math.ceil(value)\n                ]);\n                branches.push([\n                    result,\n                    cutsUpper\n                ]);\n                branches.push([\n                    result,\n                    cutsLower\n                ]);\n            }\n        }\n        // Otherwise, this branch's result is worse than the current best solution.\n        // This could be because this branch is infeasible or cycled.\n        // Either way, skip this branch and see if any other branches have a valid, better solution.\n        timedout = Date.now() >= stopTime;\n        iter++;\n    }\n    // Did the solver \"timeout\"?\n    const unfinished = (timedout || iter >= maxIterations) && !branches.empty() && bestEval >= optimalThreshold;\n    // prettier-ignore\n    const status = unfinished ? \"timedout\" : !solutionFound ? \"infeasible\" : \"optimal\";\n    return [\n        {\n            ...tabmod,\n            tableau: bestTableau\n        },\n        status,\n        solutionFound ? bestEval : NaN\n    ];\n};\n\n\n// Creates a solution object representing the optimal solution (if any).\nconst $a886f1a34b7cd82c$var$solution = ({ tableau: tableau, sign: sign, variables: vars }, status, result, { precision: precision, includeZeroVariables: includeZeroVariables })=>{\n    if (status === \"optimal\" || status === \"timedout\" && !Number.isNaN(result)) {\n        const variables = [];\n        for(let i = 0; i < vars.length; i++){\n            const [variable] = vars[i];\n            const row = tableau.positionOfVariable[i + 1] - tableau.width;\n            const value = row >= 0 ? (0, $766310993b931f49$export$b610b8812bbcded9)(tableau, row, 0) : 0.0;\n            if (value > precision) variables.push([\n                variable,\n                (0, $1b2ad3cb69a79105$export$b485511e5cd71305)(value, precision)\n            ]);\n            else if (includeZeroVariables) variables.push([\n                variable,\n                0.0\n            ]);\n        }\n        return {\n            status: status,\n            result: -sign * result,\n            variables: variables\n        };\n    } else if (status === \"unbounded\") {\n        const variable = tableau.variableAtPosition[result] - 1;\n        return {\n            status: \"unbounded\",\n            result: sign * Infinity,\n            // prettier-ignore\n            variables: 0 <= variable && variable < vars.length ? [\n                [\n                    vars[variable][0],\n                    Infinity\n                ]\n            ] : []\n        };\n    } else // infeasible | cycled | (timedout and result is NaN)\n    return {\n        status: status,\n        result: NaN,\n        variables: []\n    };\n};\nconst $a886f1a34b7cd82c$var$defaultOptionValues = {\n    precision: 1e-8,\n    checkCycles: false,\n    maxPivots: 8192,\n    tolerance: 0,\n    timeout: Infinity,\n    maxIterations: 32768,\n    includeZeroVariables: false\n};\nconst $a886f1a34b7cd82c$export$ba43bf67f3d48107 = {\n    ...$a886f1a34b7cd82c$var$defaultOptionValues\n};\nconst $a886f1a34b7cd82c$export$2865df1f26e73f8e = (model, options)=>{\n    const tabmod = (0, $766310993b931f49$export$5775ac136be60802)(model);\n    const opt = {\n        ...$a886f1a34b7cd82c$var$defaultOptionValues,\n        ...options\n    };\n    const [status, result] = (0, $8135c8e95bc184a9$export$cdff0fdd5b0f2742)(tabmod.tableau, opt);\n    if (tabmod.integers.length === 0 || status !== \"optimal\") // If a non-integer problem, return the simplex result.\n    // Otherwise, the problem has integer variables, but the initial solution is either:\n    // 1) unbounded | infeasible => all branches will also be unbounded | infeasible\n    // 2) cycled => cannot get an initial solution, return invalid solution\n    return $a886f1a34b7cd82c$var$solution(tabmod, status, result, opt);\n    else {\n        // Integer problem and an optimal non-integer solution was found\n        const [intTabmod, intStatus, intResult] = (0, $9ffe9ea54178e5e7$export$ecbfccb5730dd058)(tabmod, result, opt);\n        return $a886f1a34b7cd82c$var$solution(intTabmod, intStatus, intResult, opt);\n    }\n};\n\n\nonmessage = (message)=>{\n    const matchValue = message.data;\n    if ((0, $0ba2f68448f8716d$export$1e2f57719e155213)(matchValue)) {\n        const data = matchValue;\n        postMessage((0, $01e2cc4a8ea727fe$export$871de8747c9eaa88)((model)=>(0, $a886f1a34b7cd82c$export$2865df1f26e73f8e)(model, void 0), data));\n    }\n};\n\n})();\n//# sourceMappingURL=Worker.ed1c8dc5.js.map\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","import { isArrayLike } from \"./fable_modules/fable-library.4.5.0/Util.js\";\nimport { map } from \"./fable_modules/fable-library.4.5.0/Array.js\";\nimport { solve } from \"yalps\";\n\nonmessage = ((message) => {\n    const matchValue = message.data;\n    if (isArrayLike(matchValue)) {\n        const data = matchValue;\n        postMessage(map((model) => solve(model, void 0), data));\n    }\n});\n\n//# sourceMappingURL=Worker.js.map\n","module internal StardewValleyStonks.WebApp.Worker\n\nopen Fable.Core\nopen YALPS\n\ntype Input = Model<int, string> array\ntype Output = int Solution array\n\nlet [<Global>] private postMessage: Output -> unit = jsNative\n\nlet [<Global>] mutable private onmessage: Browser.Types.MessageEvent -> unit = jsNative\n\nonmessage <- fun message ->\n  match message.data with\n  | :? Input as data ->\n    #if DEBUG\n    console.time \"solve\"\n    #endif\n    let solutions = data |> Array.map Solver.solve\n    #if DEBUG\n    console.timeEnd \"solve\"\n    #endif\n    postMessage solutions\n  | _ -> assert false\n","namespace YALPS\n\nopen Fable.Core\n\n/// Specifies the bounds for the total of a value.\ntype Constraint =\n  /// The total should be equal to this number.\n  /// In the case that `min` or `max` are also defined, this is used instead.\n  abstract equal: float option\n\n  /// The total should be greater paket than or equal to this number.\n  /// Can be specified alongside `max`.\n  abstract min: float option\n\n  /// The total should be less than or equal to this number.\n  /// Can be specified alongside `min`.\n  abstract max: float option\n\n/// Contains functions for creating `Constraint`s.\nmodule Constraint =\n  /// Returns a `Constraint` that specifies something should be less than or equal to `value`.\n  /// Equivalent to `!!{| max = value |}`.\n  let [<Import(\"lessEq\", \"yalps\")>] lessEq (value: float): Constraint = jsNative\n\n  /// Returns a `Constraint` that specifies something should be greater than or equal to `value`.\n  /// Equivalent to `!!{| min = value |}`.\n  let [<Import(\"greaterEq\", \"yalps\")>] greaterEq (value: float): Constraint = jsNative\n\n  /// Returns a `Constraint` that specifies something should be exactly equal to `value`.\n  /// Equivalent to `!!{| equal = value |}`.\n  let [<Import(\"equalTo\", \"yalps\")>] equalTo (value: float): Constraint = jsNative\n\n  /// Returns a `Constraint` that specifies something should be between `lower` and `upper` (inclusive).\n  /// Equivalent to `!!{| min = lower; max = upper |}`.\n  let [<Import(\"inRange\", \"yalps\")>] inRange (lower: float, upper: float): Constraint = jsNative\n\n/// Contains convenience operators for creating `Constraint`s.\nmodule Operators =\n  open Constraint\n\n  /// `constraint <== value` is equivalent to `(constraint, lessEq value)`.\n  let inline (<==) ``constraint`` value = ``constraint``, lessEq value\n\n  /// `constraint >== value` is equivalent to `(constraint, greaterEq value)`.\n  let inline (>==) ``constraint`` value = ``constraint``, greaterEq value\n\n  /// `constraint === value` is equivalent to `(constraint, equalTo value)`.\n  let inline (===) ``constraint`` value = ``constraint``, equalTo value\n\n/// Indicates whether to `Maximize` or `Minimize` the objective.\ntype [<StringEnum>] OptimizationDirection =\n  | Maximize\n  | Minimize\n\n/// The model representing a LP problem.\n/// Note that equality between constraint and variable keys are tested using\n/// JS strict equality (===) and not structural equality.\ntype Model<'VariableKey, 'ConstraintKey> =\n  /// Indicates whether to `Maximize` or `Minimize` the objective.\n  abstract direction: OptimizationDirection\n\n  /// <summary>\n  /// The key of the value to maximize or minimize.\n  /// </summary>\n  /// <example>\n  /// Note that constraints can be placed upon the objective itself. Maximize up to a certain point:\n  /// ```\n  /// {| direction = Maximize\n  ///    objective = \"obj\"\n  ///    constraints = [ \"obj\", lessEq 100 ]\n  ///    variables = [ (* ... *) ] |}\n  /// ```\n  /// </example>\n  abstract objective: 'ConstraintKey\n\n  /// <summary>\n  /// The constraints of the LP problem.\n  /// Duplicate keys are not ignored.\n  /// Rather, the bounds on the constraints are merged to become the most restrictive.\n  /// </summary>\n  /// <seealso cref=\"Constraint\"/>\n  /// <seealso cref=\"Operators\"/>\n  /// <example>\n  /// ```\n  /// let constraints = [\n  ///     \"a\", lessEq 7\n  ///     \"b\", equalTo 22\n  ///     \"c\" &lt;== 5\n  /// ]\n  /// ```\n  /// </example>\n  abstract constraints: ('ConstraintKey * Constraint) seq\n\n  /// <summary>\n  /// The variables of the LP problem.\n  /// The inner `seq` represents the coefficients of the variable for some (sub)set of constraints.\n  /// For these coefficients, the last entry is used in the case of duplicate `'ConstraintKey`s.\n  /// Duplicate `'VariableKey`s, however, are not ignored.\n  /// The order of variables is preserved in the solution,\n  /// but variables that end up with a value of `0` are not included in the solution by default.\n  /// </summary>\n  /// <example>\n  /// ```\n  /// let variables = [\n  ///     \"x\", [ \"a\", 2; \"b\", 11 ]\n  ///     \"y\", [ \"a\", 3; \"c\", 22 ]\n  /// ]\n  /// ```\n  /// </example>\n  abstract variables: ('VariableKey * ('ConstraintKey * float) seq) seq\n\n  /// A `seq` of variable keys that should be treated as integer.\n  /// `integers` can instead be a `bool`, indicating whether all variables are integer or not.\n  abstract integers: U2<bool, 'VariableKey seq>\n\n  /// An `seq` of variable keys that should be treated as binary\n  /// (can only be 0 or 1 in the solution).\n  /// `binaries` can also be a `bool`, indicating whether all variables are binary or not.\n  abstract binaries: U2<bool, 'VariableKey seq>\n\n/// The model representing a LP problem.\n/// Note that equality between constraint and variable keys are tested using\n/// JS strict equality (===) and not structural equality.\ntype Model = Model<string, string>\n\n/// Contains functions to create `Model`s.\nmodule Model =\n  /// Creates a model with no integer or binary variables.\n  let inline create\n    (direction: OptimizationDirection)\n    (objective: 'ConstraintKey)\n    (constraints: ('ConstraintKey * Constraint) seq)\n    (variables: ('VariableKey * #seq<'ConstraintKey * float>) seq)\n    : Model<'VariableKey, 'ConstraintKey>\n    =\n    unbox {|\n      direction = direction\n      objective = objective\n      constraints = constraints\n      variables = variables\n    |}\n\n  /// Creates model with all variables indicated as integer.\n  let inline createAllInteger\n    (direction: OptimizationDirection)\n    (objective: 'ConstraintKey)\n    (constraints: ('ConstraintKey * Constraint) seq)\n    (variables: ('VariableKey * #seq<'ConstraintKey * float>) seq)\n    : Model<'VariableKey, 'ConstraintKey>\n    =\n    unbox {|\n      direction = direction\n      objective = objective\n      constraints = constraints\n      variables = variables\n      integers = true\n    |}\n\n  /// Creates a model with all variables indicated as binary.\n  let inline createAllBinary\n    (direction: OptimizationDirection)\n    (objective: 'ConstraintKey)\n    (constraints: ('ConstraintKey * Constraint) seq)\n    (variables: ('VariableKey * #seq<'ConstraintKey * float>) seq)\n    : Model<'VariableKey, 'ConstraintKey>\n    =\n    unbox {|\n      direction = direction\n      objective = objective\n      constraints = constraints\n      variables = variables\n      binaries = true\n    |}\n\n  /// Creates a model, marking the provided `integers` and `binaries` variables as integer and binary respectively.\n  let inline createInteger\n    (direction: OptimizationDirection)\n    (objective: 'ConstraintKey)\n    (constraints: ('ConstraintKey * Constraint) seq)\n    (variables: ('VariableKey * #seq<'ConstraintKey * float>) seq)\n    (integers: 'VariableKey seq)\n    (binaries: 'VariableKey seq)\n    : Model<'VariableKey, 'ConstraintKey>\n    =\n    unbox {|\n      direction = direction\n      objective = objective\n      constraints = constraints\n      variables = variables\n      integers = integers\n      binaries = binaries\n    |}\n\n/// <summary>This indicates what type of solution, if any, the solver was able to find.</summary>\n/// <seealso cref=\"Solution\"/>\ntype [<StringEnum>] SolutionStatus =\n  | Optimal\n  | Infeasible\n  | Unbounded\n  | Timedout\n  | Cycled\n\n/// The solution returned by the solver.\ntype Solution<'VariableKey> =\n  /// `status` indicates what type of solution, if any, the solver was able to find.\n  ///\n  /// `Optimal` indicates everything went ok, and the solver found an optimal solution.\n  ///\n  /// `Infeasible` indicates that the problem has no possible solutions.\n  /// `result` will be `NaN` in this case.\n  ///\n  /// `Unbounded` indicates a variable, or combination of variables, are not sufficiently constrained.\n  /// As such, the `result` of the solution will be +-infinity.\n  /// `variables` in the solution might contain a variable,\n  /// in which case it is the unbounded variable that the solver happened to finish on.\n  ///\n  /// `Timedout` indicates that the solver exited early for an integer problem.\n  /// This may happen if the solver takes too long and exceeds the `timeout` option.\n  /// Similarly, the number of branch and cut iterations may exceed `maxIterations` as set in the options.\n  /// In both of these cases, the current sub-optimal solution, if any, is returned.\n  /// If `result` is `NaN`, then this means no integer solutions were found before the solver timed out.\n  ///\n  /// `Cycled` indicates that the simplex method cycled and exited.\n  /// This case is rare, but `checkCycles` can be set to `true` in the options to check for cycles and stop early if one is found.\n  /// Otherwise, if `maxPivots` (as set in the options) is reached by the simplex method,\n  /// then it is assumed that a cycle was encountered.\n  /// `result` will be `NaN` in this case.\n  abstract status: SolutionStatus\n\n  /// The final, maximized or minimized value of the objective.\n  /// It may be `NaN` in the case that `status` is `Infeasible`, `Cycled`, or `Timedout`.\n  /// It may also be +-infinity in the case that `status` is `Unbounded`.\n  abstract result: float\n\n  /// An array of variables and their coefficients that add up to `result` while satisfying the constraints of the problem.\n  /// Variables with a coefficient of `0` are not included in this.\n  /// In the case that `status` is `Unbounded`, `variables` may consist of one variable which is (one of) the unbounded variable(s).\n  abstract variables: ('VariableKey * float) array\n\n/// The solution returned by the solver.\ntype Solution = Solution<string>\n\n// Options is declared as a record to allow record-update syntax.\n\n/// The options for the solver.\ntype Options = {\n  /// Numbers with magnitude equal to or less than the provided precision are treated as zero.\n  /// Similarly, the precision determines whether a number is sufficiently integer.\n  /// The default value is `1E-8`.\n  precision: float\n\n  /// In rare cases, the solver can cycle.\n  /// This is assumed to be the case when the number of pivots exceeds `maxPivots`.\n  /// Setting this to `true` will cause the solver to explicitly check for cycles and stop early if one is found.\n  /// Note that checking for cycles may incur a small performance overhead.\n  /// The default value is `false`.\n  checkCycles: bool\n\n  /// This determines the maximum number of pivots allowed within the simplex method.\n  /// If this is exceeded, then it assumed that the simplex method cycled,\n  /// and the returned solution will have the `Cycled` status.\n  /// If your problem is very large, you may have to set this option higher.\n  /// The default value is `8192`.\n  maxPivots: int\n\n  /// This setting applies to integer problems only.\n  /// If an integer solution is found within\n  /// `(1 +- tolerance) * {the problem's non-integer solution}`,\n  /// then this approximate integer solution is returned.\n  /// For example, a tolereance of `0.05` allows integer solutions found within 5% of the non-integer solution to be returned.\n  /// This is helpful for large integer problems where the most optimal solution becomes harder to find,\n  /// but other solutions that are relatively close to the optimal one may be much easier to find.\n  /// The default value is `0.0` (only find the most optimal solution).\n  tolerance: float\n\n  /// This setting applies to integer problems only.\n  /// It specifies, in milliseconds, the maximum amount of time\n  /// the main branch and cut portion of the solver may take before timing out.\n  /// If a time out occurs, the returned solution will have the `Timedout` status.\n  /// Also, if any sub-optimal solution was found before the time out, then it is returned as well.\n  /// The default value is infinity (no timeout).\n  timeout: float\n\n  /// This setting applies to integer problems only.\n  /// It determines the maximum number of iterations for the main branch and cut algorithm.\n  /// It can be used alongside or instead of `timeout` to prevent the algorithm from taking too long.\n  /// The default value is `32768`.\n  maxIterations: int\n\n  /// Controls whether variables that end up having a value of `0`\n  /// should be included in `variables` in the resulting `Solution`.\n  /// The default value is `false`.\n  includeZeroVariables: bool\n}\n\n/// Contains the main solve function(s) and the default options.\nmodule Solver =\n  /// <summary>\n  /// The default options used by the solver.\n  /// You can use record-update syntax to easily change one or more of the options.\n  /// </summary>\n  /// <example>\n  /// ```\n  /// solveWith { defaultOptions with timeout = 100.0 }\n  /// ```\n  /// </example>\n  let [<Import(\"defaultOptions\", \"yalps\")>] defaultOptions: Options = jsNative\n\n  let [<Import(\"solve\", \"yalps\")>] inline private importedSolve (model: Model<'VarKey, 'ConKey>, options: Options option): Solution<'VarKey> = jsNative\n\n  /// <summary>Runs the solver on the given model using the default options.</summary>\n  /// <seealso cref=\"Model\"/>\n  /// <seealso cref=\"solveWith\"/>\n  /// <seealso cref=\"Solution\"/>\n  let inline solve model = importedSolve (model, None)\n\n  /// <summary>Runs the solver on the given model and using the given options.</summary>\n  /// <example>\n  /// ```\n  /// model |> solveWith { defaultOptions with timeout = 100.0 }\n  /// ```\n  /// </example>\n  /// <seealso cref=\"Model\"/>\n  /// <seealso cref=\"Options\"/>\n  /// <seealso cref=\"Solution\"/>\n  let inline solveWith options model = importedSolve (model, Some options)\n","// tslint:disable:ban-types\nexport function isArrayLike(x) {\n    return Array.isArray(x) || ArrayBuffer.isView(x);\n}\nexport function isIterable(x) {\n    return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nexport function isEnumerable(x) {\n    return x != null && typeof x.GetEnumerator === \"function\";\n}\nexport function isComparer(x) {\n    return x != null && typeof x.Compare === \"function\";\n}\nexport function isComparable(x) {\n    return x != null && typeof x.CompareTo === \"function\";\n}\nexport function isEquatable(x) {\n    return x != null && typeof x.Equals === \"function\";\n}\nexport function isHashable(x) {\n    return x != null && typeof x.GetHashCode === \"function\";\n}\nexport function isDisposable(x) {\n    return x != null && typeof x.Dispose === \"function\";\n}\nexport function disposeSafe(x) {\n    if (isDisposable(x)) {\n        x.Dispose();\n    }\n}\nexport function defaultOf() {\n    return null;\n}\nexport function sameConstructor(x, y) {\n    return Object.getPrototypeOf(x)?.constructor === Object.getPrototypeOf(y)?.constructor;\n}\nexport class Enumerable {\n    constructor(en) {\n        this.en = en;\n    }\n    GetEnumerator() { return this.en; }\n    \"System.Collections.IEnumerable.GetEnumerator\"() { return this.en; }\n    [Symbol.iterator]() {\n        return this;\n    }\n    next() {\n        const hasNext = this.en[\"System.Collections.IEnumerator.MoveNext\"]();\n        const current = hasNext ? this.en[\"System.Collections.Generic.IEnumerator`1.get_Current\"]() : undefined;\n        return { done: !hasNext, value: current };\n    }\n}\nexport class Enumerator {\n    constructor(iter) {\n        this.iter = iter;\n        this.current = defaultOf();\n    }\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    [\"System.Collections.IEnumerator.Reset\"]() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() {\n        return;\n    }\n}\nexport function toEnumerable(e) {\n    if (isEnumerable(e)) {\n        return e;\n    }\n    else {\n        return new Enumerable(new Enumerator(e[Symbol.iterator]()));\n    }\n}\nexport function getEnumerator(e) {\n    if (isEnumerable(e)) {\n        return e.GetEnumerator();\n    }\n    else {\n        return new Enumerator(e[Symbol.iterator]());\n    }\n}\nexport function toIterator(en) {\n    return {\n        next() {\n            const hasNext = en[\"System.Collections.IEnumerator.MoveNext\"]();\n            const current = hasNext ? en[\"System.Collections.Generic.IEnumerator`1.get_Current\"]() : undefined;\n            return { done: !hasNext, value: current };\n        },\n    };\n}\nexport function enumerableToIterator(e) {\n    return toIterator(toEnumerable(e).GetEnumerator());\n}\nexport class Comparer {\n    constructor(f) {\n        this.Compare = f || compare;\n    }\n}\nexport function comparerFromEqualityComparer(comparer) {\n    // Sometimes IEqualityComparer also implements IComparer\n    if (isComparer(comparer)) {\n        return new Comparer(comparer.Compare);\n    }\n    else {\n        return new Comparer((x, y) => {\n            const xhash = comparer.GetHashCode(x);\n            const yhash = comparer.GetHashCode(y);\n            if (xhash === yhash) {\n                return comparer.Equals(x, y) ? 0 : -1;\n            }\n            else {\n                return xhash < yhash ? -1 : 1;\n            }\n        });\n    }\n}\nexport function assertEqual(actual, expected, msg) {\n    if (!equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport function assertNotEqual(actual, expected, msg) {\n    if (equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport class Lazy {\n    constructor(factory) {\n        this.factory = factory;\n        this.isValueCreated = false;\n    }\n    get Value() {\n        if (!this.isValueCreated) {\n            this.createdValue = this.factory();\n            this.isValueCreated = true;\n        }\n        return this.createdValue;\n    }\n    get IsValueCreated() {\n        return this.isValueCreated;\n    }\n}\nexport function lazyFromValue(v) {\n    return new Lazy(() => v);\n}\nexport function padWithZeros(i, length) {\n    let str = i.toString(10);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\nexport function padLeftAndRightWithZeros(i, lengthLeft, lengthRight) {\n    let str = i.toString(10);\n    while (str.length < lengthLeft) {\n        str = \"0\" + str;\n    }\n    while (str.length < lengthRight) {\n        str = str + \"0\";\n    }\n    return str;\n}\nexport function dateOffset(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\"\n        ? date1.offset\n        : (date.kind === 1 /* DateKind.UTC */\n            ? 0 : date.getTimezoneOffset() * -60000);\n}\nexport function int16ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport function int32ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport function int64ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xffffffffffffffffn + i + 1n : i;\n    return i.toString(radix);\n}\nexport class ObjectRef {\n    static id(o) {\n        if (!ObjectRef.idMap.has(o)) {\n            ObjectRef.idMap.set(o, ++ObjectRef.count);\n        }\n        return ObjectRef.idMap.get(o);\n    }\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nexport function stringHash(s) {\n    let i = 0;\n    let h = 5381;\n    const len = s.length;\n    while (i < len) {\n        h = (h * 33) ^ s.charCodeAt(i++);\n    }\n    return h;\n}\nexport function numberHash(x) {\n    return x * 2654435761 | 0;\n}\nexport function bigintHash(x) {\n    return stringHash(x.toString(32));\n}\n// From https://stackoverflow.com/a/37449594\nexport function combineHashCodes(hashes) {\n    let h1 = 0;\n    const len = hashes.length;\n    for (let i = 0; i < len; i++) {\n        const h2 = hashes[i];\n        h1 = ((h1 << 5) + h1) ^ h2;\n    }\n    return h1;\n}\nexport function physicalHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"bigint\":\n            return bigintHash(x);\n        case \"string\":\n            return stringHash(x);\n        default:\n            return numberHash(ObjectRef.id(x));\n    }\n}\nexport function identityHash(x) {\n    if (isHashable(x)) {\n        return x.GetHashCode();\n    }\n    else {\n        return physicalHash(x);\n    }\n}\nexport function dateHash(x) {\n    return x.getTime();\n}\nexport function arrayHash(x) {\n    const len = x.length;\n    const hashes = new Array(len);\n    for (let i = 0; i < len; i++) {\n        hashes[i] = structuralHash(x[i]);\n    }\n    return combineHashCodes(hashes);\n}\nexport function structuralHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"bigint\":\n            return bigintHash(x);\n        case \"string\":\n            return stringHash(x);\n        default: {\n            if (isHashable(x)) {\n                return x.GetHashCode();\n            }\n            else if (isArrayLike(x)) {\n                return arrayHash(x);\n            }\n            else if (x instanceof Date) {\n                return dateHash(x);\n            }\n            else if (Object.getPrototypeOf(x)?.constructor === Object) {\n                // TODO: check call-stack to prevent cyclic objects?\n                const hashes = Object.values(x).map((v) => structuralHash(v));\n                return combineHashCodes(hashes);\n            }\n            else {\n                // Classes don't implement GetHashCode by default, but must use identity hashing\n                return numberHash(ObjectRef.id(x));\n                // return stringHash(String(x));\n            }\n        }\n    }\n}\n// Intended for custom numeric types, like long or decimal\nexport function fastStructuralHash(x) {\n    return stringHash(String(x));\n}\n// Intended for declared types that may or may not implement GetHashCode\nexport function safeHash(x) {\n    // return x == null ? 0 : isHashable(x) ? x.GetHashCode() : numberHash(ObjectRef.id(x));\n    return identityHash(x);\n}\nexport function equalArraysWith(x, y, eq) {\n    if (x == null) {\n        return y == null;\n    }\n    if (y == null) {\n        return false;\n    }\n    if (x.length !== y.length) {\n        return false;\n    }\n    for (let i = 0; i < x.length; i++) {\n        if (!eq(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equalArrays(x, y) {\n    return equalArraysWith(x, y, equals);\n}\nfunction equalObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return false;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0; i < xKeys.length; i++) {\n        if (xKeys[i] !== yKeys[i] || !equals(x[xKeys[i]], y[yKeys[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function physicalEquality(x, y) {\n    return x === y;\n}\nexport function equals(x, y) {\n    if (x === y) {\n        return true;\n    }\n    else if (x == null) {\n        return y == null;\n    }\n    else if (y == null) {\n        return false;\n    }\n    else if (isEquatable(x)) {\n        return x.Equals(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) && equalArrays(x, y);\n    }\n    else if (typeof x !== \"object\") {\n        return false;\n    }\n    else if (x instanceof Date) {\n        return (y instanceof Date) && compareDates(x, y) === 0;\n    }\n    else {\n        return Object.getPrototypeOf(x)?.constructor === Object && equalObjects(x, y);\n    }\n}\nexport function compareDates(x, y) {\n    let xtime;\n    let ytime;\n    // DateTimeOffset and DateTime deals with equality differently.\n    if (\"offset\" in x && \"offset\" in y) {\n        xtime = x.getTime();\n        ytime = y.getTime();\n    }\n    else {\n        xtime = x.getTime() + dateOffset(x);\n        ytime = y.getTime() + dateOffset(y);\n    }\n    return xtime === ytime ? 0 : (xtime < ytime ? -1 : 1);\n}\nexport function comparePrimitives(x, y) {\n    return x === y ? 0 : (x < y ? -1 : 1);\n}\nexport function compareArraysWith(x, y, comp) {\n    if (x == null) {\n        return y == null ? 0 : 1;\n    }\n    if (y == null) {\n        return -1;\n    }\n    if (x.length !== y.length) {\n        return x.length < y.length ? -1 : 1;\n    }\n    for (let i = 0, j = 0; i < x.length; i++) {\n        j = comp(x[i], y[i]);\n        if (j !== 0) {\n            return j;\n        }\n    }\n    return 0;\n}\nexport function compareArrays(x, y) {\n    return compareArraysWith(x, y, compare);\n}\nfunction compareObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return xKeys.length < yKeys.length ? -1 : 1;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0, j = 0; i < xKeys.length; i++) {\n        const key = xKeys[i];\n        if (key !== yKeys[i]) {\n            return key < yKeys[i] ? -1 : 1;\n        }\n        else {\n            j = compare(x[key], y[key]);\n            if (j !== 0) {\n                return j;\n            }\n        }\n    }\n    return 0;\n}\nexport function compare(x, y) {\n    if (x === y) {\n        return 0;\n    }\n    else if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    else if (y == null) {\n        return 1;\n    }\n    else if (isComparable(x)) {\n        return x.CompareTo(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) ? compareArrays(x, y) : -1;\n    }\n    else if (typeof x !== \"object\") {\n        return x < y ? -1 : 1;\n    }\n    else if (x instanceof Date) {\n        return y instanceof Date ? compareDates(x, y) : -1;\n    }\n    else {\n        return Object.getPrototypeOf(x)?.constructor === Object ? compareObjects(x, y) : -1;\n    }\n}\nexport function min(comparer, x, y) {\n    return comparer(x, y) < 0 ? x : y;\n}\nexport function max(comparer, x, y) {\n    return comparer(x, y) > 0 ? x : y;\n}\nexport function clamp(comparer, value, min, max) {\n    return (comparer(value, min) < 0) ? min : (comparer(value, max) > 0) ? max : value;\n}\nexport function createAtom(value) {\n    let atom = value;\n    return (...args) => {\n        if (args.length === 0) {\n            return atom;\n        }\n        else {\n            atom = args[0];\n        }\n    };\n}\nexport function createObj(fields) {\n    const obj = {};\n    for (const kv of fields) {\n        obj[kv[0]] = kv[1];\n    }\n    return obj;\n}\nexport function jsOptions(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nexport function round(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return digits ? r / m : r;\n}\nexport function sign(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nexport function unescapeDataString(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent((s).replace(/\\+/g, \"%20\"));\n}\nexport function escapeDataString(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\")\n        .replace(/'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\")\n        .replace(/\\*/g, \"%2A\");\n}\nexport function escapeUriString(s) {\n    return encodeURI(s);\n}\n// ICollection.Clear and Count members can be called on Arrays\n// or Dictionaries so we need a runtime check (see #1120)\nexport function count(col) {\n    if (isArrayLike(col)) {\n        return col.length;\n    }\n    else {\n        let count = 0;\n        for (const _ of col) {\n            count++;\n        }\n        return count;\n    }\n}\nexport function clear(col) {\n    if (isArrayLike(col)) {\n        col.splice(0);\n    }\n    else {\n        col.clear();\n    }\n}\nconst curried = new WeakMap();\nexport function uncurry2(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2) => f(a1)(a2);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry2(f) {\n    return curried.get(f) ?? ((a1) => (a2) => f(a1, a2));\n}\nexport function uncurry3(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3) => f(a1)(a2)(a3);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry3(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => f(a1, a2, a3));\n}\nexport function uncurry4(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4) => f(a1)(a2)(a3)(a4);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry4(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => f(a1, a2, a3, a4));\n}\nexport function uncurry5(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5) => f(a1)(a2)(a3)(a4)(a5);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry5(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => f(a1, a2, a3, a4, a5));\n}\nexport function uncurry6(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6) => f(a1)(a2)(a3)(a4)(a5)(a6);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry6(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => f(a1, a2, a3, a4, a5, a6));\n}\nexport function uncurry7(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry7(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => f(a1, a2, a3, a4, a5, a6, a7));\n}\nexport function uncurry8(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry8(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => f(a1, a2, a3, a4, a5, a6, a7, a8));\n}\nexport function uncurry9(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry9(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9));\n}\nexport function uncurry10(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry10(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));\n}\nexport function uncurry11(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry11(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));\n}\nexport function uncurry12(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry12(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12));\n}\nexport function uncurry13(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry13(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13));\n}\nexport function uncurry14(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry14(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14));\n}\nexport function uncurry15(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry15(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15));\n}\nexport function uncurry16(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry16(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16));\n}\nexport function uncurry17(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry17(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17));\n}\nexport function uncurry18(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry18(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => (a18) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18));\n}\nexport function uncurry19(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18)(a19);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry19(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => (a18) => (a19) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19));\n}\nexport function uncurry20(f) {\n    if (f == null) {\n        return null;\n    }\n    const f2 = (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20) => f(a1)(a2)(a3)(a4)(a5)(a6)(a7)(a8)(a9)(a10)(a11)(a12)(a13)(a14)(a15)(a16)(a17)(a18)(a19)(a20);\n    curried.set(f2, f);\n    return f2;\n}\nexport function curry20(f) {\n    return curried.get(f)\n        ?? ((a1) => (a2) => (a3) => (a4) => (a5) => (a6) => (a7) => (a8) => (a9) => (a10) => (a11) => (a12) => (a13) => (a14) => (a15) => (a16) => (a17) => (a18) => (a19) => (a20) => f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20));\n}\n// More performant method to copy arrays, see #2352\nexport function copyToArray(source, sourceIndex, target, targetIndex, count) {\n    if (ArrayBuffer.isView(source) && ArrayBuffer.isView(target)) {\n        target.set(source.subarray(sourceIndex, sourceIndex + count), targetIndex);\n    }\n    else {\n        for (let i = 0; i < count; ++i) {\n            target[targetIndex + i] = source[sourceIndex + i];\n        }\n    }\n}\n","import { Helpers_allocateArrayFromCons } from \"./Native.js\";\nimport { value as value_2, map as map_1, defaultArg, some } from \"./Option.js\";\nimport { min as min_1, max as max_1 } from \"./Double.js\";\nimport { equals as equals_1, disposeSafe, getEnumerator, copyToArray, defaultOf } from \"./Util.js\";\nimport { SR_indexOutOfBounds } from \"./Global.js\";\nfunction indexNotFound() {\n    throw new Error(\"An index satisfying the predicate was not found in the collection.\");\n}\nfunction differentLengths() {\n    throw new Error(\"Arrays had different lengths\");\n}\nexport function append(array1, array2, cons) {\n    const len1 = array1.length | 0;\n    const len2 = array2.length | 0;\n    const newArray = Helpers_allocateArrayFromCons(cons, len1 + len2);\n    for (let i = 0; i <= (len1 - 1); i++) {\n        newArray[i] = array1[i];\n    }\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\n        newArray[i_1 + len1] = array2[i_1];\n    }\n    return newArray;\n}\nexport function filter(predicate, array) {\n    return array.filter(predicate);\n}\nexport function fill(target, targetIndex, count, value) {\n    const start = targetIndex | 0;\n    return target.fill(value, start, (start + count));\n}\nexport function getSubArray(array, start, count) {\n    const start_1 = start | 0;\n    return array.slice(start_1, (start_1 + count));\n}\nexport function last(array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    return array[array.length - 1];\n}\nexport function tryLast(array) {\n    if (array.length === 0) {\n        return void 0;\n    }\n    else {\n        return some(array[array.length - 1]);\n    }\n}\nexport function mapIndexed(f, source, cons) {\n    const len = source.length | 0;\n    const target = Helpers_allocateArrayFromCons(cons, len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = f(i, source[i]);\n    }\n    return target;\n}\nexport function map(f, source, cons) {\n    const len = source.length | 0;\n    const target = Helpers_allocateArrayFromCons(cons, len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = f(source[i]);\n    }\n    return target;\n}\nexport function mapIndexed2(f, source1, source2, cons) {\n    if (source1.length !== source2.length) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(i, source1[i], source2[i]);\n    }\n    return result;\n}\nexport function map2(f, source1, source2, cons) {\n    if (source1.length !== source2.length) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(source1[i], source2[i]);\n    }\n    return result;\n}\nexport function mapIndexed3(f, source1, source2, source3, cons) {\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(i, source1[i], source2[i], source3[i]);\n    }\n    return result;\n}\nexport function map3(f, source1, source2, source3, cons) {\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\n        throw new Error(\"Arrays had different lengths\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\n    for (let i = 0; i <= (source1.length - 1); i++) {\n        result[i] = f(source1[i], source2[i], source3[i]);\n    }\n    return result;\n}\nexport function mapFold(mapping, state, array, cons) {\n    const matchValue = array.length | 0;\n    if (matchValue === 0) {\n        return [[], state];\n    }\n    else {\n        let acc = state;\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\n        for (let i = 0; i <= (array.length - 1); i++) {\n            const patternInput = mapping(acc, array[i]);\n            res[i] = patternInput[0];\n            acc = patternInput[1];\n        }\n        return [res, acc];\n    }\n}\nexport function mapFoldBack(mapping, array, state, cons) {\n    const matchValue = array.length | 0;\n    if (matchValue === 0) {\n        return [[], state];\n    }\n    else {\n        let acc = state;\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\n        for (let i = array.length - 1; i >= 0; i--) {\n            const patternInput = mapping(array[i], acc);\n            res[i] = patternInput[0];\n            acc = patternInput[1];\n        }\n        return [res, acc];\n    }\n}\nexport function indexed(source) {\n    const len = source.length | 0;\n    const target = new Array(len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = [i, source[i]];\n    }\n    return target;\n}\nexport function truncate(count, array) {\n    const count_1 = max_1(0, count) | 0;\n    return array.slice(0, (0 + count_1));\n}\nexport function concat(arrays, cons) {\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\n    const matchValue = arrays_1.length | 0;\n    switch (matchValue) {\n        case 0:\n            return Helpers_allocateArrayFromCons(cons, 0);\n        case 1:\n            return arrays_1[0];\n        default: {\n            let totalIdx = 0;\n            let totalLength = 0;\n            for (let idx = 0; idx <= (arrays_1.length - 1); idx++) {\n                const arr_1 = arrays_1[idx];\n                totalLength = ((totalLength + arr_1.length) | 0);\n            }\n            const result = Helpers_allocateArrayFromCons(cons, totalLength);\n            for (let idx_1 = 0; idx_1 <= (arrays_1.length - 1); idx_1++) {\n                const arr_2 = arrays_1[idx_1];\n                for (let j = 0; j <= (arr_2.length - 1); j++) {\n                    result[totalIdx] = arr_2[j];\n                    totalIdx = ((totalIdx + 1) | 0);\n                }\n            }\n            return result;\n        }\n    }\n}\nexport function collect(mapping, array, cons) {\n    return concat(map(mapping, array, defaultOf()), cons);\n}\nexport function where(predicate, array) {\n    return array.filter(predicate);\n}\nexport function indexOf(array, item_1, start, count, eq) {\n    const start_1 = defaultArg(start, 0) | 0;\n    const end$0027 = defaultArg(map_1((c) => (start_1 + c), count), array.length) | 0;\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i >= end$0027) {\n                return -1;\n            }\n            else if (eq.Equals(item_1, array[i])) {\n                return i | 0;\n            }\n            else {\n                i_mut = (i + 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(start_1) | 0;\n}\nexport function contains(value, array, eq) {\n    return indexOf(array, value, void 0, void 0, eq) >= 0;\n}\nexport function empty(cons) {\n    return Helpers_allocateArrayFromCons(cons, 0);\n}\nexport function singleton(value, cons) {\n    const ar = Helpers_allocateArrayFromCons(cons, 1);\n    ar[0] = value;\n    return ar;\n}\nexport function initialize(count, initializer, cons) {\n    if (count < 0) {\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, count);\n    for (let i = 0; i <= (count - 1); i++) {\n        result[i] = initializer(i);\n    }\n    return result;\n}\nexport function pairwise(array) {\n    if (array.length < 2) {\n        return [];\n    }\n    else {\n        const count = (array.length - 1) | 0;\n        const result = new Array(count);\n        for (let i = 0; i <= (count - 1); i++) {\n            result[i] = [array[i], array[i + 1]];\n        }\n        return result;\n    }\n}\nexport function replicate(count, initial, cons) {\n    if (count < 0) {\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    }\n    const result = Helpers_allocateArrayFromCons(cons, count);\n    for (let i = 0; i <= (result.length - 1); i++) {\n        result[i] = initial;\n    }\n    return result;\n}\nexport function copy(array) {\n    return array.slice();\n}\nexport function copyTo(source, sourceIndex, target, targetIndex, count) {\n    copyToArray(source, sourceIndex, target, targetIndex, count);\n}\nexport function reverse(array) {\n    const array_2 = array.slice();\n    return array_2.reverse();\n}\nexport function scan(folder, state, array, cons) {\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\n    res[0] = state;\n    for (let i = 0; i <= (array.length - 1); i++) {\n        res[i + 1] = folder(res[i], array[i]);\n    }\n    return res;\n}\nexport function scanBack(folder, array, state, cons) {\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\n    res[array.length] = state;\n    for (let i = array.length - 1; i >= 0; i--) {\n        res[i] = folder(array[i], res[i + 1]);\n    }\n    return res;\n}\nexport function skip(count, array, cons) {\n    if (count > array.length) {\n        throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n    }\n    if (count === array.length) {\n        return Helpers_allocateArrayFromCons(cons, 0);\n    }\n    else {\n        const count_1 = ((count < 0) ? 0 : count) | 0;\n        return array.slice(count_1);\n    }\n}\nexport function skipWhile(predicate, array, cons) {\n    let count = 0;\n    while ((count < array.length) && predicate(array[count])) {\n        count = ((count + 1) | 0);\n    }\n    if (count === array.length) {\n        return Helpers_allocateArrayFromCons(cons, 0);\n    }\n    else {\n        const count_1 = count | 0;\n        return array.slice(count_1);\n    }\n}\nexport function take(count, array, cons) {\n    if (count < 0) {\n        throw new Error(\"The input must be non-negative\\\\nParameter name: count\");\n    }\n    if (count > array.length) {\n        throw new Error(\"count is greater than array length\\\\nParameter name: count\");\n    }\n    if (count === 0) {\n        return Helpers_allocateArrayFromCons(cons, 0);\n    }\n    else {\n        return array.slice(0, (0 + count));\n    }\n}\nexport function takeWhile(predicate, array, cons) {\n    let count = 0;\n    while ((count < array.length) && predicate(array[count])) {\n        count = ((count + 1) | 0);\n    }\n    if (count === 0) {\n        return Helpers_allocateArrayFromCons(cons, 0);\n    }\n    else {\n        const count_1 = count | 0;\n        return array.slice(0, (0 + count_1));\n    }\n}\nexport function addInPlace(x, array) {\n    array.push(x);\n}\nexport function addRangeInPlace(range, array) {\n    const enumerator = getEnumerator(range);\n    try {\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            addInPlace(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), array);\n        }\n    }\n    finally {\n        disposeSafe(enumerator);\n    }\n}\nexport function insertRangeInPlace(index, range, array) {\n    let index_1;\n    let i = index;\n    const enumerator = getEnumerator(range);\n    try {\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\n            const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\n            (index_1 = (i | 0), array.splice(index_1, 0, x));\n            i = ((i + 1) | 0);\n        }\n    }\n    finally {\n        disposeSafe(enumerator);\n    }\n}\nexport function removeInPlace(item_1, array, eq) {\n    const i = indexOf(array, item_1, void 0, void 0, eq) | 0;\n    if (i > -1) {\n        array.splice(i, 1);\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function removeAllInPlace(predicate, array) {\n    const countRemoveAll = (count) => {\n        const i = (array.findIndex(predicate)) | 0;\n        if (i > -1) {\n            array.splice(i, 1);\n            return (countRemoveAll(count) + 1) | 0;\n        }\n        else {\n            return count | 0;\n        }\n    };\n    return countRemoveAll(0) | 0;\n}\nexport function partition(f, source, cons) {\n    const len = source.length | 0;\n    const res1 = Helpers_allocateArrayFromCons(cons, len);\n    const res2 = Helpers_allocateArrayFromCons(cons, len);\n    let iTrue = 0;\n    let iFalse = 0;\n    for (let i = 0; i <= (len - 1); i++) {\n        if (f(source[i])) {\n            res1[iTrue] = source[i];\n            iTrue = ((iTrue + 1) | 0);\n        }\n        else {\n            res2[iFalse] = source[i];\n            iFalse = ((iFalse + 1) | 0);\n        }\n    }\n    return [truncate(iTrue, res1), truncate(iFalse, res2)];\n}\nexport function find(predicate, array) {\n    const matchValue = array.find(predicate);\n    if (matchValue == null) {\n        return indexNotFound();\n    }\n    else {\n        return value_2(matchValue);\n    }\n}\nexport function tryFind(predicate, array) {\n    return array.find(predicate);\n}\nexport function findIndex(predicate, array) {\n    const matchValue = (array.findIndex(predicate)) | 0;\n    if (matchValue > -1) {\n        return matchValue | 0;\n    }\n    else {\n        indexNotFound();\n        return -1;\n    }\n}\nexport function tryFindIndex(predicate, array) {\n    const matchValue = (array.findIndex(predicate)) | 0;\n    if (matchValue > -1) {\n        return matchValue;\n    }\n    else {\n        return void 0;\n    }\n}\nexport function pick(chooser, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i >= array.length) {\n                return indexNotFound();\n            }\n            else {\n                const matchValue = chooser(array[i]);\n                if (matchValue != null) {\n                    return value_2(matchValue);\n                }\n                else {\n                    i_mut = (i + 1);\n                    continue loop;\n                }\n            }\n            break;\n        }\n    };\n    return loop(0);\n}\nexport function tryPick(chooser, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i >= array.length) {\n                return void 0;\n            }\n            else {\n                const matchValue = chooser(array[i]);\n                if (matchValue == null) {\n                    i_mut = (i + 1);\n                    continue loop;\n                }\n                else {\n                    return matchValue;\n                }\n            }\n            break;\n        }\n    };\n    return loop(0);\n}\nexport function findBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return indexNotFound();\n            }\n            else if (predicate(array[i])) {\n                return array[i];\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nexport function tryFindBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return void 0;\n            }\n            else if (predicate(array[i])) {\n                return some(array[i]);\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nexport function findLastIndex(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return -1;\n            }\n            else if (predicate(array[i])) {\n                return i | 0;\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1) | 0;\n}\nexport function findIndexBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                indexNotFound();\n                return -1;\n            }\n            else if (predicate(array[i])) {\n                return i | 0;\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1) | 0;\n}\nexport function tryFindIndexBack(predicate, array) {\n    const loop = (i_mut) => {\n        loop: while (true) {\n            const i = i_mut;\n            if (i < 0) {\n                return void 0;\n            }\n            else if (predicate(array[i])) {\n                return i;\n            }\n            else {\n                i_mut = (i - 1);\n                continue loop;\n            }\n            break;\n        }\n    };\n    return loop(array.length - 1);\n}\nexport function choose(chooser, array, cons) {\n    const res = [];\n    for (let i = 0; i <= (array.length - 1); i++) {\n        const matchValue = chooser(array[i]);\n        if (matchValue != null) {\n            const y = value_2(matchValue);\n            res.push(y);\n        }\n    }\n    if (equals_1(cons, defaultOf())) {\n        return res;\n    }\n    else {\n        return map((x) => x, res, cons);\n    }\n}\nexport function foldIndexed(folder, state, array) {\n    return array.reduce(((delegateArg, delegateArg_1, delegateArg_2) => folder(delegateArg_2, delegateArg, delegateArg_1)), state);\n}\nexport function fold(folder, state, array) {\n    return array.reduce((folder), state);\n}\nexport function iterate(action, array) {\n    for (let i = 0; i <= (array.length - 1); i++) {\n        action(array[i]);\n    }\n}\nexport function iterateIndexed(action, array) {\n    for (let i = 0; i <= (array.length - 1); i++) {\n        action(i, array[i]);\n    }\n}\nexport function iterate2(action, array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        action(array1[i], array2[i]);\n    }\n}\nexport function iterateIndexed2(action, array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        action(i, array1[i], array2[i]);\n    }\n}\nexport function isEmpty(array) {\n    return array.length === 0;\n}\nexport function forAll(predicate, array) {\n    return array.every(predicate);\n}\nexport function permute(f, array) {\n    const size = array.length | 0;\n    const res = array.slice();\n    const checkFlags = new Array(size);\n    iterateIndexed((i, x) => {\n        const j = f(i) | 0;\n        if ((j < 0) ? true : (j >= size)) {\n            throw new Error(\"Not a valid permutation\");\n        }\n        res[j] = x;\n        checkFlags[j] = 1;\n    }, array);\n    if (!(checkFlags.every((y) => (1 === y)))) {\n        throw new Error(\"Not a valid permutation\");\n    }\n    return res;\n}\nexport function setSlice(target, lower, upper, source) {\n    const lower_1 = defaultArg(lower, 0) | 0;\n    const upper_1 = defaultArg(upper, -1) | 0;\n    const length = (((upper_1 >= 0) ? upper_1 : (target.length - 1)) - lower_1) | 0;\n    for (let i = 0; i <= length; i++) {\n        target[i + lower_1] = source[i];\n    }\n}\nexport function sortInPlaceBy(projection, xs, comparer) {\n    xs.sort((x, y) => comparer.Compare(projection(x), projection(y)));\n}\nexport function sortInPlace(xs, comparer) {\n    xs.sort((x, y) => comparer.Compare(x, y));\n}\nexport function sort(xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => comparer.Compare(x, y));\n    return xs_1;\n}\nexport function sortBy(projection, xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => comparer.Compare(projection(x), projection(y)));\n    return xs_1;\n}\nexport function sortDescending(xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => (comparer.Compare(x, y) * -1));\n    return xs_1;\n}\nexport function sortByDescending(projection, xs, comparer) {\n    const xs_1 = xs.slice();\n    xs_1.sort((x, y) => (comparer.Compare(projection(x), projection(y)) * -1));\n    return xs_1;\n}\nexport function sortWith(comparer, xs) {\n    const comparer_1 = comparer;\n    const xs_1 = xs.slice();\n    xs_1.sort(comparer_1);\n    return xs_1;\n}\nexport function allPairs(xs, ys) {\n    const len1 = xs.length | 0;\n    const len2 = ys.length | 0;\n    const res = new Array(len1 * len2);\n    for (let i = 0; i <= (xs.length - 1); i++) {\n        for (let j = 0; j <= (ys.length - 1); j++) {\n            res[(i * len2) + j] = [xs[i], ys[j]];\n        }\n    }\n    return res;\n}\nexport function unfold(generator, state) {\n    const res = [];\n    const loop = (state_1_mut) => {\n        loop: while (true) {\n            const state_1 = state_1_mut;\n            const matchValue = generator(state_1);\n            if (matchValue != null) {\n                const x = value_2(matchValue)[0];\n                const s = value_2(matchValue)[1];\n                res.push(x);\n                state_1_mut = s;\n                continue loop;\n            }\n            break;\n        }\n    };\n    loop(state);\n    return res;\n}\nexport function unzip(array) {\n    const len = array.length | 0;\n    const res1 = new Array(len);\n    const res2 = new Array(len);\n    iterateIndexed((i, tupledArg) => {\n        res1[i] = tupledArg[0];\n        res2[i] = tupledArg[1];\n    }, array);\n    return [res1, res2];\n}\nexport function unzip3(array) {\n    const len = array.length | 0;\n    const res1 = new Array(len);\n    const res2 = new Array(len);\n    const res3 = new Array(len);\n    iterateIndexed((i, tupledArg) => {\n        res1[i] = tupledArg[0];\n        res2[i] = tupledArg[1];\n        res3[i] = tupledArg[2];\n    }, array);\n    return [res1, res2, res3];\n}\nexport function zip(array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    const result = new Array(array1.length);\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        result[i] = [array1[i], array2[i]];\n    }\n    return result;\n}\nexport function zip3(array1, array2, array3) {\n    if ((array1.length !== array2.length) ? true : (array2.length !== array3.length)) {\n        differentLengths();\n    }\n    const result = new Array(array1.length);\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        result[i] = [array1[i], array2[i], array3[i]];\n    }\n    return result;\n}\nexport function chunkBySize(chunkSize, array) {\n    if (chunkSize < 1) {\n        throw new Error(\"The input must be positive.\\\\nParameter name: size\");\n    }\n    if (array.length === 0) {\n        return [[]];\n    }\n    else {\n        const result = [];\n        for (let x = 0; x <= (~~Math.ceil(array.length / chunkSize) - 1); x++) {\n            let slice;\n            const start_1 = (x * chunkSize) | 0;\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\n            result.push(slice);\n        }\n        return result;\n    }\n}\nexport function splitAt(index, array) {\n    if ((index < 0) ? true : (index > array.length)) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    return [array.slice(0, (0 + index)), array.slice(index)];\n}\nexport function compareWith(comparer, source1, source2) {\n    if (source1 == null) {\n        if (source2 == null) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    }\n    else if (source2 == null) {\n        return 1;\n    }\n    else {\n        const len1 = source1.length | 0;\n        const len2 = source2.length | 0;\n        const len = ((len1 < len2) ? len1 : len2) | 0;\n        let i = 0;\n        let res = 0;\n        while ((res === 0) && (i < len)) {\n            res = (comparer(source1[i], source2[i]) | 0);\n            i = ((i + 1) | 0);\n        }\n        if (res !== 0) {\n            return res | 0;\n        }\n        else if (len1 > len2) {\n            return 1;\n        }\n        else if (len1 < len2) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nexport function compareTo(comparer, source1, source2) {\n    if (source1 == null) {\n        if (source2 == null) {\n            return 0;\n        }\n        else {\n            return -1;\n        }\n    }\n    else if (source2 == null) {\n        return 1;\n    }\n    else {\n        const len1 = source1.length | 0;\n        const len2 = source2.length | 0;\n        if (len1 > len2) {\n            return 1;\n        }\n        else if (len1 < len2) {\n            return -1;\n        }\n        else {\n            let i = 0;\n            let res = 0;\n            while ((res === 0) && (i < len1)) {\n                res = (comparer(source1[i], source2[i]) | 0);\n                i = ((i + 1) | 0);\n            }\n            return res | 0;\n        }\n    }\n}\nexport function equalsWith(equals, array1, array2) {\n    if (array1 == null) {\n        if (array2 == null) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    else if (array2 == null) {\n        return false;\n    }\n    else {\n        let i = 0;\n        let result = true;\n        const length1 = array1.length | 0;\n        const length2 = array2.length | 0;\n        if (length1 > length2) {\n            return false;\n        }\n        else if (length1 < length2) {\n            return false;\n        }\n        else {\n            while ((i < length1) && result) {\n                result = equals(array1[i], array2[i]);\n                i = ((i + 1) | 0);\n            }\n            return result;\n        }\n    }\n}\nexport function exactlyOne(array) {\n    switch (array.length) {\n        case 1:\n            return array[0];\n        case 0:\n            throw new Error(\"The input sequence was empty\\\\nParameter name: array\");\n        default:\n            throw new Error(\"Input array too long\\\\nParameter name: array\");\n    }\n}\nexport function tryExactlyOne(array) {\n    if (array.length === 1) {\n        return some(array[0]);\n    }\n    else {\n        return void 0;\n    }\n}\nexport function head(array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    else {\n        return array[0];\n    }\n}\nexport function tryHead(array) {\n    if (array.length === 0) {\n        return void 0;\n    }\n    else {\n        return some(array[0]);\n    }\n}\nexport function tail(array) {\n    if (array.length === 0) {\n        throw new Error(\"Not enough elements\\\\nParameter name: array\");\n    }\n    return array.slice(1);\n}\nexport function item(index, array) {\n    return array[index];\n}\nexport function tryItem(index, array) {\n    if ((index < 0) ? true : (index >= array.length)) {\n        return void 0;\n    }\n    else {\n        return some(array[index]);\n    }\n}\nexport function foldBackIndexed(folder, array, state) {\n    return array.reduceRight(((delegateArg, delegateArg_1, delegateArg_2) => folder(delegateArg_2, delegateArg_1, delegateArg)), state);\n}\nexport function foldBack(folder, array, state) {\n    return array.reduceRight(((delegateArg, delegateArg_1) => folder(delegateArg_1, delegateArg)), state);\n}\nexport function foldIndexed2(folder, state, array1, array2) {\n    let acc = state;\n    if (array1.length !== array2.length) {\n        throw new Error(\"Arrays have different lengths\");\n    }\n    for (let i = 0; i <= (array1.length - 1); i++) {\n        acc = folder(i, acc, array1[i], array2[i]);\n    }\n    return acc;\n}\nexport function fold2(folder, state, array1, array2) {\n    return foldIndexed2((_arg, acc, x, y) => folder(acc, x, y), state, array1, array2);\n}\nexport function foldBackIndexed2(folder, array1, array2, state) {\n    let acc = state;\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    const size = array1.length | 0;\n    for (let i = 1; i <= size; i++) {\n        acc = folder(i - 1, array1[size - i], array2[size - i], acc);\n    }\n    return acc;\n}\nexport function foldBack2(f, array1, array2, state) {\n    return foldBackIndexed2((_arg, x, y, acc) => f(x, y, acc), array1, array2, state);\n}\nexport function reduce(reduction, array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\");\n    }\n    const reduction_1 = reduction;\n    return array.reduce(reduction_1);\n}\nexport function reduceBack(reduction, array) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\");\n    }\n    const reduction_1 = reduction;\n    return array.reduceRight(reduction_1);\n}\nexport function forAll2(predicate, array1, array2) {\n    return fold2((acc, x, y) => (acc && predicate(x, y)), true, array1, array2);\n}\nexport function existsOffset(predicate_mut, array_mut, index_mut) {\n    existsOffset: while (true) {\n        const predicate = predicate_mut, array = array_mut, index = index_mut;\n        if (index === array.length) {\n            return false;\n        }\n        else if (predicate(array[index])) {\n            return true;\n        }\n        else {\n            predicate_mut = predicate;\n            array_mut = array;\n            index_mut = (index + 1);\n            continue existsOffset;\n        }\n        break;\n    }\n}\nexport function exists(predicate, array) {\n    return existsOffset(predicate, array, 0);\n}\nexport function existsOffset2(predicate_mut, array1_mut, array2_mut, index_mut) {\n    existsOffset2: while (true) {\n        const predicate = predicate_mut, array1 = array1_mut, array2 = array2_mut, index = index_mut;\n        if (index === array1.length) {\n            return false;\n        }\n        else if (predicate(array1[index], array2[index])) {\n            return true;\n        }\n        else {\n            predicate_mut = predicate;\n            array1_mut = array1;\n            array2_mut = array2;\n            index_mut = (index + 1);\n            continue existsOffset2;\n        }\n        break;\n    }\n}\nexport function exists2(predicate, array1, array2) {\n    if (array1.length !== array2.length) {\n        differentLengths();\n    }\n    return existsOffset2(predicate, array1, array2, 0);\n}\nexport function sum(array, adder) {\n    let acc = adder.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        acc = adder.Add(acc, array[i]);\n    }\n    return acc;\n}\nexport function sumBy(projection, array, adder) {\n    let acc = adder.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        acc = adder.Add(acc, projection(array[i]));\n    }\n    return acc;\n}\nexport function maxBy(projection, xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\n}\nexport function max(xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\n}\nexport function minBy(projection, xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\n}\nexport function min(xs, comparer) {\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\n}\nexport function average(array, averager) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    let total = averager.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        total = averager.Add(total, array[i]);\n    }\n    return averager.DivideByInt(total, array.length);\n}\nexport function averageBy(projection, array, averager) {\n    if (array.length === 0) {\n        throw new Error(\"The input array was empty\\\\nParameter name: array\");\n    }\n    let total = averager.GetZero();\n    for (let i = 0; i <= (array.length - 1); i++) {\n        total = averager.Add(total, projection(array[i]));\n    }\n    return averager.DivideByInt(total, array.length);\n}\nexport function windowed(windowSize, source) {\n    if (windowSize <= 0) {\n        throw new Error(\"windowSize must be positive\");\n    }\n    let res;\n    const len = max_1(0, (source.length - windowSize) + 1) | 0;\n    res = (new Array(len));\n    for (let i = windowSize; i <= source.length; i++) {\n        res[i - windowSize] = source.slice(i - windowSize, (i - 1) + 1);\n    }\n    return res;\n}\nexport function splitInto(chunks, array) {\n    if (chunks < 1) {\n        throw new Error(\"The input must be positive.\\\\nParameter name: chunks\");\n    }\n    if (array.length === 0) {\n        return [[]];\n    }\n    else {\n        const result = [];\n        const chunks_1 = min_1(chunks, array.length) | 0;\n        const minChunkSize = ~~(array.length / chunks_1) | 0;\n        const chunksWithExtraItem = (array.length % chunks_1) | 0;\n        for (let i = 0; i <= (chunks_1 - 1); i++) {\n            const chunkSize = ((i < chunksWithExtraItem) ? (minChunkSize + 1) : minChunkSize) | 0;\n            let slice;\n            const start_1 = ((i * minChunkSize) + min_1(chunksWithExtraItem, i)) | 0;\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\n            result.push(slice);\n        }\n        return result;\n    }\n}\nexport function transpose(arrays, cons) {\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\n    const len = arrays_1.length | 0;\n    if (len === 0) {\n        return new Array(0);\n    }\n    else {\n        const firstArray = arrays_1[0];\n        const lenInner = firstArray.length | 0;\n        if (!forAll((a) => (a.length === lenInner), arrays_1)) {\n            differentLengths();\n        }\n        const result = new Array(lenInner);\n        for (let i = 0; i <= (lenInner - 1); i++) {\n            result[i] = Helpers_allocateArrayFromCons(cons, len);\n            for (let j = 0; j <= (len - 1); j++) {\n                result[i][j] = arrays_1[j][i];\n            }\n        }\n        return result;\n    }\n}\nexport function insertAt(index, y, xs, cons) {\n    const len = xs.length | 0;\n    if ((index < 0) ? true : (index > len)) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    const target = Helpers_allocateArrayFromCons(cons, len + 1);\n    for (let i = 0; i <= (index - 1); i++) {\n        target[i] = xs[i];\n    }\n    target[index] = y;\n    for (let i_1 = index; i_1 <= (len - 1); i_1++) {\n        target[i_1 + 1] = xs[i_1];\n    }\n    return target;\n}\nexport function insertManyAt(index, ys, xs, cons) {\n    const len = xs.length | 0;\n    if ((index < 0) ? true : (index > len)) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    const ys_1 = Array.from(ys);\n    const len2 = ys_1.length | 0;\n    const target = Helpers_allocateArrayFromCons(cons, len + len2);\n    for (let i = 0; i <= (index - 1); i++) {\n        target[i] = xs[i];\n    }\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\n        target[index + i_1] = ys_1[i_1];\n    }\n    for (let i_2 = index; i_2 <= (len - 1); i_2++) {\n        target[i_2 + len2] = xs[i_2];\n    }\n    return target;\n}\nexport function removeAt(index, xs) {\n    if ((index < 0) ? true : (index >= xs.length)) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    let i = -1;\n    return filter((_arg) => {\n        i = ((i + 1) | 0);\n        return i !== index;\n    }, xs);\n}\nexport function removeManyAt(index, count, xs) {\n    let i = -1;\n    let status = -1;\n    const ys = filter((_arg) => {\n        i = ((i + 1) | 0);\n        if (i === index) {\n            status = 0;\n            return false;\n        }\n        else if (i > index) {\n            if (i < (index + count)) {\n                return false;\n            }\n            else {\n                status = 1;\n                return true;\n            }\n        }\n        else {\n            return true;\n        }\n    }, xs);\n    const status_1 = (((status === 0) && ((i + 1) === (index + count))) ? 1 : status) | 0;\n    if (status_1 < 1) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + ((status_1 < 0) ? \"index\" : \"count\"));\n    }\n    return ys;\n}\nexport function updateAt(index, y, xs, cons) {\n    const len = xs.length | 0;\n    if ((index < 0) ? true : (index >= len)) {\n        throw new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\");\n    }\n    const target = Helpers_allocateArrayFromCons(cons, len);\n    for (let i = 0; i <= (len - 1); i++) {\n        target[i] = ((i === index) ? y : xs[i]);\n    }\n    return target;\n}\n","export function Helpers_allocateArrayFromCons(cons, len) {\n    if ((typeof cons) === \"function\") {\n        return new cons(len);\n    }\n    else {\n        return new Array(len);\n    }\n}\n","import { structuralHash, equals, compare } from \"./Util.js\";\n// Using a class here for better compatibility with TS files importing Some\nexport class Some {\n    constructor(value) {\n        this.value = value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    // Don't add \"Some\" for consistency with erased options\n    toString() {\n        return String(this.value);\n    }\n    GetHashCode() {\n        return structuralHash(this.value);\n    }\n    Equals(other) {\n        if (other == null) {\n            return false;\n        }\n        else {\n            return equals(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n    CompareTo(other) {\n        if (other == null) {\n            return 1;\n        }\n        else {\n            return compare(this.value, other instanceof Some ? other.value : other);\n        }\n    }\n}\nexport function value(x) {\n    if (x == null) {\n        throw new Error(\"Option has no value\");\n    }\n    else {\n        return x instanceof Some ? x.value : x;\n    }\n}\nexport function unwrap(opt) {\n    return opt instanceof Some ? opt.value : opt;\n}\nexport function some(x) {\n    return x == null || x instanceof Some ? new Some(x) : x;\n}\nexport function ofNullable(x) {\n    // This will fail with unit probably, an alternative would be:\n    // return x === null ? undefined : (x === undefined ? new Some(x) : x);\n    return x == null ? undefined : x;\n}\nexport function toNullable(x) {\n    return x == null ? null : value(x);\n}\nexport function flatten(x) {\n    return x == null ? undefined : value(x);\n}\nexport function toArray(opt) {\n    return (opt == null) ? [] : [value(opt)];\n}\nexport function defaultArg(opt, defaultValue) {\n    return (opt != null) ? value(opt) : defaultValue;\n}\nexport function defaultArgWith(opt, defThunk) {\n    return (opt != null) ? value(opt) : defThunk();\n}\nexport function orElse(opt, ifNone) {\n    return opt == null ? ifNone : opt;\n}\nexport function orElseWith(opt, ifNoneThunk) {\n    return opt == null ? ifNoneThunk() : opt;\n}\nexport function filter(predicate, opt) {\n    return (opt != null) ? (predicate(value(opt)) ? opt : undefined) : opt;\n}\nexport function map(mapping, opt) {\n    return (opt != null) ? some(mapping(value(opt))) : undefined;\n}\nexport function map2(mapping, opt1, opt2) {\n    return (opt1 != null && opt2 != null) ? mapping(value(opt1), value(opt2)) : undefined;\n}\nexport function map3(mapping, opt1, opt2, opt3) {\n    return (opt1 != null && opt2 != null && opt3 != null) ? mapping(value(opt1), value(opt2), value(opt3)) : undefined;\n}\nexport function bind(binder, opt) {\n    return opt != null ? binder(value(opt)) : undefined;\n}\nexport function tryOp(op, arg) {\n    try {\n        return some(op(arg));\n    }\n    catch {\n        return undefined;\n    }\n}\n","import { FSharpRef } from \"./Types.js\";\nexport function tryParse(str, defValue) {\n    // TODO: test if value is valid and in range\n    if (str != null && /\\S/.test(str)) {\n        const v = +str.replace(\"_\", \"\");\n        if (!Number.isNaN(v)) {\n            defValue.contents = v;\n            return true;\n        }\n    }\n    return false;\n}\nexport function parse(str) {\n    const defValue = new FSharpRef(0);\n    if (tryParse(str, defValue)) {\n        return defValue.contents;\n    }\n    else {\n        throw new Error(`The input string ${str} was not in a correct format.`);\n    }\n}\n// JS Number.isFinite function evals false for NaN\nexport function isPositiveInfinity(x) {\n    return x === Number.POSITIVE_INFINITY;\n}\nexport function isNegativeInfinity(x) {\n    return x === Number.NEGATIVE_INFINITY;\n}\nexport function isInfinity(x) {\n    return x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY;\n}\nexport function max(x, y) {\n    return x > y ? x : y;\n}\nexport function min(x, y) {\n    return x < y ? x : y;\n}\nexport function maxMagnitude(x, y) {\n    return Math.abs(x) > Math.abs(y) ? x : y;\n}\nexport function minMagnitude(x, y) {\n    return Math.abs(x) < Math.abs(y) ? x : y;\n}\nexport function clamp(x, min, max) {\n    return x < min ? min : x > max ? max : x;\n}\n","import { combineHashCodes, compare, compareArrays, equalArrays, equals, sameConstructor, numberHash, structuralHash } from \"./Util.js\";\nexport function seqToString(self) {\n    let count = 0;\n    let str = \"[\";\n    for (const x of self) {\n        if (count === 0) {\n            str += toString(x);\n        }\n        else if (count === 100) {\n            str += \"; ...\";\n            break;\n        }\n        else {\n            str += \"; \" + toString(x);\n        }\n        count++;\n    }\n    return str + \"]\";\n}\nexport function toString(x, callStack = 0) {\n    if (x != null && typeof x === \"object\") {\n        if (typeof x.toString === \"function\") {\n            return x.toString();\n        }\n        else if (Symbol.iterator in x) {\n            return seqToString(x);\n        }\n        else { // TODO: Date?\n            const cons = Object.getPrototypeOf(x)?.constructor;\n            return cons === Object && callStack < 10\n                // Same format as recordToString\n                ? \"{ \" + Object.entries(x).map(([k, v]) => k + \" = \" + toString(v, callStack + 1)).join(\"\\n  \") + \" }\"\n                : cons?.name ?? \"\";\n        }\n    }\n    return String(x);\n}\nexport function unionToString(name, fields) {\n    if (fields.length === 0) {\n        return name;\n    }\n    else {\n        let fieldStr;\n        let withParens = true;\n        if (fields.length === 1) {\n            fieldStr = toString(fields[0]);\n            withParens = fieldStr.indexOf(\" \") >= 0;\n        }\n        else {\n            fieldStr = fields.map((x) => toString(x)).join(\", \");\n        }\n        return name + (withParens ? \" (\" : \" \") + fieldStr + (withParens ? \")\" : \"\");\n    }\n}\nexport class Union {\n    get name() {\n        return this.cases()[this.tag];\n    }\n    toJSON() {\n        return this.fields.length === 0 ? this.name : [this.name].concat(this.fields);\n    }\n    toString() {\n        return unionToString(this.name, this.fields);\n    }\n    GetHashCode() {\n        const hashes = this.fields.map((x) => structuralHash(x));\n        hashes.splice(0, 0, numberHash(this.tag));\n        return combineHashCodes(hashes);\n    }\n    Equals(other) {\n        if (this === other) {\n            return true;\n        }\n        else if (!sameConstructor(this, other)) {\n            return false;\n        }\n        else if (this.tag === other.tag) {\n            return equalArrays(this.fields, other.fields);\n        }\n        else {\n            return false;\n        }\n    }\n    CompareTo(other) {\n        if (this === other) {\n            return 0;\n        }\n        else if (!sameConstructor(this, other)) {\n            return -1;\n        }\n        else if (this.tag === other.tag) {\n            return compareArrays(this.fields, other.fields);\n        }\n        else {\n            return this.tag < other.tag ? -1 : 1;\n        }\n    }\n}\nfunction recordToJSON(self) {\n    const o = {};\n    const keys = Object.keys(self);\n    for (let i = 0; i < keys.length; i++) {\n        o[keys[i]] = self[keys[i]];\n    }\n    return o;\n}\nfunction recordToString(self) {\n    return \"{ \" + Object.entries(self).map(([k, v]) => k + \" = \" + toString(v)).join(\"\\n  \") + \" }\";\n}\nfunction recordGetHashCode(self) {\n    const hashes = Object.values(self).map((v) => structuralHash(v));\n    return combineHashCodes(hashes);\n}\nfunction recordEquals(self, other) {\n    if (self === other) {\n        return true;\n    }\n    else if (!sameConstructor(self, other)) {\n        return false;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            if (!equals(self[thisNames[i]], other[thisNames[i]])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfunction recordCompareTo(self, other) {\n    if (self === other) {\n        return 0;\n    }\n    else if (!sameConstructor(self, other)) {\n        return -1;\n    }\n    else {\n        const thisNames = Object.keys(self);\n        for (let i = 0; i < thisNames.length; i++) {\n            const result = compare(self[thisNames[i]], other[thisNames[i]]);\n            if (result !== 0) {\n                return result;\n            }\n        }\n        return 0;\n    }\n}\nexport class Record {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nexport class FSharpRef {\n    get contents() {\n        return this.getter();\n    }\n    set contents(v) {\n        this.setter(v);\n    }\n    constructor(contentsOrGetter, setter) {\n        if (typeof setter === \"function\") {\n            this.getter = contentsOrGetter;\n            this.setter = setter;\n        }\n        else {\n            this.getter = () => contentsOrGetter;\n            this.setter = (v) => { contentsOrGetter = v; };\n        }\n    }\n}\n// EXCEPTIONS\n// Exception is intentionally not derived from Error, for performance reasons (see #2160)\nexport class Exception {\n    constructor(message) {\n        this.message = message;\n    }\n}\nexport function isException(x) {\n    return x instanceof Exception || x instanceof Error;\n}\nexport function isPromise(x) {\n    return x instanceof Promise;\n}\nexport function ensureErrorOrException(e) {\n    // Exceptionally admitting promises as errors for compatibility with React.suspense (see #3298)\n    return (isException(e) || isPromise(e)) ? e : new Error(String(e));\n}\nexport class FSharpException extends Exception {\n    toJSON() { return recordToJSON(this); }\n    toString() { return recordToString(this); }\n    GetHashCode() { return recordGetHashCode(this); }\n    Equals(other) { return recordEquals(this, other); }\n    CompareTo(other) { return recordCompareTo(this, other); }\n}\nexport class MatchFailureException extends FSharpException {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.arg1 = arg1;\n        this.arg2 = arg2 | 0;\n        this.arg3 = arg3 | 0;\n        this.message = \"The match cases were incomplete\";\n    }\n}\nexport class Attribute {\n}\n","export const SR_indexOutOfBounds = \"The index was outside the range of elements in the collection.\";\nexport const SR_inputWasEmpty = \"Collection was empty.\";\nexport const SR_inputMustBeNonNegative = \"The input must be non-negative.\";\nexport const SR_inputSequenceEmpty = \"The input sequence was empty.\";\nexport const SR_inputSequenceTooLong = \"The input sequence contains more than one element.\";\nexport const SR_keyNotFoundAlt = \"An index satisfying the predicate was not found in the collection.\";\nexport const SR_differentLengths = \"The collections had different lengths.\";\nexport const SR_notEnoughElements = \"The input sequence has an insufficient number of elements.\";\n","import { index, tableauModel } from \"./tableau.js\";\nimport { roundToPrecision } from \"./util.js\";\nimport { simplex } from \"./simplex.js\";\nimport { branchAndCut } from \"./branchAndCut.js\";\n// Creates a solution object representing the optimal solution (if any).\nconst solution = ({ tableau, sign, variables: vars }, status, result, { precision, includeZeroVariables }) => {\n    if (status === \"optimal\" || (status === \"timedout\" && !Number.isNaN(result))) {\n        const variables = [];\n        for (let i = 0; i < vars.length; i++) {\n            const [variable] = vars[i];\n            const row = tableau.positionOfVariable[i + 1] - tableau.width;\n            const value = row >= 0 ? index(tableau, row, 0) : 0.0;\n            if (value > precision) {\n                variables.push([variable, roundToPrecision(value, precision)]);\n            }\n            else if (includeZeroVariables) {\n                variables.push([variable, 0.0]);\n            }\n        }\n        return {\n            status,\n            result: -sign * result,\n            variables\n        };\n    }\n    else if (status === \"unbounded\") {\n        const variable = tableau.variableAtPosition[result] - 1;\n        return {\n            status: \"unbounded\",\n            result: sign * Infinity,\n            // prettier-ignore\n            variables: (0 <= variable && variable < vars.length)\n                ? [[vars[variable][0], Infinity]]\n                : []\n        };\n    }\n    else {\n        // infeasible | cycled | (timedout and result is NaN)\n        return {\n            status,\n            result: NaN,\n            variables: []\n        };\n    }\n};\nconst defaultOptionValues = {\n    precision: 1e-8,\n    checkCycles: false,\n    maxPivots: 8192,\n    tolerance: 0,\n    timeout: Infinity,\n    maxIterations: 32768,\n    includeZeroVariables: false\n};\n/**\n * The default options used by the solver.\n */\nexport const defaultOptions = { ...defaultOptionValues };\n/**\n * Runs the solver on the given model and using the given options (if any).\n * @see `Model` on how to specify/create the model.\n * @see `Options` for the kinds of options available.\n * @see `Solution` for more detailed information on what is returned.\n */\nexport const solve = (model, options) => {\n    const tabmod = tableauModel(model);\n    const opt = { ...defaultOptionValues, ...options };\n    const [status, result] = simplex(tabmod.tableau, opt);\n    if (tabmod.integers.length === 0 || status !== \"optimal\") {\n        // If a non-integer problem, return the simplex result.\n        // Otherwise, the problem has integer variables, but the initial solution is either:\n        // 1) unbounded | infeasible => all branches will also be unbounded | infeasible\n        // 2) cycled => cannot get an initial solution, return invalid solution\n        return solution(tabmod, status, result, opt);\n    }\n    else {\n        // Integer problem and an optimal non-integer solution was found\n        const [intTabmod, intStatus, intResult] = branchAndCut(tabmod, result, opt);\n        return solution(intTabmod, intStatus, intResult, opt);\n    }\n};\n","export const index = (tableau, row, col) => tableau.matrix[Math.imul(row, tableau.width) + col];\nexport const update = (tableau, row, col, value) => {\n    tableau.matrix[Math.imul(row, tableau.width) + col] = value;\n};\nconst convertToIterable = (seq) => typeof seq[Symbol.iterator] === \"function\" // eslint-disable-line\n    ? seq\n    : Object.entries(seq);\n// prettier-ignore\nconst convertToSet = (set) => set === true ? true\n    : set === false ? new Set()\n        : set instanceof Set ? set\n            : new Set(set);\nexport const tableauModel = (model) => {\n    const { direction, objective, integers, binaries } = model;\n    const sign = direction === \"minimize\" ? -1.0 : 1.0;\n    const constraintsIter = convertToIterable(model.constraints);\n    const variablesIter = convertToIterable(model.variables);\n    const variables = Array.isArray(variablesIter) ? variablesIter : Array.from(variablesIter);\n    const binaryConstraintCol = [];\n    const ints = [];\n    if (integers != null || binaries != null) {\n        const binaryVariables = convertToSet(binaries);\n        const integerVariables = binaryVariables === true ? true : convertToSet(integers);\n        for (let i = 1; i <= variables.length; i++) {\n            const [key] = variables[i - 1];\n            if (binaryVariables === true || binaryVariables.has(key)) {\n                binaryConstraintCol.push(i);\n                ints.push(i);\n            }\n            else if (integerVariables === true || integerVariables.has(key)) {\n                ints.push(i);\n            }\n        }\n    }\n    const constraints = new Map();\n    for (const [key, constraint] of constraintsIter) {\n        const bounds = constraints.get(key) ?? { row: NaN, lower: -Infinity, upper: Infinity };\n        bounds.lower = Math.max(bounds.lower, constraint.equal ?? constraint.min ?? -Infinity);\n        bounds.upper = Math.min(bounds.upper, constraint.equal ?? constraint.max ?? Infinity);\n        // if (rows.lower > rows.upper) return [\"infeasible\", NaN]\n        if (!constraints.has(key))\n            constraints.set(key, bounds);\n    }\n    let numConstraints = 1;\n    for (const constraint of constraints.values()) {\n        constraint.row = numConstraints;\n        numConstraints += (Number.isFinite(constraint.lower) ? 1 : 0) + (Number.isFinite(constraint.upper) ? 1 : 0);\n    }\n    const width = variables.length + 1;\n    const height = numConstraints + binaryConstraintCol.length;\n    const numVars = width + height;\n    const matrix = new Float64Array(width * height);\n    const positionOfVariable = new Int32Array(numVars);\n    const variableAtPosition = new Int32Array(numVars);\n    const tableau = { matrix, width, height, positionOfVariable, variableAtPosition };\n    for (let i = 0; i < numVars; i++) {\n        positionOfVariable[i] = i;\n        variableAtPosition[i] = i;\n    }\n    for (let c = 1; c < width; c++) {\n        for (const [constraint, coef] of convertToIterable(variables[c - 1][1])) {\n            if (constraint === objective) {\n                update(tableau, 0, c, sign * coef);\n            }\n            const bounds = constraints.get(constraint);\n            if (bounds != null) {\n                if (Number.isFinite(bounds.upper)) {\n                    update(tableau, bounds.row, c, coef);\n                    if (Number.isFinite(bounds.lower)) {\n                        update(tableau, bounds.row + 1, c, -coef);\n                    }\n                }\n                else if (Number.isFinite(bounds.lower)) {\n                    update(tableau, bounds.row, c, -coef);\n                }\n            }\n        }\n    }\n    for (const bounds of constraints.values()) {\n        if (Number.isFinite(bounds.upper)) {\n            update(tableau, bounds.row, 0, bounds.upper);\n            if (Number.isFinite(bounds.lower)) {\n                update(tableau, bounds.row + 1, 0, -bounds.lower);\n            }\n        }\n        else if (Number.isFinite(bounds.lower)) {\n            update(tableau, bounds.row, 0, -bounds.lower);\n        }\n    }\n    for (let b = 0; b < binaryConstraintCol.length; b++) {\n        const row = numConstraints + b;\n        update(tableau, row, 0, 1.0);\n        update(tableau, row, binaryConstraintCol[b], 1.0);\n    }\n    return { tableau, sign, variables, integers: ints };\n};\n","export const roundToPrecision = (num, precision) => {\n    const rounding = Math.round(1.0 / precision);\n    return Math.round((num + Number.EPSILON) * rounding) / rounding;\n};\n","import { index, update } from \"./tableau.js\";\nimport { roundToPrecision } from \"./util.js\";\nconst pivot = (tableau, row, col) => {\n    const quotient = index(tableau, row, col);\n    const leaving = tableau.variableAtPosition[tableau.width + row];\n    const entering = tableau.variableAtPosition[col];\n    tableau.variableAtPosition[tableau.width + row] = entering;\n    tableau.variableAtPosition[col] = leaving;\n    tableau.positionOfVariable[leaving] = col;\n    tableau.positionOfVariable[entering] = tableau.width + row;\n    const nonZeroColumns = [];\n    // (1 / quotient) * R_pivot -> R_pivot\n    for (let c = 0; c < tableau.width; c++) {\n        const value = index(tableau, row, c);\n        if (Math.abs(value) > 1e-16) {\n            update(tableau, row, c, value / quotient);\n            nonZeroColumns.push(c);\n        }\n        else {\n            update(tableau, row, c, 0.0);\n        }\n    }\n    update(tableau, row, col, 1.0 / quotient);\n    // -M[r, col] * R_pivot + R_r -> R_r\n    for (let r = 0; r < tableau.height; r++) {\n        if (r === row)\n            continue;\n        const coef = index(tableau, r, col);\n        if (Math.abs(coef) > 1e-16) {\n            for (let i = 0; i < nonZeroColumns.length; i++) {\n                const c = nonZeroColumns[i];\n                update(tableau, r, c, index(tableau, r, c) - coef * index(tableau, row, c));\n            }\n            update(tableau, r, col, -coef / quotient);\n        }\n    }\n};\n// Checks if the simplex method has encountered a cycle.\nconst hasCycle = (history, tableau, row, col) => {\n    // This whole function seems somewhat inefficient,\n    // but there was no? noticable impact in the benchmarks.\n    history.push([tableau.variableAtPosition[tableau.width + row], tableau.variableAtPosition[col]]);\n    // the minimum length of a cycle is 6\n    for (let length = 6; length <= Math.trunc(history.length / 2); length++) {\n        let cycle = true;\n        for (let i = 0; i < length; i++) {\n            const item = history.length - 1 - i;\n            const [row1, col1] = history[item];\n            const [row2, col2] = history[item - length];\n            if (row1 !== row2 || col1 !== col2) {\n                cycle = false;\n                break;\n            }\n        }\n        if (cycle)\n            return true;\n    }\n    return false;\n};\n// Finds the optimal solution given some basic feasible solution.\nconst phase2 = (tableau, options) => {\n    const pivotHistory = [];\n    const { precision, maxPivots, checkCycles } = options;\n    for (let iter = 0; iter < maxPivots; iter++) {\n        // Find the entering column/variable\n        let col = 0;\n        let value = precision;\n        for (let c = 1; c < tableau.width; c++) {\n            const reducedCost = index(tableau, 0, c);\n            if (reducedCost > value) {\n                value = reducedCost;\n                col = c;\n            }\n        }\n        if (col === 0)\n            return [\"optimal\", roundToPrecision(index(tableau, 0, 0), precision)];\n        // Find the leaving row/variable\n        let row = 0;\n        let minRatio = Infinity;\n        for (let r = 1; r < tableau.height; r++) {\n            const value = index(tableau, r, col);\n            if (value <= precision)\n                continue; // pivot entry must be positive\n            const rhs = index(tableau, r, 0);\n            const ratio = rhs / value;\n            if (ratio < minRatio) {\n                row = r;\n                minRatio = ratio;\n                if (ratio <= precision)\n                    break; // ratio is 0, lowest possible\n            }\n        }\n        if (row === 0)\n            return [\"unbounded\", col];\n        if (checkCycles && hasCycle(pivotHistory, tableau, row, col))\n            return [\"cycled\", NaN];\n        pivot(tableau, row, col);\n    }\n    return [\"cycled\", NaN];\n};\n// Transforms a tableau into a basic feasible solution.\nconst phase1 = (tableau, options) => {\n    const pivotHistory = [];\n    const { precision, maxPivots, checkCycles } = options;\n    for (let iter = 0; iter < maxPivots; iter++) {\n        // Find the leaving row/variable\n        let row = 0;\n        let rhs = -precision;\n        for (let r = 1; r < tableau.height; r++) {\n            const value = index(tableau, r, 0);\n            if (value < rhs) {\n                rhs = value;\n                row = r;\n            }\n        }\n        if (row === 0)\n            return phase2(tableau, options);\n        // Find the entering column/variable\n        let col = 0;\n        let maxRatio = -Infinity;\n        for (let c = 1; c < tableau.width; c++) {\n            const coefficient = index(tableau, row, c);\n            if (coefficient < -precision) {\n                const ratio = -index(tableau, 0, c) / coefficient;\n                if (ratio > maxRatio) {\n                    maxRatio = ratio;\n                    col = c;\n                }\n            }\n        }\n        if (col === 0)\n            return [\"infeasible\", NaN];\n        if (checkCycles && hasCycle(pivotHistory, tableau, row, col))\n            return [\"cycled\", NaN];\n        pivot(tableau, row, col);\n    }\n    return [\"cycled\", NaN];\n};\nexport { phase1 as simplex };\n","import { index } from \"./tableau.js\";\nimport { simplex } from \"./simplex.js\";\nimport Heap from \"heap\";\nconst buffer = (matrixLength, posVarLength) => ({\n    matrix: new Float64Array(matrixLength),\n    positionOfVariable: new Int32Array(posVarLength),\n    variableAtPosition: new Int32Array(posVarLength)\n});\n// Creates a new tableau with additional cut constraints from a buffer.\nconst applyCuts = (tableau, { matrix, positionOfVariable, variableAtPosition }, cuts) => {\n    const { width, height } = tableau;\n    matrix.set(tableau.matrix);\n    for (let i = 0; i < cuts.length; i++) {\n        const [sign, variable, value] = cuts[i];\n        const r = (height + i) * width;\n        const pos = tableau.positionOfVariable[variable];\n        if (pos < width) {\n            matrix[r] = sign * value;\n            matrix.fill(0.0, r + 1, r + width);\n            matrix[r + pos] = sign;\n        }\n        else {\n            const row = (pos - width) * width;\n            matrix[r] = sign * (value - matrix[row]);\n            for (let c = 1; c < width; c++) {\n                matrix[r + c] = -sign * matrix[row + c];\n            }\n        }\n    }\n    positionOfVariable.set(tableau.positionOfVariable);\n    variableAtPosition.set(tableau.variableAtPosition);\n    const length = width + height + cuts.length;\n    for (let i = width + height; i < length; i++) {\n        positionOfVariable[i] = i;\n        variableAtPosition[i] = i;\n    }\n    return {\n        matrix: matrix.subarray(0, tableau.matrix.length + width * cuts.length),\n        width,\n        height: height + cuts.length,\n        positionOfVariable: positionOfVariable.subarray(0, length),\n        variableAtPosition: variableAtPosition.subarray(0, length)\n    };\n};\n// Finds the integer variable with the most fractional value.\nconst mostFractionalVar = (tableau, intVars) => {\n    let highestFrac = 0.0;\n    let variable = 0;\n    let value = 0.0;\n    for (let i = 0; i < intVars.length; i++) {\n        const intVar = intVars[i];\n        const row = tableau.positionOfVariable[intVar] - tableau.width;\n        if (row < 0)\n            continue;\n        const val = index(tableau, row, 0);\n        const frac = Math.abs(val - Math.round(val));\n        if (frac > highestFrac) {\n            highestFrac = frac;\n            variable = intVar;\n            value = val;\n        }\n    }\n    return [variable, value, highestFrac];\n};\n// Runs the branch and cut algorithm to solve an integer problem.\n// Requires the non-integer solution as input.\nexport const branchAndCut = (tabmod, initResult, options) => {\n    const { tableau, sign, integers } = tabmod;\n    const { precision, maxIterations, tolerance, timeout } = options;\n    const [initVariable, initValue, initFrac] = mostFractionalVar(tableau, integers);\n    // Wow, the initial solution is integer\n    if (initFrac <= precision)\n        return [tabmod, \"optimal\", initResult];\n    const branches = new Heap((x, y) => x[0] - y[0]);\n    branches.push([initResult, [[-1, initVariable, Math.ceil(initValue)]]]);\n    branches.push([initResult, [[1, initVariable, Math.floor(initValue)]]]);\n    // Set aside arrays/buffers to be reused over the course of the algorithm.\n    // One set of buffers stores the state of the currrent best solution.\n    // The other is used to solve the current candidate solution.\n    // The two buffers are \"swapped\" once a new best solution is found.\n    const maxExtraRows = integers.length * 2;\n    const matrixLength = tableau.matrix.length + maxExtraRows * tableau.width;\n    const posVarLength = tableau.positionOfVariable.length + maxExtraRows;\n    let candidateBuffer = buffer(matrixLength, posVarLength);\n    let solutionBuffer = buffer(matrixLength, posVarLength);\n    const optimalThreshold = initResult * (1.0 - sign * tolerance);\n    const stopTime = timeout + Date.now();\n    let timedout = Date.now() >= stopTime; // in case options.timeout <= 0\n    let solutionFound = false;\n    let bestEval = Infinity;\n    let bestTableau = tableau;\n    let iter = 0;\n    while (iter < maxIterations && !branches.empty() && bestEval >= optimalThreshold && !timedout) {\n        const [relaxedEval, cuts] = branches.pop();\n        if (relaxedEval > bestEval)\n            break; // the remaining branches are worse than the current best solution\n        const currentTableau = applyCuts(tableau, candidateBuffer, cuts);\n        const [status, result] = simplex(currentTableau, options);\n        // The initial tableau is not unbounded and adding more cuts/constraints cannot make it become unbounded\n        // assert(status !== \"unbounded\")\n        if (status === \"optimal\" && result < bestEval) {\n            const [variable, value, frac] = mostFractionalVar(currentTableau, integers);\n            if (frac <= precision) {\n                // The solution is integer\n                solutionFound = true;\n                bestEval = result;\n                bestTableau = currentTableau;\n                const temp = solutionBuffer;\n                solutionBuffer = candidateBuffer;\n                candidateBuffer = temp;\n            }\n            else {\n                const cutsUpper = [];\n                const cutsLower = [];\n                for (let i = 0; i < cuts.length; i++) {\n                    const cut = cuts[i];\n                    const [dir, v] = cut;\n                    if (v === variable) {\n                        dir < 0 ? cutsLower.push(cut) : cutsUpper.push(cut);\n                    }\n                    else {\n                        cutsUpper.push(cut);\n                        cutsLower.push(cut);\n                    }\n                }\n                cutsLower.push([1, variable, Math.floor(value)]);\n                cutsUpper.push([-1, variable, Math.ceil(value)]);\n                branches.push([result, cutsUpper]);\n                branches.push([result, cutsLower]);\n            }\n        }\n        // Otherwise, this branch's result is worse than the current best solution.\n        // This could be because this branch is infeasible or cycled.\n        // Either way, skip this branch and see if any other branches have a valid, better solution.\n        timedout = Date.now() >= stopTime;\n        iter++;\n    }\n    // Did the solver \"timeout\"?\n    const unfinished = (timedout || iter >= maxIterations) && !branches.empty() && bestEval >= optimalThreshold;\n    // prettier-ignore\n    const status = unfinished ? \"timedout\"\n        : !solutionFound ? \"infeasible\"\n            : \"optimal\";\n    return [{ ...tabmod, tableau: bestTableau }, status, solutionFound ? bestEval : NaN];\n};\n","module.exports = require('./lib/heap');\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Heap","defaultCmp","floor","heapify","heappop","heappush","heappushpop","heapreplace","insort","min","nlargest","nsmallest","updateItem","_siftdown","_siftup","factory","Math","x","y","a","lo","hi","cmp","mid","length","splice","apply","concat","array","item","push","lastelt","returnitem","pop","_ref","i","_i","_len","_ref1","_results","_results1","_j","reverse","pos","indexOf","n","result","slice","sort","elem","los","startpos","newitem","parent","parentpos","childpos","endpos","rightpos","nodes","replace","pushpop","prototype","peek","contains","clear","empty","size","clone","heap","toArray","insert","top","front","has","copy","define","amd","$0ba2f68448f8716d$export$f3f95c9f1920e9b5","o","idMap","set","count","get","WeakMap","$766310993b931f49$export$b610b8812bbcded9","tableau","row","col","matrix","imul","width","$766310993b931f49$export$722fbec263ad908a","value","$766310993b931f49$var$convertToIterable","seq","Symbol","iterator","Object","entries","$766310993b931f49$var$convertToSet","Set","$766310993b931f49$export$5775ac136be60802","model","direction","objective","integers","binaries","sign","constraintsIter","constraints","variablesIter","variables","Array","isArray","from","binaryConstraintCol","ints","binaryVariables","integerVariables","key","Map","constraint","bounds","NaN","lower","Infinity","upper","max","equal","numConstraints","values","Number","isFinite","height","numVars","Float64Array","positionOfVariable","Int32Array","variableAtPosition","c","coef","b","$1b2ad3cb69a79105$export$b485511e5cd71305","num","precision","rounding","round","EPSILON","$8135c8e95bc184a9$var$pivot","quotient","leaving","entering","nonZeroColumns","abs","r","$8135c8e95bc184a9$var$hasCycle","history","trunc","cycle","row1","col1","row2","col2","$8135c8e95bc184a9$var$phase2","options","pivotHistory","maxPivots","checkCycles","iter","reducedCost","minRatio","ratio","rhs","$8135c8e95bc184a9$export$cdff0fdd5b0f2742","maxRatio","coefficient","$a480cfd0af27e963$exports","$9ffe9ea54178e5e7$var$buffer","matrixLength","posVarLength","$9ffe9ea54178e5e7$var$applyCuts","cuts","variable","fill","subarray","$9ffe9ea54178e5e7$var$mostFractionalVar","intVars","highestFrac","intVar","val","frac","$9ffe9ea54178e5e7$export$ecbfccb5730dd058","tabmod","initResult","maxIterations","tolerance","timeout","initVariable","initValue","initFrac","branches","__esModule","default","ceil","maxExtraRows","candidateBuffer","solutionBuffer","optimalThreshold","stopTime","Date","now","timedout","solutionFound","bestEval","bestTableau","relaxedEval","currentTableau","status","temp","cutsUpper","cutsLower","cut","dir","v","unfinished","$a886f1a34b7cd82c$var$solution","vars","includeZeroVariables","isNaN","$a886f1a34b7cd82c$var$defaultOptionValues","$a886f1a34b7cd82c$export$2865df1f26e73f8e","opt","intTabmod","intStatus","intResult","onmessage","message","matchValue","data","ArrayBuffer","isView","postMessage","f","source","cons","len","target"],"version":3,"file":"Worker.ed1c8dc5.js.map"}
{"mappings":"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","sources":["fable/fable_modules/fable-library.3.7.20/Util.js","node_modules/.pnpm/heap@0.2.7/node_modules/heap/index.js","node_modules/.pnpm/heap@0.2.7/node_modules/heap/lib/heap.js","fable/fable_modules/fable-library.3.7.20/Array.js","node_modules/.pnpm/yalps@0.3.0/node_modules/yalps/dist/YALPS.cjs","src/WebApp/Worker.fs"],"sourcesContent":["// tslint:disable:ban-types\nexport function isIterable(x) {\n    return x != null && typeof x === \"object\" && Symbol.iterator in x;\n}\nexport function isArrayLike(x) {\n    return Array.isArray(x) || ArrayBuffer.isView(x);\n}\nfunction isComparer(x) {\n    return typeof x.Compare === \"function\";\n}\nfunction isComparable(x) {\n    return typeof x.CompareTo === \"function\";\n}\nfunction isEquatable(x) {\n    return typeof x.Equals === \"function\";\n}\nfunction isHashable(x) {\n    return typeof x.GetHashCode === \"function\";\n}\nexport function isDisposable(x) {\n    return x != null && typeof x.Dispose === \"function\";\n}\nexport function disposeSafe(x) {\n    if (isDisposable(x)) {\n        x.Dispose();\n    }\n}\nexport function sameConstructor(x, y) {\n    var _a, _b;\n    return ((_a = Object.getPrototypeOf(x)) === null || _a === void 0 ? void 0 : _a.constructor) === ((_b = Object.getPrototypeOf(y)) === null || _b === void 0 ? void 0 : _b.constructor);\n}\nexport class Enumerator {\n    constructor(iter) {\n        this.iter = iter;\n    }\n    [\"System.Collections.Generic.IEnumerator`1.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.get_Current\"]() {\n        return this.current;\n    }\n    [\"System.Collections.IEnumerator.MoveNext\"]() {\n        const cur = this.iter.next();\n        this.current = cur.value;\n        return !cur.done;\n    }\n    [\"System.Collections.IEnumerator.Reset\"]() {\n        throw new Error(\"JS iterators cannot be reset\");\n    }\n    Dispose() {\n        return;\n    }\n}\nexport function getEnumerator(o) {\n    return typeof o.GetEnumerator === \"function\"\n        ? o.GetEnumerator()\n        : new Enumerator(o[Symbol.iterator]());\n}\nexport function toIterator(en) {\n    return {\n        [Symbol.iterator]() { return this; },\n        next() {\n            const hasNext = en[\"System.Collections.IEnumerator.MoveNext\"]();\n            const current = hasNext ? en[\"System.Collections.IEnumerator.get_Current\"]() : undefined;\n            return { done: !hasNext, value: current };\n        },\n    };\n}\nexport class Comparer {\n    constructor(f) {\n        this.Compare = f || compare;\n    }\n}\nexport function comparerFromEqualityComparer(comparer) {\n    // Sometimes IEqualityComparer also implements IComparer\n    if (isComparer(comparer)) {\n        return new Comparer(comparer.Compare);\n    }\n    else {\n        return new Comparer((x, y) => {\n            const xhash = comparer.GetHashCode(x);\n            const yhash = comparer.GetHashCode(y);\n            if (xhash === yhash) {\n                return comparer.Equals(x, y) ? 0 : -1;\n            }\n            else {\n                return xhash < yhash ? -1 : 1;\n            }\n        });\n    }\n}\nexport function assertEqual(actual, expected, msg) {\n    if (!equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport function assertNotEqual(actual, expected, msg) {\n    if (equals(actual, expected)) {\n        throw Object.assign(new Error(msg || `Expected: ${expected} - Actual: ${actual}`), {\n            actual,\n            expected,\n        });\n    }\n}\nexport class Lazy {\n    constructor(factory) {\n        this.factory = factory;\n        this.isValueCreated = false;\n    }\n    get Value() {\n        if (!this.isValueCreated) {\n            this.createdValue = this.factory();\n            this.isValueCreated = true;\n        }\n        return this.createdValue;\n    }\n    get IsValueCreated() {\n        return this.isValueCreated;\n    }\n}\nexport function lazyFromValue(v) {\n    return new Lazy(() => v);\n}\nexport function padWithZeros(i, length) {\n    let str = i.toString(10);\n    while (str.length < length) {\n        str = \"0\" + str;\n    }\n    return str;\n}\nexport function padLeftAndRightWithZeros(i, lengthLeft, lengthRight) {\n    let str = i.toString(10);\n    while (str.length < lengthLeft) {\n        str = \"0\" + str;\n    }\n    while (str.length < lengthRight) {\n        str = str + \"0\";\n    }\n    return str;\n}\nexport function dateOffset(date) {\n    const date1 = date;\n    return typeof date1.offset === \"number\"\n        ? date1.offset\n        : (date.kind === 1 /* UTC */\n            ? 0 : date.getTimezoneOffset() * -60000);\n}\nexport function int16ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport function int32ToString(i, radix) {\n    i = i < 0 && radix != null && radix !== 10 ? 0xFFFFFFFF + i + 1 : i;\n    return i.toString(radix);\n}\nexport class ObjectRef {\n    static id(o) {\n        if (!ObjectRef.idMap.has(o)) {\n            ObjectRef.idMap.set(o, ++ObjectRef.count);\n        }\n        return ObjectRef.idMap.get(o);\n    }\n}\nObjectRef.idMap = new WeakMap();\nObjectRef.count = 0;\nexport function stringHash(s) {\n    let i = 0;\n    let h = 5381;\n    const len = s.length;\n    while (i < len) {\n        h = (h * 33) ^ s.charCodeAt(i++);\n    }\n    return h;\n}\nexport function numberHash(x) {\n    return x * 2654435761 | 0;\n}\n// From https://stackoverflow.com/a/37449594\nexport function combineHashCodes(hashes) {\n    if (hashes.length === 0) {\n        return 0;\n    }\n    return hashes.reduce((h1, h2) => {\n        return ((h1 << 5) + h1) ^ h2;\n    });\n}\nexport function physicalHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default:\n            return numberHash(ObjectRef.id(x));\n    }\n}\nexport function identityHash(x) {\n    if (x == null) {\n        return 0;\n    }\n    else if (isHashable(x)) {\n        return x.GetHashCode();\n    }\n    else {\n        return physicalHash(x);\n    }\n}\nexport function dateHash(x) {\n    return x.getTime();\n}\nexport function arrayHash(x) {\n    const len = x.length;\n    const hashes = new Array(len);\n    for (let i = 0; i < len; i++) {\n        hashes[i] = structuralHash(x[i]);\n    }\n    return combineHashCodes(hashes);\n}\nexport function structuralHash(x) {\n    var _a;\n    if (x == null) {\n        return 0;\n    }\n    switch (typeof x) {\n        case \"boolean\":\n            return x ? 1 : 0;\n        case \"number\":\n            return numberHash(x);\n        case \"string\":\n            return stringHash(x);\n        default: {\n            if (isHashable(x)) {\n                return x.GetHashCode();\n            }\n            else if (isArrayLike(x)) {\n                return arrayHash(x);\n            }\n            else if (x instanceof Date) {\n                return dateHash(x);\n            }\n            else if (((_a = Object.getPrototypeOf(x)) === null || _a === void 0 ? void 0 : _a.constructor) === Object) {\n                // TODO: check call-stack to prevent cyclic objects?\n                const hashes = Object.values(x).map((v) => structuralHash(v));\n                return combineHashCodes(hashes);\n            }\n            else {\n                // Classes don't implement GetHashCode by default, but must use identity hashing\n                return numberHash(ObjectRef.id(x));\n                // return stringHash(String(x));\n            }\n        }\n    }\n}\n// Intended for custom numeric types, like long or decimal\nexport function fastStructuralHash(x) {\n    return stringHash(String(x));\n}\n// Intended for declared types that may or may not implement GetHashCode\nexport function safeHash(x) {\n    return x == null ? 0 : isHashable(x) ? x.GetHashCode() : numberHash(ObjectRef.id(x));\n}\nexport function equalArraysWith(x, y, eq) {\n    if (x == null) {\n        return y == null;\n    }\n    if (y == null) {\n        return false;\n    }\n    if (x.length !== y.length) {\n        return false;\n    }\n    for (let i = 0; i < x.length; i++) {\n        if (!eq(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equalArrays(x, y) {\n    return equalArraysWith(x, y, equals);\n}\nfunction equalObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return false;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0; i < xKeys.length; i++) {\n        if (xKeys[i] !== yKeys[i] || !equals(x[xKeys[i]], y[yKeys[i]])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function equals(x, y) {\n    var _a;\n    if (x === y) {\n        return true;\n    }\n    else if (x == null) {\n        return y == null;\n    }\n    else if (y == null) {\n        return false;\n    }\n    else if (typeof x !== \"object\") {\n        return false;\n    }\n    else if (isEquatable(x)) {\n        return x.Equals(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) && equalArrays(x, y);\n    }\n    else if (x instanceof Date) {\n        return (y instanceof Date) && compareDates(x, y) === 0;\n    }\n    else {\n        return ((_a = Object.getPrototypeOf(x)) === null || _a === void 0 ? void 0 : _a.constructor) === Object && equalObjects(x, y);\n    }\n}\nexport function compareDates(x, y) {\n    let xtime;\n    let ytime;\n    // DateTimeOffset and DateTime deals with equality differently.\n    if (\"offset\" in x && \"offset\" in y) {\n        xtime = x.getTime();\n        ytime = y.getTime();\n    }\n    else {\n        xtime = x.getTime() + dateOffset(x);\n        ytime = y.getTime() + dateOffset(y);\n    }\n    return xtime === ytime ? 0 : (xtime < ytime ? -1 : 1);\n}\nexport function comparePrimitives(x, y) {\n    return x === y ? 0 : (x < y ? -1 : 1);\n}\nexport function compareArraysWith(x, y, comp) {\n    if (x == null) {\n        return y == null ? 0 : 1;\n    }\n    if (y == null) {\n        return -1;\n    }\n    if (x.length !== y.length) {\n        return x.length < y.length ? -1 : 1;\n    }\n    for (let i = 0, j = 0; i < x.length; i++) {\n        j = comp(x[i], y[i]);\n        if (j !== 0) {\n            return j;\n        }\n    }\n    return 0;\n}\nexport function compareArrays(x, y) {\n    return compareArraysWith(x, y, compare);\n}\nfunction compareObjects(x, y) {\n    const xKeys = Object.keys(x);\n    const yKeys = Object.keys(y);\n    if (xKeys.length !== yKeys.length) {\n        return xKeys.length < yKeys.length ? -1 : 1;\n    }\n    xKeys.sort();\n    yKeys.sort();\n    for (let i = 0, j = 0; i < xKeys.length; i++) {\n        const key = xKeys[i];\n        if (key !== yKeys[i]) {\n            return key < yKeys[i] ? -1 : 1;\n        }\n        else {\n            j = compare(x[key], y[key]);\n            if (j !== 0) {\n                return j;\n            }\n        }\n    }\n    return 0;\n}\nexport function compare(x, y) {\n    var _a;\n    if (x === y) {\n        return 0;\n    }\n    else if (x == null) {\n        return y == null ? 0 : -1;\n    }\n    else if (y == null) {\n        return 1;\n    }\n    else if (typeof x !== \"object\") {\n        return x < y ? -1 : 1;\n    }\n    else if (isComparable(x)) {\n        return x.CompareTo(y);\n    }\n    else if (isArrayLike(x)) {\n        return isArrayLike(y) ? compareArrays(x, y) : -1;\n    }\n    else if (x instanceof Date) {\n        return y instanceof Date ? compareDates(x, y) : -1;\n    }\n    else {\n        return ((_a = Object.getPrototypeOf(x)) === null || _a === void 0 ? void 0 : _a.constructor) === Object ? compareObjects(x, y) : -1;\n    }\n}\nexport function min(comparer, x, y) {\n    return comparer(x, y) < 0 ? x : y;\n}\nexport function max(comparer, x, y) {\n    return comparer(x, y) > 0 ? x : y;\n}\nexport function clamp(comparer, value, min, max) {\n    return (comparer(value, min) < 0) ? min : (comparer(value, max) > 0) ? max : value;\n}\nexport function createAtom(value) {\n    let atom = value;\n    return (value, isSetter) => {\n        if (!isSetter) {\n            return atom;\n        }\n        else {\n            atom = value;\n            return void 0;\n        }\n    };\n}\nexport function createObj(fields) {\n    const obj = {};\n    for (const kv of fields) {\n        obj[kv[0]] = kv[1];\n    }\n    return obj;\n}\nexport function jsOptions(mutator) {\n    const opts = {};\n    mutator(opts);\n    return opts;\n}\nexport function round(value, digits = 0) {\n    const m = Math.pow(10, digits);\n    const n = +(digits ? value * m : value).toFixed(8);\n    const i = Math.floor(n);\n    const f = n - i;\n    const e = 1e-8;\n    const r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 === 0) ? i : i + 1) : Math.round(n);\n    return digits ? r / m : r;\n}\nexport function sign(x) {\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\n}\nexport function unescapeDataString(s) {\n    // https://stackoverflow.com/a/4458580/524236\n    return decodeURIComponent((s).replace(/\\+/g, \"%20\"));\n}\nexport function escapeDataString(s) {\n    return encodeURIComponent(s).replace(/!/g, \"%21\")\n        .replace(/'/g, \"%27\")\n        .replace(/\\(/g, \"%28\")\n        .replace(/\\)/g, \"%29\")\n        .replace(/\\*/g, \"%2A\");\n}\nexport function escapeUriString(s) {\n    return encodeURI(s);\n}\n// ICollection.Clear and Count members can be called on Arrays\n// or Dictionaries so we need a runtime check (see #1120)\nexport function count(col) {\n    if (isArrayLike(col)) {\n        return col.length;\n    }\n    else {\n        let count = 0;\n        for (const _ of col) {\n            count++;\n        }\n        return count;\n    }\n}\nexport function clear(col) {\n    if (isArrayLike(col)) {\n        col.splice(0);\n    }\n    else {\n        col.clear();\n    }\n}\nconst CURRIED = Symbol(\"curried\");\nexport function uncurry(arity, f) {\n    // f may be a function option with None value\n    if (f == null || f.length > 1) {\n        return f;\n    }\n    const uncurried = (...args) => {\n        let res = f;\n        for (let i = 0; i < arity; i++) {\n            res = res(args[i]);\n        }\n        return res;\n    };\n    uncurried[CURRIED] = f;\n    return uncurried;\n}\nfunction _curry(args, arity, f) {\n    return (arg) => arity === 1\n        ? f(...args.concat([arg]))\n        // Note it's important to generate a new args array every time\n        // because a partially applied function can be run multiple times\n        : _curry(args.concat([arg]), arity - 1, f);\n}\nexport function curry(arity, f) {\n    if (f == null || f.length === 1) {\n        return f;\n    }\n    else if (CURRIED in f) {\n        return f[CURRIED];\n    }\n    else {\n        return _curry([], arity, f);\n    }\n}\nexport function checkArity(arity, f) {\n    return f.length > arity\n        ? (...args1) => (...args2) => f.apply(undefined, args1.concat(args2))\n        : f;\n}\nexport function partialApply(arity, f, args) {\n    if (f == null) {\n        return undefined;\n    }\n    else if (CURRIED in f) {\n        f = f[CURRIED];\n        for (let i = 0; i < args.length; i++) {\n            f = f(args[i]);\n        }\n        return f;\n    }\n    else {\n        return _curry(args, arity, f);\n    }\n}\nexport function mapCurriedArgs(fn, mappings) {\n    function mapArg(fn, arg, mappings, idx) {\n        const mapping = mappings[idx];\n        if (mapping !== 0) {\n            const expectedArity = mapping[0];\n            const actualArity = mapping[1];\n            if (expectedArity > 1) {\n                arg = curry(expectedArity, arg);\n            }\n            if (actualArity > 1) {\n                arg = uncurry(actualArity, arg);\n            }\n        }\n        const res = fn(arg);\n        if (idx + 1 === mappings.length) {\n            return res;\n        }\n        else {\n            return (arg) => mapArg(res, arg, mappings, idx + 1);\n        }\n    }\n    return (arg) => mapArg(fn, arg, mappings, 0);\n}\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","import { value as value_2, map as map_1, defaultArg, some } from \"./Option.js\";\r\nimport { min as min_1, disposeSafe, getEnumerator, comparePrimitives, max as max_1 } from \"./Util.js\";\r\nimport { SR_indexOutOfBounds } from \"./Global.js\";\r\n\r\nexport function Helpers_allocateArrayFromCons(cons, len) {\r\n    if ((typeof cons) === \"function\") {\r\n        return new cons(len);\r\n    }\r\n    else {\r\n        return new Array(len);\r\n    }\r\n}\r\n\r\nfunction indexNotFound() {\r\n    throw (new Error(\"An index satisfying the predicate was not found in the collection.\"));\r\n}\r\n\r\nfunction differentLengths() {\r\n    throw (new Error(\"Arrays had different lengths\"));\r\n}\r\n\r\nexport function append(array1, array2, cons) {\r\n    const len1 = array1.length | 0;\r\n    const len2 = array2.length | 0;\r\n    const newArray = Helpers_allocateArrayFromCons(cons, len1 + len2);\r\n    for (let i = 0; i <= (len1 - 1); i++) {\r\n        newArray[i] = array1[i];\r\n    }\r\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\r\n        newArray[i_1 + len1] = array2[i_1];\r\n    }\r\n    return newArray;\r\n}\r\n\r\nexport function filter(predicate, array) {\r\n    return array.filter(predicate);\r\n}\r\n\r\nexport function fill(target, targetIndex, count, value) {\r\n    const start = targetIndex | 0;\r\n    return target.fill(value, start, (start + count));\r\n}\r\n\r\nexport function getSubArray(array, start, count) {\r\n    const start_1 = start | 0;\r\n    return array.slice(start_1, (start_1 + count));\r\n}\r\n\r\nexport function last(array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    return array[array.length - 1];\r\n}\r\n\r\nexport function tryLast(array) {\r\n    if (array.length === 0) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[array.length - 1]);\r\n    }\r\n}\r\n\r\nexport function mapIndexed(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const target = Helpers_allocateArrayFromCons(cons, len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = f(i, source[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function map(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const target = Helpers_allocateArrayFromCons(cons, len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = f(source[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function mapIndexed2(f, source1, source2, cons) {\r\n    if (source1.length !== source2.length) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(i, source1[i], source2[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function map2(f, source1, source2, cons) {\r\n    if (source1.length !== source2.length) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(source1[i], source2[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function mapIndexed3(f, source1, source2, source3, cons) {\r\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(i, source1[i], source2[i], source3[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function map3(f, source1, source2, source3, cons) {\r\n    if ((source1.length !== source2.length) ? true : (source2.length !== source3.length)) {\r\n        throw (new Error(\"Arrays had different lengths\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, source1.length);\r\n    for (let i = 0; i <= (source1.length - 1); i++) {\r\n        result[i] = f(source1[i], source2[i], source3[i]);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function mapFold(mapping, state, array, cons) {\r\n    const matchValue = array.length | 0;\r\n    if (matchValue === 0) {\r\n        return [[], state];\r\n    }\r\n    else {\r\n        let acc = state;\r\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\r\n        for (let i = 0; i <= (array.length - 1); i++) {\r\n            const patternInput = mapping(acc, array[i]);\r\n            res[i] = patternInput[0];\r\n            acc = patternInput[1];\r\n        }\r\n        return [res, acc];\r\n    }\r\n}\r\n\r\nexport function mapFoldBack(mapping, array, state, cons) {\r\n    const matchValue = array.length | 0;\r\n    if (matchValue === 0) {\r\n        return [[], state];\r\n    }\r\n    else {\r\n        let acc = state;\r\n        const res = Helpers_allocateArrayFromCons(cons, matchValue);\r\n        for (let i = array.length - 1; i >= 0; i--) {\r\n            const patternInput = mapping(array[i], acc);\r\n            res[i] = patternInput[0];\r\n            acc = patternInput[1];\r\n        }\r\n        return [res, acc];\r\n    }\r\n}\r\n\r\nexport function indexed(source) {\r\n    const len = source.length | 0;\r\n    const target = new Array(len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = [i, source[i]];\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function truncate(count, array) {\r\n    const count_1 = max_1(comparePrimitives, 0, count) | 0;\r\n    const start = 0;\r\n    return array.slice(start, (start + count_1));\r\n}\r\n\r\nexport function concat(arrays, cons) {\r\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\r\n    const matchValue = arrays_1.length | 0;\r\n    switch (matchValue) {\r\n        case 0: {\r\n            return Helpers_allocateArrayFromCons(cons, 0);\r\n        }\r\n        case 1: {\r\n            return arrays_1[0];\r\n        }\r\n        default: {\r\n            let totalIdx = 0;\r\n            let totalLength = 0;\r\n            for (let idx = 0; idx <= (arrays_1.length - 1); idx++) {\r\n                const arr_1 = arrays_1[idx];\r\n                totalLength = ((totalLength + arr_1.length) | 0);\r\n            }\r\n            const result = Helpers_allocateArrayFromCons(cons, totalLength);\r\n            for (let idx_1 = 0; idx_1 <= (arrays_1.length - 1); idx_1++) {\r\n                const arr_2 = arrays_1[idx_1];\r\n                for (let j = 0; j <= (arr_2.length - 1); j++) {\r\n                    result[totalIdx] = arr_2[j];\r\n                    totalIdx = ((totalIdx + 1) | 0);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nexport function collect(mapping, array, cons) {\r\n    return concat(map(mapping, array, null), cons);\r\n}\r\n\r\nexport function where(predicate, array) {\r\n    return array.filter(predicate);\r\n}\r\n\r\nexport function indexOf(array, item_1, start, count, eq) {\r\n    const start_1 = defaultArg(start, 0) | 0;\r\n    const end$0027 = defaultArg(map_1((c) => (start_1 + c), count), array.length) | 0;\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= end$0027) {\r\n                return -1;\r\n            }\r\n            else if (eq.Equals(item_1, array[i])) {\r\n                return i | 0;\r\n            }\r\n            else {\r\n                i_mut = (i + 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(start_1) | 0;\r\n}\r\n\r\nexport function contains(value, array, eq) {\r\n    return indexOf(array, value, void 0, void 0, eq) >= 0;\r\n}\r\n\r\nexport function empty(cons) {\r\n    return Helpers_allocateArrayFromCons(cons, 0);\r\n}\r\n\r\nexport function singleton(value, cons) {\r\n    const ar = Helpers_allocateArrayFromCons(cons, 1);\r\n    ar[0] = value;\r\n    return ar;\r\n}\r\n\r\nexport function initialize(count, initializer, cons) {\r\n    if (count < 0) {\r\n        throw (new Error(\"The input must be non-negative\\\\nParameter name: count\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, count);\r\n    for (let i = 0; i <= (count - 1); i++) {\r\n        result[i] = initializer(i);\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function pairwise(array) {\r\n    if (array.length < 2) {\r\n        return [];\r\n    }\r\n    else {\r\n        const count = (array.length - 1) | 0;\r\n        const result = new Array(count);\r\n        for (let i = 0; i <= (count - 1); i++) {\r\n            result[i] = [array[i], array[i + 1]];\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function replicate(count, initial, cons) {\r\n    if (count < 0) {\r\n        throw (new Error(\"The input must be non-negative\\\\nParameter name: count\"));\r\n    }\r\n    const result = Helpers_allocateArrayFromCons(cons, count);\r\n    for (let i = 0; i <= (result.length - 1); i++) {\r\n        result[i] = initial;\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function copy(array) {\r\n    return array.slice();\r\n}\r\n\r\nexport function reverse(array) {\r\n    const array_2 = array.slice();\r\n    return array_2.reverse();\r\n}\r\n\r\nexport function scan(folder, state, array, cons) {\r\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\r\n    res[0] = state;\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        res[i + 1] = folder(res[i], array[i]);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function scanBack(folder, array, state, cons) {\r\n    const res = Helpers_allocateArrayFromCons(cons, array.length + 1);\r\n    res[array.length] = state;\r\n    for (let i = array.length - 1; i >= 0; i--) {\r\n        res[i] = folder(array[i], res[i + 1]);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function skip(count, array, cons) {\r\n    if (count > array.length) {\r\n        throw (new Error(\"count is greater than array length\\\\nParameter name: count\"));\r\n    }\r\n    if (count === array.length) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const count_1 = ((count < 0) ? 0 : count) | 0;\r\n        return array.slice(count_1);\r\n    }\r\n}\r\n\r\nexport function skipWhile(predicate, array, cons) {\r\n    let count = 0;\r\n    while ((count < array.length) && predicate(array[count])) {\r\n        count = ((count + 1) | 0);\r\n    }\r\n    if (count === array.length) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const count_1 = count | 0;\r\n        return array.slice(count_1);\r\n    }\r\n}\r\n\r\nexport function take(count, array, cons) {\r\n    if (count < 0) {\r\n        throw (new Error(\"The input must be non-negative\\\\nParameter name: count\"));\r\n    }\r\n    if (count > array.length) {\r\n        throw (new Error(\"count is greater than array length\\\\nParameter name: count\"));\r\n    }\r\n    if (count === 0) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const start = 0;\r\n        return array.slice(start, (start + count));\r\n    }\r\n}\r\n\r\nexport function takeWhile(predicate, array, cons) {\r\n    let count = 0;\r\n    while ((count < array.length) && predicate(array[count])) {\r\n        count = ((count + 1) | 0);\r\n    }\r\n    if (count === 0) {\r\n        return Helpers_allocateArrayFromCons(cons, 0);\r\n    }\r\n    else {\r\n        const start = 0;\r\n        const count_1 = count | 0;\r\n        return array.slice(start, (start + count_1));\r\n    }\r\n}\r\n\r\nexport function addInPlace(x, array) {\r\n    array.push(x);\r\n}\r\n\r\nexport function addRangeInPlace(range, array) {\r\n    const enumerator = getEnumerator(range);\r\n    try {\r\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            addInPlace(enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"](), array);\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(enumerator);\r\n    }\r\n}\r\n\r\nexport function insertRangeInPlace(index, range, array) {\r\n    let index_1;\r\n    let i = index;\r\n    const enumerator = getEnumerator(range);\r\n    try {\r\n        while (enumerator[\"System.Collections.IEnumerator.MoveNext\"]()) {\r\n            const x = enumerator[\"System.Collections.Generic.IEnumerator`1.get_Current\"]();\r\n            (index_1 = (i | 0), array.splice(index_1, 0, x));\r\n            i = ((i + 1) | 0);\r\n        }\r\n    }\r\n    finally {\r\n        disposeSafe(enumerator);\r\n    }\r\n}\r\n\r\nexport function removeInPlace(item_1, array, eq) {\r\n    const i = indexOf(array, item_1, void 0, void 0, eq) | 0;\r\n    if (i > -1) {\r\n        array.splice(i, 1);\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function removeAllInPlace(predicate, array) {\r\n    const countRemoveAll = (count) => {\r\n        const i = (array.findIndex(predicate)) | 0;\r\n        if (i > -1) {\r\n            array.splice(i, 1);\r\n            return (countRemoveAll(count) + 1) | 0;\r\n        }\r\n        else {\r\n            return count | 0;\r\n        }\r\n    };\r\n    return countRemoveAll(0) | 0;\r\n}\r\n\r\nexport function copyTo(source, sourceIndex, target, targetIndex, count) {\r\n    const diff = (targetIndex - sourceIndex) | 0;\r\n    for (let i = sourceIndex; i <= ((sourceIndex + count) - 1); i++) {\r\n        target[i + diff] = source[i];\r\n    }\r\n}\r\n\r\nexport function copyToTypedArray(source, sourceIndex, target, targetIndex, count) {\r\n    try {\r\n        target.set(source.subarray(sourceIndex, sourceIndex + count), targetIndex);\r\n    }\r\n    catch (matchValue) {\r\n        copyTo(source, sourceIndex, target, targetIndex, count);\r\n    }\r\n}\r\n\r\nexport function partition(f, source, cons) {\r\n    const len = source.length | 0;\r\n    const res1 = Helpers_allocateArrayFromCons(cons, len);\r\n    const res2 = Helpers_allocateArrayFromCons(cons, len);\r\n    let iTrue = 0;\r\n    let iFalse = 0;\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        if (f(source[i])) {\r\n            res1[iTrue] = source[i];\r\n            iTrue = ((iTrue + 1) | 0);\r\n        }\r\n        else {\r\n            res2[iFalse] = source[i];\r\n            iFalse = ((iFalse + 1) | 0);\r\n        }\r\n    }\r\n    return [truncate(iTrue, res1), truncate(iFalse, res2)];\r\n}\r\n\r\nexport function find(predicate, array) {\r\n    const matchValue = array.find(predicate);\r\n    if (matchValue == null) {\r\n        return indexNotFound();\r\n    }\r\n    else {\r\n        return value_2(matchValue);\r\n    }\r\n}\r\n\r\nexport function tryFind(predicate, array) {\r\n    return array.find(predicate);\r\n}\r\n\r\nexport function findIndex(predicate, array) {\r\n    const matchValue = (array.findIndex(predicate)) | 0;\r\n    if (matchValue > -1) {\r\n        return matchValue | 0;\r\n    }\r\n    else {\r\n        return indexNotFound() | 0;\r\n    }\r\n}\r\n\r\nexport function tryFindIndex(predicate, array) {\r\n    const matchValue = (array.findIndex(predicate)) | 0;\r\n    if (matchValue > -1) {\r\n        return matchValue;\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function pick(chooser, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= array.length) {\r\n                return indexNotFound();\r\n            }\r\n            else {\r\n                const matchValue = chooser(array[i]);\r\n                if (matchValue != null) {\r\n                    return value_2(matchValue);\r\n                }\r\n                else {\r\n                    i_mut = (i + 1);\r\n                    continue loop;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0);\r\n}\r\n\r\nexport function tryPick(chooser, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i >= array.length) {\r\n                return void 0;\r\n            }\r\n            else {\r\n                const matchValue = chooser(array[i]);\r\n                if (matchValue == null) {\r\n                    i_mut = (i + 1);\r\n                    continue loop;\r\n                }\r\n                else {\r\n                    return matchValue;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(0);\r\n}\r\n\r\nexport function findBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return indexNotFound();\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return array[i];\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function tryFindBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return void 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return some(array[i]);\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function findLastIndex(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return -1;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i | 0;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1) | 0;\r\n}\r\n\r\nexport function findIndexBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return indexNotFound() | 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i | 0;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1) | 0;\r\n}\r\n\r\nexport function tryFindIndexBack(predicate, array) {\r\n    const loop = (i_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const i = i_mut;\r\n            if (i < 0) {\r\n                return void 0;\r\n            }\r\n            else if (predicate(array[i])) {\r\n                return i;\r\n            }\r\n            else {\r\n                i_mut = (i - 1);\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    return loop(array.length - 1);\r\n}\r\n\r\nexport function choose(chooser, array, cons) {\r\n    const res = [];\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        const matchValue = chooser(array[i]);\r\n        if (matchValue != null) {\r\n            const y = value_2(matchValue);\r\n            res.push(y);\r\n        }\r\n    }\r\n    if ((typeof cons) === \"function\") {\r\n        return map((x) => x, res, cons);\r\n    }\r\n    else {\r\n        return res;\r\n    }\r\n}\r\n\r\nexport function foldIndexed(folder, state, array) {\r\n    return array.reduce(((delegateArg, delegateArg_1, delegateArg_2) => folder(delegateArg_2, delegateArg, delegateArg_1)), state);\r\n}\r\n\r\nexport function fold(folder, state, array) {\r\n    return array.reduce((folder), state);\r\n}\r\n\r\nexport function iterate(action, array) {\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        action(array[i]);\r\n    }\r\n}\r\n\r\nexport function iterateIndexed(action, array) {\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        action(i, array[i]);\r\n    }\r\n}\r\n\r\nexport function iterate2(action, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        action(array1[i], array2[i]);\r\n    }\r\n}\r\n\r\nexport function iterateIndexed2(action, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        action(i, array1[i], array2[i]);\r\n    }\r\n}\r\n\r\nexport function isEmpty(array) {\r\n    return array.length === 0;\r\n}\r\n\r\nexport function forAll(predicate, array) {\r\n    return array.every(predicate);\r\n}\r\n\r\nexport function permute(f, array) {\r\n    const size = array.length | 0;\r\n    const res = array.slice();\r\n    const checkFlags = new Array(size);\r\n    iterateIndexed((i, x) => {\r\n        const j = f(i) | 0;\r\n        if ((j < 0) ? true : (j >= size)) {\r\n            throw (new Error(\"Not a valid permutation\"));\r\n        }\r\n        res[j] = x;\r\n        checkFlags[j] = 1;\r\n    }, array);\r\n    if (!(checkFlags.every((y) => (1 === y)))) {\r\n        throw (new Error(\"Not a valid permutation\"));\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function setSlice(target, lower, upper, source) {\r\n    const lower_1 = defaultArg(lower, 0) | 0;\r\n    const upper_1 = defaultArg(upper, -1) | 0;\r\n    const length = (((upper_1 >= 0) ? upper_1 : (target.length - 1)) - lower_1) | 0;\r\n    for (let i = 0; i <= length; i++) {\r\n        target[i + lower_1] = source[i];\r\n    }\r\n}\r\n\r\nexport function sortInPlaceBy(projection, xs, comparer) {\r\n    xs.sort((x, y) => comparer.Compare(projection(x), projection(y)));\r\n}\r\n\r\nexport function sortInPlace(xs, comparer) {\r\n    xs.sort((x, y) => comparer.Compare(x, y));\r\n}\r\n\r\nexport function sort(xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort((x, y) => comparer.Compare(x, y));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortBy(projection, xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort((x, y) => comparer.Compare(projection(x), projection(y)));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortDescending(xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort((x, y) => (comparer.Compare(x, y) * -1));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortByDescending(projection, xs, comparer) {\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort((x, y) => (comparer.Compare(projection(x), projection(y)) * -1));\r\n    return xs_1;\r\n}\r\n\r\nexport function sortWith(comparer, xs) {\r\n    const comparer_1 = comparer;\r\n    const xs_1 = xs.slice();\r\n    xs_1.sort(comparer_1);\r\n    return xs_1;\r\n}\r\n\r\nexport function allPairs(xs, ys) {\r\n    const len1 = xs.length | 0;\r\n    const len2 = ys.length | 0;\r\n    const res = new Array(len1 * len2);\r\n    for (let i = 0; i <= (xs.length - 1); i++) {\r\n        for (let j = 0; j <= (ys.length - 1); j++) {\r\n            res[(i * len2) + j] = [xs[i], ys[j]];\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function unfold(generator, state) {\r\n    const res = [];\r\n    const loop = (state_1_mut) => {\r\n        loop:\r\n        while (true) {\r\n            const state_1 = state_1_mut;\r\n            const matchValue = generator(state_1);\r\n            if (matchValue != null) {\r\n                const x = matchValue[0];\r\n                const s = matchValue[1];\r\n                res.push(x);\r\n                state_1_mut = s;\r\n                continue loop;\r\n            }\r\n            break;\r\n        }\r\n    };\r\n    loop(state);\r\n    return res;\r\n}\r\n\r\nexport function unzip(array) {\r\n    const len = array.length | 0;\r\n    const res1 = new Array(len);\r\n    const res2 = new Array(len);\r\n    iterateIndexed((i, tupledArg) => {\r\n        res1[i] = tupledArg[0];\r\n        res2[i] = tupledArg[1];\r\n    }, array);\r\n    return [res1, res2];\r\n}\r\n\r\nexport function unzip3(array) {\r\n    const len = array.length | 0;\r\n    const res1 = new Array(len);\r\n    const res2 = new Array(len);\r\n    const res3 = new Array(len);\r\n    iterateIndexed((i, tupledArg) => {\r\n        res1[i] = tupledArg[0];\r\n        res2[i] = tupledArg[1];\r\n        res3[i] = tupledArg[2];\r\n    }, array);\r\n    return [res1, res2, res3];\r\n}\r\n\r\nexport function zip(array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    const result = new Array(array1.length);\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        result[i] = [array1[i], array2[i]];\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function zip3(array1, array2, array3) {\r\n    if ((array1.length !== array2.length) ? true : (array2.length !== array3.length)) {\r\n        differentLengths();\r\n    }\r\n    const result = new Array(array1.length);\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        result[i] = [array1[i], array2[i], array3[i]];\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function chunkBySize(chunkSize, array) {\r\n    if (chunkSize < 1) {\r\n        throw (new Error(\"The input must be positive.\\\\nParameter name: size\"));\r\n    }\r\n    if (array.length === 0) {\r\n        return [[]];\r\n    }\r\n    else {\r\n        const result = [];\r\n        for (let x = 0; x <= ((~(~Math.ceil(array.length / chunkSize))) - 1); x++) {\r\n            let slice;\r\n            const start_1 = (x * chunkSize) | 0;\r\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\r\n            result.push(slice);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function splitAt(index, array) {\r\n    let start;\r\n    if ((index < 0) ? true : (index > array.length)) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    return [(start = 0, array.slice(start, (start + index))), array.slice(index)];\r\n}\r\n\r\nexport function compareWith(comparer, source1, source2) {\r\n    if (source1 == null) {\r\n        if (source2 == null) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    else if (source2 == null) {\r\n        return 1;\r\n    }\r\n    else {\r\n        const len1 = source1.length | 0;\r\n        const len2 = source2.length | 0;\r\n        const len = ((len1 < len2) ? len1 : len2) | 0;\r\n        let i = 0;\r\n        let res = 0;\r\n        while ((res === 0) && (i < len)) {\r\n            res = (comparer(source1[i], source2[i]) | 0);\r\n            i = ((i + 1) | 0);\r\n        }\r\n        if (res !== 0) {\r\n            return res | 0;\r\n        }\r\n        else if (len1 > len2) {\r\n            return 1;\r\n        }\r\n        else if (len1 < len2) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport function compareTo(comparer, source1, source2) {\r\n    if (source1 == null) {\r\n        if (source2 == null) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    else if (source2 == null) {\r\n        return 1;\r\n    }\r\n    else {\r\n        const len1 = source1.length | 0;\r\n        const len2 = source2.length | 0;\r\n        if (len1 > len2) {\r\n            return 1;\r\n        }\r\n        else if (len1 < len2) {\r\n            return -1;\r\n        }\r\n        else {\r\n            let i = 0;\r\n            let res = 0;\r\n            while ((res === 0) && (i < len1)) {\r\n                res = (comparer(source1[i], source2[i]) | 0);\r\n                i = ((i + 1) | 0);\r\n            }\r\n            return res | 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport function equalsWith(equals, array1, array2) {\r\n    if (array1 == null) {\r\n        if (array2 == null) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    else if (array2 == null) {\r\n        return false;\r\n    }\r\n    else {\r\n        let i = 0;\r\n        let result = true;\r\n        const length1 = array1.length | 0;\r\n        const length2 = array2.length | 0;\r\n        if (length1 > length2) {\r\n            return false;\r\n        }\r\n        else if (length1 < length2) {\r\n            return false;\r\n        }\r\n        else {\r\n            while ((i < length1) && result) {\r\n                result = equals(array1[i], array2[i]);\r\n                i = ((i + 1) | 0);\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n}\r\n\r\nexport function exactlyOne(array) {\r\n    if (array.length === 1) {\r\n        return array[0];\r\n    }\r\n    else if (array.length === 0) {\r\n        throw (new Error(\"The input sequence was empty\\\\nParameter name: array\"));\r\n    }\r\n    else {\r\n        throw (new Error(\"Input array too long\\\\nParameter name: array\"));\r\n    }\r\n}\r\n\r\nexport function tryExactlyOne(array) {\r\n    if (array.length === 1) {\r\n        return some(array[0]);\r\n    }\r\n    else {\r\n        return void 0;\r\n    }\r\n}\r\n\r\nexport function head(array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    else {\r\n        return array[0];\r\n    }\r\n}\r\n\r\nexport function tryHead(array) {\r\n    if (array.length === 0) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[0]);\r\n    }\r\n}\r\n\r\nexport function tail(array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"Not enough elements\\\\nParameter name: array\"));\r\n    }\r\n    return array.slice(1);\r\n}\r\n\r\nexport function item(index, array) {\r\n    return array[index];\r\n}\r\n\r\nexport function tryItem(index, array) {\r\n    if ((index < 0) ? true : (index >= array.length)) {\r\n        return void 0;\r\n    }\r\n    else {\r\n        return some(array[index]);\r\n    }\r\n}\r\n\r\nexport function foldBackIndexed(folder, array, state) {\r\n    return array.reduceRight(((delegateArg, delegateArg_1, delegateArg_2) => folder(delegateArg_2, delegateArg_1, delegateArg)), state);\r\n}\r\n\r\nexport function foldBack(folder, array, state) {\r\n    return array.reduceRight(((delegateArg, delegateArg_1) => folder(delegateArg_1, delegateArg)), state);\r\n}\r\n\r\nexport function foldIndexed2(folder, state, array1, array2) {\r\n    let acc = state;\r\n    if (array1.length !== array2.length) {\r\n        throw (new Error(\"Arrays have different lengths\"));\r\n    }\r\n    for (let i = 0; i <= (array1.length - 1); i++) {\r\n        acc = folder(i, acc, array1[i], array2[i]);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function fold2(folder, state, array1, array2) {\r\n    return foldIndexed2((_arg, acc, x, y) => folder(acc, x, y), state, array1, array2);\r\n}\r\n\r\nexport function foldBackIndexed2(folder, array1, array2, state) {\r\n    let acc = state;\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    const size = array1.length | 0;\r\n    for (let i = 1; i <= size; i++) {\r\n        acc = folder(i - 1, array1[size - i], array2[size - i], acc);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function foldBack2(f, array1, array2, state) {\r\n    return foldBackIndexed2((_arg, x, y, acc) => f(x, y, acc), array1, array2, state);\r\n}\r\n\r\nexport function reduce(reduction, array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\"));\r\n    }\r\n    const reduction_1 = reduction;\r\n    return array.reduce(reduction_1);\r\n}\r\n\r\nexport function reduceBack(reduction, array) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\"));\r\n    }\r\n    const reduction_1 = reduction;\r\n    return array.reduceRight(reduction_1);\r\n}\r\n\r\nexport function forAll2(predicate, array1, array2) {\r\n    return fold2((acc, x, y) => (acc && predicate(x, y)), true, array1, array2);\r\n}\r\n\r\nexport function existsOffset(predicate_mut, array_mut, index_mut) {\r\n    existsOffset:\r\n    while (true) {\r\n        const predicate = predicate_mut, array = array_mut, index = index_mut;\r\n        if (index === array.length) {\r\n            return false;\r\n        }\r\n        else if (predicate(array[index])) {\r\n            return true;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            array_mut = array;\r\n            index_mut = (index + 1);\r\n            continue existsOffset;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function exists(predicate, array) {\r\n    return existsOffset(predicate, array, 0);\r\n}\r\n\r\nexport function existsOffset2(predicate_mut, array1_mut, array2_mut, index_mut) {\r\n    existsOffset2:\r\n    while (true) {\r\n        const predicate = predicate_mut, array1 = array1_mut, array2 = array2_mut, index = index_mut;\r\n        if (index === array1.length) {\r\n            return false;\r\n        }\r\n        else if (predicate(array1[index], array2[index])) {\r\n            return true;\r\n        }\r\n        else {\r\n            predicate_mut = predicate;\r\n            array1_mut = array1;\r\n            array2_mut = array2;\r\n            index_mut = (index + 1);\r\n            continue existsOffset2;\r\n        }\r\n        break;\r\n    }\r\n}\r\n\r\nexport function exists2(predicate, array1, array2) {\r\n    if (array1.length !== array2.length) {\r\n        differentLengths();\r\n    }\r\n    return existsOffset2(predicate, array1, array2, 0);\r\n}\r\n\r\nexport function sum(array, adder) {\r\n    let acc = adder.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        acc = adder.Add(acc, array[i]);\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function sumBy(projection, array, adder) {\r\n    let acc = adder.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        acc = adder.Add(acc, projection(array[i]));\r\n    }\r\n    return acc;\r\n}\r\n\r\nexport function maxBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function max(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? y : x), xs);\r\n}\r\n\r\nexport function minBy(projection, xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(projection(y), projection(x)) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function min(xs, comparer) {\r\n    return reduce((x, y) => ((comparer.Compare(y, x) > 0) ? x : y), xs);\r\n}\r\n\r\nexport function average(array, averager) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    let total = averager.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        total = averager.Add(total, array[i]);\r\n    }\r\n    return averager.DivideByInt(total, array.length);\r\n}\r\n\r\nexport function averageBy(projection, array, averager) {\r\n    if (array.length === 0) {\r\n        throw (new Error(\"The input array was empty\\\\nParameter name: array\"));\r\n    }\r\n    let total = averager.GetZero();\r\n    for (let i = 0; i <= (array.length - 1); i++) {\r\n        total = averager.Add(total, projection(array[i]));\r\n    }\r\n    return averager.DivideByInt(total, array.length);\r\n}\r\n\r\nexport function windowed(windowSize, source) {\r\n    if (windowSize <= 0) {\r\n        throw (new Error(\"windowSize must be positive\"));\r\n    }\r\n    let res;\r\n    const len = max_1(comparePrimitives, 0, (source.length - windowSize) + 1) | 0;\r\n    res = (new Array(len));\r\n    for (let i = windowSize; i <= source.length; i++) {\r\n        res[i - windowSize] = source.slice(i - windowSize, (i - 1) + 1);\r\n    }\r\n    return res;\r\n}\r\n\r\nexport function splitInto(chunks, array) {\r\n    if (chunks < 1) {\r\n        throw (new Error(\"The input must be positive.\\\\nParameter name: chunks\"));\r\n    }\r\n    if (array.length === 0) {\r\n        return [[]];\r\n    }\r\n    else {\r\n        const result = [];\r\n        const chunks_1 = min_1(comparePrimitives, chunks, array.length) | 0;\r\n        const minChunkSize = (~(~(array.length / chunks_1))) | 0;\r\n        const chunksWithExtraItem = (array.length % chunks_1) | 0;\r\n        for (let i = 0; i <= (chunks_1 - 1); i++) {\r\n            const chunkSize = ((i < chunksWithExtraItem) ? (minChunkSize + 1) : minChunkSize) | 0;\r\n            let slice;\r\n            const start_1 = ((i * minChunkSize) + min_1(comparePrimitives, chunksWithExtraItem, i)) | 0;\r\n            slice = (array.slice(start_1, (start_1 + chunkSize)));\r\n            result.push(slice);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function transpose(arrays, cons) {\r\n    const arrays_1 = Array.isArray(arrays) ? arrays : (Array.from(arrays));\r\n    const len = arrays_1.length | 0;\r\n    if (len === 0) {\r\n        return new Array(0);\r\n    }\r\n    else {\r\n        const firstArray = arrays_1[0];\r\n        const lenInner = firstArray.length | 0;\r\n        if (!forAll((a) => (a.length === lenInner), arrays_1)) {\r\n            differentLengths();\r\n        }\r\n        const result = new Array(lenInner);\r\n        for (let i = 0; i <= (lenInner - 1); i++) {\r\n            result[i] = Helpers_allocateArrayFromCons(cons, len);\r\n            for (let j = 0; j <= (len - 1); j++) {\r\n                result[i][j] = arrays_1[j][i];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport function insertAt(index, y, xs) {\r\n    const len = xs.length | 0;\r\n    if ((index < 0) ? true : (index > len)) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    const target = new xs.constructor(len + 1);\r\n    for (let i = 0; i <= (index - 1); i++) {\r\n        target[i] = xs[i];\r\n    }\r\n    target[index] = y;\r\n    for (let i_1 = index; i_1 <= (len - 1); i_1++) {\r\n        target[i_1 + 1] = xs[i_1];\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function insertManyAt(index, ys, xs) {\r\n    const len = xs.length | 0;\r\n    if ((index < 0) ? true : (index > len)) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    const ys_1 = Array.from(ys);\r\n    const len2 = ys_1.length | 0;\r\n    const target = new xs.constructor(len + len2);\r\n    for (let i = 0; i <= (index - 1); i++) {\r\n        target[i] = xs[i];\r\n    }\r\n    for (let i_1 = 0; i_1 <= (len2 - 1); i_1++) {\r\n        target[index + i_1] = ys_1[i_1];\r\n    }\r\n    for (let i_2 = index; i_2 <= (len - 1); i_2++) {\r\n        target[i_2 + len2] = xs[i_2];\r\n    }\r\n    return target;\r\n}\r\n\r\nexport function removeAt(index, xs) {\r\n    if ((index < 0) ? true : (index >= xs.length)) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    let i = -1;\r\n    return filter((_arg) => {\r\n        i = ((i + 1) | 0);\r\n        return i !== index;\r\n    }, xs);\r\n}\r\n\r\nexport function removeManyAt(index, count, xs) {\r\n    let i = -1;\r\n    let status = -1;\r\n    const ys = filter((_arg) => {\r\n        i = ((i + 1) | 0);\r\n        if (i === index) {\r\n            status = 0;\r\n            return false;\r\n        }\r\n        else if (i > index) {\r\n            if (i < (index + count)) {\r\n                return false;\r\n            }\r\n            else {\r\n                status = 1;\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }, xs);\r\n    const status_1 = (((status === 0) && ((i + 1) === (index + count))) ? 1 : status) | 0;\r\n    if (status_1 < 1) {\r\n        const arg = (status_1 < 0) ? \"index\" : \"count\";\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + arg));\r\n    }\r\n    return ys;\r\n}\r\n\r\nexport function updateAt(index, y, xs) {\r\n    const len = xs.length | 0;\r\n    if ((index < 0) ? true : (index >= len)) {\r\n        throw (new Error((SR_indexOutOfBounds + \"\\\\nParameter name: \") + \"index\"));\r\n    }\r\n    const target = new xs.constructor(len);\r\n    for (let i = 0; i <= (len - 1); i++) {\r\n        target[i] = ((i === index) ? y : xs[i]);\r\n    }\r\n    return target;\r\n}\r\n\r\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.solve = exports.defaultOptions = exports.backupDefaultOptions = exports.tableauModel = exports.update = exports.index = exports.inRange = exports.equalTo = exports.greaterEq = exports.lessEq = void 0;\nconst heap_1 = __importDefault(require(\"heap\"));\n// Actual code starts here.\n/**\n * Returns a `Constraint` that specifies something should be less than or equal to `value`.\n * Equivalent to `{ max: value }`.\n */\nconst lessEq = (value) => ({ max: value });\nexports.lessEq = lessEq;\n/**\n * Returns a `Constraint` that specifies something should be greater than or equal to `value`.\n * Equivalent to `{ min: value }`.\n */\nconst greaterEq = (value) => ({ min: value });\nexports.greaterEq = greaterEq;\n/**\n * Returns a `Constraint` that specifies something should be exactly equal to `value`.\n * Equivalent to `{ equal: value }`.\n */\nconst equalTo = (value) => ({ equal: value });\nexports.equalTo = equalTo;\n/**\n * Returns a `Constraint` that specifies something should be between `lower` and `upper` (both inclusive).\n * Equivalent to `{ min: lower, max: upper }`.\n */\nconst inRange = (lower, upper) => ({\n    max: upper,\n    min: lower\n});\nexports.inRange = inRange;\n/** Intended to be called internally. It gives the element at the row and col of the tableau. */\nconst index = (tableau, row, col) => tableau.matrix[row * tableau.width + col];\nexports.index = index;\n/** Intended to be called internally. It overwrites the element at the row and col of the tableau. */\nconst update = (tableau, row, col, value) => {\n    tableau.matrix[row * tableau.width + col] = value;\n};\nexports.update = update;\nconst convertToIterable = (msg, seq) => {\n    if (seq == null)\n        throw `${msg} was null or undefined.`;\n    if (typeof seq[Symbol.iterator] === \"function\")\n        return seq;\n    if (typeof seq === \"object\")\n        return Object.entries(seq);\n    throw `${msg} was not an object or iterable.`;\n};\nconst convertToSet = (set) => set === true ? true\n    : set === false ? new Set()\n        : set instanceof Set ? set\n            : new Set(set);\n/** Intended to be called internally. It constructs a Tableau from a `Model`. */\nconst tableauModel = (model) => {\n    if (model.variables == null)\n        throw \"variables was null or undefined.\";\n    if (model.constraints == null)\n        throw \"constraints was null or undefined.\";\n    const sign = model.direction === \"maximize\" || model.direction == null ? 1\n        : model.direction === \"minimize\" ? -1\n            : 0;\n    if (sign === 0)\n        throw `'${model.direction}' is not a valid optimization direction. Should be 'maximize', 'minimize', or left blank.`;\n    const variables = Array.isArray(model.variables) ? model.variables\n        : typeof model.variables[Symbol.iterator] === \"function\" ? Array.from(model.variables)\n            : typeof model.variables === \"object\" ? Object.entries(model.variables)\n                : null;\n    if (variables === null)\n        throw \"variables was not an object or iterable.\";\n    const binaryConstraintCol = [];\n    const intVars = [];\n    if (model.integers || model.binaries) {\n        const binaryVariables = convertToSet(model.binaries);\n        const integerVariables = binaryVariables === true ? true : convertToSet(model.integers);\n        for (let i = 1; i <= variables.length; i++) {\n            const [key,] = variables[i - 1];\n            if (binaryVariables === true || binaryVariables.has(key)) {\n                binaryConstraintCol.push(i);\n                intVars.push(i);\n            }\n            else if (integerVariables === true || integerVariables.has(key)) {\n                intVars.push(i);\n            }\n        }\n    }\n    const constraints = new Map();\n    for (const [key, constraint] of convertToIterable(\"constraints\", model.constraints)) {\n        if (constraint == null)\n            throw \"A constraint was null or undefined.\";\n        const bounds = constraints.get(key) ?? { row: NaN, lower: -Infinity, upper: Infinity };\n        bounds.lower = Math.max(bounds.lower, constraint.equal ?? constraint.min ?? -Infinity);\n        bounds.upper = Math.min(bounds.upper, constraint.equal ?? constraint.max ?? Infinity);\n        //if (rows.lower > rows.upper) return [\"infeasible\", NaN]\n        if (!constraints.has(key))\n            constraints.set(key, bounds);\n    }\n    let numConstraints = 1;\n    for (const constraint of constraints.values()) {\n        constraint.row = numConstraints;\n        numConstraints +=\n            (Number.isFinite(constraint.lower) ? 1 : 0)\n                + (Number.isFinite(constraint.upper) ? 1 : 0);\n    }\n    const width = variables.length + 1;\n    const height = numConstraints + binaryConstraintCol.length;\n    const numVars = width + height;\n    const tableau = {\n        matrix: new Float64Array(width * height),\n        width: width,\n        height: height,\n        positionOfVariable: new Int32Array(numVars),\n        variableAtPosition: new Int32Array(numVars)\n    };\n    for (let i = 0; i < numVars; i++) {\n        tableau.positionOfVariable[i] = i;\n        tableau.variableAtPosition[i] = i;\n    }\n    const hasObjective = \"objective\" in model;\n    for (let c = 1; c < width; c++) {\n        for (const [constraint, coef] of convertToIterable(\"A variable\", variables[c - 1][1])) {\n            if (hasObjective && constraint === model.objective) {\n                (0, exports.update)(tableau, 0, c, sign * coef);\n            }\n            const bounds = constraints.get(constraint);\n            if (bounds != null) {\n                if (Number.isFinite(bounds.upper)) {\n                    (0, exports.update)(tableau, bounds.row, c, coef);\n                    if (Number.isFinite(bounds.lower)) {\n                        (0, exports.update)(tableau, bounds.row + 1, c, -coef);\n                    }\n                }\n                else if (Number.isFinite(bounds.lower)) {\n                    (0, exports.update)(tableau, bounds.row, c, -coef);\n                }\n            }\n        }\n    }\n    for (const bounds of constraints.values()) {\n        if (Number.isFinite(bounds.upper)) {\n            (0, exports.update)(tableau, bounds.row, 0, bounds.upper);\n            if (Number.isFinite(bounds.lower)) {\n                (0, exports.update)(tableau, bounds.row + 1, 0, -bounds.lower);\n            }\n        }\n        else if (Number.isFinite(bounds.lower)) {\n            (0, exports.update)(tableau, bounds.row, 0, -bounds.lower);\n        }\n    }\n    for (let b = 0; b < binaryConstraintCol.length; b++) {\n        const row = numConstraints + b;\n        (0, exports.update)(tableau, row, 0, 1);\n        (0, exports.update)(tableau, row, binaryConstraintCol[b], 1);\n    }\n    return {\n        tableau: tableau,\n        sign: sign,\n        variables: variables,\n        integers: intVars\n    };\n};\nexports.tableauModel = tableauModel;\nconst pivot = (tableau, row, col) => {\n    const quotient = (0, exports.index)(tableau, row, col);\n    const leaving = tableau.variableAtPosition[tableau.width + row];\n    const entering = tableau.variableAtPosition[col];\n    tableau.variableAtPosition[tableau.width + row] = entering;\n    tableau.variableAtPosition[col] = leaving;\n    tableau.positionOfVariable[leaving] = col;\n    tableau.positionOfVariable[entering] = tableau.width + row;\n    const nonZeroColumns = [];\n    // (1 / quotient) * R_pivot -> R_pivot\n    for (let c = 0; c < tableau.width; c++) {\n        const value = (0, exports.index)(tableau, row, c);\n        if (Math.abs(value) > 1E-16) {\n            (0, exports.update)(tableau, row, c, value / quotient);\n            nonZeroColumns.push(c);\n        }\n        else {\n            (0, exports.update)(tableau, row, c, 0);\n        }\n    }\n    (0, exports.update)(tableau, row, col, 1 / quotient);\n    // -M[r, col] * R_pivot + R_r -> R_r\n    for (let r = 0; r < tableau.height; r++) {\n        if (r === row)\n            continue;\n        const coef = (0, exports.index)(tableau, r, col);\n        if (Math.abs(coef) > 1E-16) {\n            for (let i = 0; i < nonZeroColumns.length; i++) {\n                const c = nonZeroColumns[i];\n                (0, exports.update)(tableau, r, c, (0, exports.index)(tableau, r, c) - coef * (0, exports.index)(tableau, row, c));\n            }\n            (0, exports.update)(tableau, r, col, -coef / quotient);\n        }\n    }\n};\n// Checks if the simplex method has encountered a cycle.\nconst hasCycle = (history, tableau, row, col) => {\n    // This whole function seems somewhat inefficient,\n    // but there was no? noticable impact in the benchmarks.\n    history.push([tableau.variableAtPosition[tableau.width + row], tableau.variableAtPosition[col]]);\n    // the minimum length of a cycle is 6\n    for (let length = 6; length <= Math.floor(history.length / 2); length++) {\n        let cycle = true;\n        for (let i = 0; i < length; i++) {\n            const item = history.length - 1 - i;\n            const [row1, col1] = history[item];\n            const [row2, col2] = history[item - length];\n            if (row1 !== row2 || col1 !== col2) {\n                cycle = false;\n                break;\n            }\n        }\n        if (cycle)\n            return true;\n    }\n    return false;\n};\nconst roundToPrecision = (num, precision) => {\n    const rounding = Math.round(1 / precision);\n    return Math.round((num + Number.EPSILON) * rounding) / rounding;\n};\n// Finds the optimal solution given some basic feasible solution.\nconst phase2 = (tableau, options) => {\n    const pivotHistory = [];\n    const precision = options.precision;\n    for (let iter = 0; iter < options.maxPivots; iter++) {\n        // Find the entering column/variable\n        let col = 0;\n        let value = precision;\n        for (let c = 1; c < tableau.width; c++) {\n            const reducedCost = (0, exports.index)(tableau, 0, c);\n            if (reducedCost > value) {\n                value = reducedCost;\n                col = c;\n            }\n        }\n        if (col === 0)\n            return [\"optimal\", roundToPrecision((0, exports.index)(tableau, 0, 0), precision)];\n        // Find the leaving row/variable\n        let row = 0;\n        let minRatio = Infinity;\n        for (let r = 1; r < tableau.height; r++) {\n            const value = (0, exports.index)(tableau, r, col);\n            if (value <= precision)\n                continue; // pivot entry must be positive\n            const rhs = (0, exports.index)(tableau, r, 0);\n            const ratio = rhs / value;\n            if (ratio < minRatio) {\n                row = r;\n                if (minRatio <= precision)\n                    break; // ratio is 0, lowest possible\n                minRatio = ratio;\n            }\n        }\n        if (row === 0)\n            return [\"unbounded\", col];\n        if (options.checkCycles && hasCycle(pivotHistory, tableau, row, col))\n            return [\"cycled\", NaN];\n        pivot(tableau, row, col);\n    }\n    return [\"cycled\", NaN];\n};\n// Transforms a tableau into a basic feasible solution.\nconst phase1 = (tableau, options) => {\n    const pivotHistory = [];\n    const precision = options.precision;\n    for (let iter = 0; iter < options.maxPivots; iter++) {\n        // Find the leaving row/variable\n        let row = 0;\n        let rhs = -precision;\n        for (let r = 1; r < tableau.height; r++) {\n            const value = (0, exports.index)(tableau, r, 0);\n            if (value < rhs) {\n                rhs = value;\n                row = r;\n            }\n        }\n        if (row === 0)\n            return phase2(tableau, options);\n        // Find the entering column/variable\n        let col = 0;\n        let maxRatio = -Infinity;\n        for (let c = 1; c < tableau.width; c++) {\n            const coefficient = (0, exports.index)(tableau, row, c);\n            if (coefficient < -precision) {\n                const ratio = -(0, exports.index)(tableau, 0, c) / coefficient;\n                if (ratio > maxRatio) {\n                    maxRatio = ratio;\n                    col = c;\n                }\n            }\n        }\n        if (col === 0)\n            return [\"infeasible\", NaN];\n        if (options.checkCycles && hasCycle(pivotHistory, tableau, row, col))\n            return [\"cycled\", NaN];\n        pivot(tableau, row, col);\n    }\n    return [\"cycled\", NaN];\n};\n// Creates a solution object representing the optimal solution (if any).\nconst solution = (tabmod, status, result, precision, includeZeroVariables) => {\n    if (status === \"optimal\" || (status === \"timedout\" && !Number.isNaN(result))) {\n        const variables = [];\n        for (let i = 0; i < tabmod.variables.length; i++) {\n            const variable = tabmod.variables[i][0];\n            const row = tabmod.tableau.positionOfVariable[i + 1] - tabmod.tableau.width;\n            const value = row >= 0 ? (0, exports.index)(tabmod.tableau, row, 0) : 0;\n            if (value > precision) {\n                variables.push([variable, roundToPrecision(value, precision)]);\n            }\n            else if (includeZeroVariables) {\n                variables.push([variable, 0]);\n            }\n        }\n        return {\n            status: status,\n            result: -tabmod.sign * result,\n            variables: variables\n        };\n    }\n    else if (status === \"unbounded\") {\n        const variable = tabmod.tableau.variableAtPosition[result] - 1;\n        return {\n            status: \"unbounded\",\n            result: tabmod.sign * Infinity,\n            variables: 0 <= variable && variable < tabmod.variables.length\n                ? [[tabmod.variables[variable][0], Infinity]]\n                : []\n        };\n    }\n    else {\n        // infeasible | cycled | (timedout and result is NaN)\n        return {\n            status: status,\n            result: NaN,\n            variables: []\n        };\n    }\n};\nconst buffer = (matrixLength, posVarLength) => ({\n    matrix: new Float64Array(matrixLength),\n    positionOfVariable: new Int32Array(posVarLength),\n    variableAtPosition: new Int32Array(posVarLength)\n});\n// Creates a new tableau with additional cut constraints from a buffer.\nconst applyCuts = (tableau, { matrix, positionOfVariable, variableAtPosition }, cuts) => {\n    matrix.set(tableau.matrix);\n    for (let i = 0; i < cuts.length; i++) {\n        const [sign, variable, value] = cuts[i];\n        const r = (tableau.height + i) * tableau.width;\n        const pos = tableau.positionOfVariable[variable];\n        if (pos < tableau.width) {\n            matrix[r] = sign * value;\n            matrix.fill(0, r + 1, r + tableau.width);\n            matrix[r + pos] = sign;\n        }\n        else {\n            const row = (pos - tableau.width) * tableau.width;\n            matrix[r] = sign * (value - matrix[row]);\n            for (let c = 1; c < tableau.width; c++) {\n                matrix[r + c] = -sign * matrix[row + c];\n            }\n        }\n    }\n    positionOfVariable.set(tableau.positionOfVariable);\n    variableAtPosition.set(tableau.variableAtPosition);\n    const length = tableau.width + tableau.height + cuts.length;\n    for (let i = tableau.width + tableau.height; i < length; i++) {\n        positionOfVariable[i] = i;\n        variableAtPosition[i] = i;\n    }\n    return {\n        matrix: matrix.subarray(0, tableau.matrix.length + tableau.width * cuts.length),\n        width: tableau.width,\n        height: tableau.height + cuts.length,\n        positionOfVariable: positionOfVariable.subarray(0, length),\n        variableAtPosition: variableAtPosition.subarray(0, length)\n    };\n};\n// Finds the integer variable with the most fractional value.\nconst mostFractionalVar = (tableau, intVars) => {\n    let highestFrac = 0;\n    let variable = 0;\n    let value = 0;\n    for (let i = 0; i < intVars.length; i++) {\n        const intVar = intVars[i];\n        const row = tableau.positionOfVariable[intVar] - tableau.width;\n        if (row < 0)\n            continue;\n        const val = (0, exports.index)(tableau, row, 0);\n        const frac = Math.abs(val - Math.round(val));\n        if (frac > highestFrac) {\n            highestFrac = frac;\n            variable = intVar;\n            value = val;\n        }\n    }\n    return [variable, value, highestFrac];\n};\n// Runs the branch and cut algorithm to solve an integer problem.\n// Requires the non-integer solution as input.\nconst branchAndCut = (tabmod, initResult, options) => {\n    const [initVariable, initValue, initFrac] = mostFractionalVar(tabmod.tableau, tabmod.integers);\n    if (initFrac <= options.precision) {\n        // Wow, the initial solution is integer\n        return solution(tabmod, \"optimal\", initResult, options.precision, options.includeZeroVariables);\n    }\n    const branches = new heap_1.default((x, y) => x[0] - y[0]);\n    branches.push([initResult, [[-1, initVariable, Math.ceil(initValue)]]]);\n    branches.push([initResult, [[1, initVariable, Math.floor(initValue)]]]);\n    // Set aside arrays/buffers to be reused over the course of the algorithm.\n    // One set of buffers stores the state of the currrent best solution.\n    // The other is used to solve the current candidate solution.\n    // The two buffers are \"swapped\" once a new best solution is found.\n    const maxExtraRows = tabmod.integers.length * 2;\n    const matrixLength = tabmod.tableau.matrix.length + maxExtraRows * tabmod.tableau.width;\n    const posVarLength = tabmod.tableau.positionOfVariable.length + maxExtraRows;\n    const bufferA = buffer(matrixLength, posVarLength);\n    const bufferB = buffer(matrixLength, posVarLength);\n    let currentBuffer = true;\n    const optimalThreshold = initResult * (1 - tabmod.sign * options.tolerance);\n    const timeout = options.timeout + Date.now();\n    let timedout = Date.now() >= timeout; // in case options.timeout <= 0\n    let solutionFound = false;\n    let bestEval = Infinity;\n    let bestTableau = tabmod.tableau;\n    let iter = 0;\n    while (iter < options.maxIterations\n        && !branches.empty()\n        && bestEval >= optimalThreshold\n        && !timedout) {\n        const [relaxedEval, cuts] = branches.pop();\n        if (relaxedEval > bestEval)\n            break; // the remaining branches are worse than the current best solution\n        const tableau = applyCuts(tabmod.tableau, currentBuffer ? bufferA : bufferB, cuts);\n        const [status, result] = phase1(tableau, options);\n        // The initial tableau is not unbounded and adding more cuts/constraints cannot make it become unbounded\n        // assert(status !== \"unbounded\")\n        if (status === \"optimal\" && result < bestEval) {\n            const [variable, value, frac] = mostFractionalVar(tableau, tabmod.integers);\n            if (frac <= options.precision) {\n                // The solution is integer\n                solutionFound = true;\n                bestEval = result;\n                bestTableau = tableau;\n                currentBuffer = !currentBuffer;\n            }\n            else {\n                const cutsUpper = [];\n                const cutsLower = [];\n                for (let i = 0; i < cuts.length; i++) {\n                    const cut = cuts[i];\n                    const [dir, v,] = cut;\n                    if (v === variable) {\n                        dir < 0 ? cutsLower.push(cut) : cutsUpper.push(cut);\n                    }\n                    else {\n                        cutsUpper.push(cut);\n                        cutsLower.push(cut);\n                    }\n                }\n                cutsLower.push([1, variable, Math.floor(value)]);\n                cutsUpper.push([-1, variable, Math.ceil(value)]);\n                branches.push([result, cutsUpper]);\n                branches.push([result, cutsLower]);\n            }\n        }\n        // Otherwise, this branch's result is worse than the current best solution.\n        // This could be because this branch is infeasible or cycled.\n        // Either way, skip this branch and see if any other branches have a valid, better solution.\n        timedout = Date.now() >= timeout;\n        iter++;\n    }\n    // Did the solver \"timeout\"?\n    const unfinished = !branches.empty()\n        && bestEval < optimalThreshold\n        && (timedout || iter === options.maxIterations);\n    return solution({ ...tabmod, tableau: bestTableau }, unfinished ? \"timedout\"\n        : !solutionFound ? \"infeasible\"\n            : \"optimal\", solutionFound ? bestEval : NaN, options.precision, options.includeZeroVariables);\n};\n/**\n * The initial, default options for the solver.\n * Can be used to reset `defaultOptions`.\n * Do not try to mutate this object - it is frozen.\n*/\nexports.backupDefaultOptions = Object.freeze({\n    precision: 1E-08,\n    checkCycles: false,\n    maxPivots: 8192,\n    tolerance: 0,\n    timeout: Infinity,\n    maxIterations: 32768,\n    includeZeroVariables: false\n});\n/**\n * The default options used by the solver.\n * You may change these so that you do not have to\n * pass a custom `Options` object every time you call `solve`.\n */\nexports.defaultOptions = { ...exports.backupDefaultOptions };\n/**\n * Runs the solver on the given model and using the given options (if any).\n * @see `Model` on how to specify/create the model.\n * @see `Options` for the kinds of options available.\n * @see `Solution` as well for more detailed information on what is returned.\n */\nconst solve = (model, options) => {\n    if (model == null)\n        throw \"model was null or undefined.\";\n    const tabmod = (0, exports.tableauModel)(model);\n    const opt = { ...exports.backupDefaultOptions, ...exports.defaultOptions, ...options };\n    const [status, result] = phase1(tabmod.tableau, opt);\n    return (\n    // Non-integer problem, return the simplex result.\n    tabmod.integers.length === 0 ? solution(tabmod, status, result, opt.precision, opt.includeZeroVariables)\n        // Integer problem, run branchAndCut using the valid simplex result.\n        : status === \"optimal\" ? branchAndCut(tabmod, result, opt)\n            // The problem has integer variables, but the initial solution is either:\n            // 1) unbounded | infeasible => all branches will also be unbounded | infeasible\n            // 2) cycled => cannot get an initial solution, return invalid solution\n            : solution(tabmod, status, result, opt.precision, opt.includeZeroVariables));\n};\nexports.solve = solve;\n","module internal StardewValleyStonks.WebApp.Worker\n\nopen Fable.Core\nopen YALPS\n\ntype Input = Model<int, string> array\ntype Output = int Solution array\n\nlet [<Global>] private postMessage: Output -> unit = jsNative\n\nlet [<Global>] mutable private onmessage: Browser.Types.MessageEvent -> unit = jsNative\n\nonmessage <- fun message ->\n  match message.data with\n  | :? Input as data -> postMessage (data |> Array.map Solver.solve)\n  | _ -> assert false\n"],"names":["$bd777539733b4883$export$1e2f57719e155213","x","Array","isArray","ArrayBuffer","isView","module","exports","parcelRequire","Heap","defaultCmp","floor","heapify","heappop","heappush","heappushpop","heapreplace","insort","min","nlargest","nsmallest","updateItem","_siftdown","_siftup","factory","Math","y","a","lo","hi","cmp","mid","Error","length","splice","apply","concat","array","item","push","lastelt","returnitem","pop","_ref","i","_i","_len","_ref1","_results","_results1","_j","this","reverse","pos","indexOf","n","elem","result","slice","sort","los","startpos","newitem","parent","parentpos","childpos","endpos","rightpos","nodes","replace","pushpop","prototype","peek","contains","clear","empty","size","clone","heap","toArray","insert","top","front","has","copy","define","amd","call","$bd777539733b4883$export$f3f95c9f1920e9b5","static","o","idMap","set","count","get","WeakMap","Symbol","$581abe127a97b570$export$882a7a2eca8e1502","cons","len","$581abe127a97b570$export$871de8747c9eaa88","f","source","target","$91c5ada832831cfd$var$__importDefault","$91c5ada832831cfd$exports","__importDefault","mod","__esModule","default","Object","defineProperty","value","solve","defaultOptions","backupDefaultOptions","tableauModel","update","index","inRange","equalTo","greaterEq","lessEq","$91c5ada832831cfd$var$heap_1","max","equal","lower","upper","tableau","row","col","matrix","width","$91c5ada832831cfd$var$convertToIterable","msg","seq","iterator","entries","$91c5ada832831cfd$var$convertToSet","Set","model","variables","constraints","sign","direction","from","binaryConstraintCol","intVars","integers","binaries","binaryVariables","integerVariables","key","Map","constraint","bounds","NaN","Infinity","numConstraints","values","Number","isFinite","height","numVars","Float64Array","positionOfVariable","Int32Array","variableAtPosition","hasObjective","c","coef","objective","b","$91c5ada832831cfd$var$pivot","quotient","leaving","entering","nonZeroColumns","abs","r","$91c5ada832831cfd$var$hasCycle","history","cycle","row1","col1","row2","col2","$91c5ada832831cfd$var$roundToPrecision","num","precision","rounding","round","EPSILON","$91c5ada832831cfd$var$phase2","options","pivotHistory","iter","maxPivots","reducedCost","minRatio","ratio","checkCycles","$91c5ada832831cfd$var$phase1","rhs","maxRatio","coefficient","$91c5ada832831cfd$var$solution","tabmod","status","includeZeroVariables","isNaN","variable","$91c5ada832831cfd$var$buffer","matrixLength","posVarLength","$91c5ada832831cfd$var$applyCuts","cuts","fill","subarray","$91c5ada832831cfd$var$mostFractionalVar","highestFrac","intVar","val","frac","freeze","tolerance","timeout","maxIterations","opt","initResult","initVariable","initValue","initFrac","branches","ceil","maxExtraRows","bufferA","bufferB","currentBuffer","optimalThreshold","Date","now","timedout","solutionFound","bestEval","bestTableau","relaxedEval","cutsUpper","cutsLower","cut","dir","v","unfinished","$91c5ada832831cfd$var$branchAndCut","onmessage","message","matchValue","postMessage"],"version":3,"file":"Worker.5b01e5fb.js.map"}